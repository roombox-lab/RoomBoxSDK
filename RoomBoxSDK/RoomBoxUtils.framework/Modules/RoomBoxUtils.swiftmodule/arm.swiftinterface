// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.3.2 (swiftlang-1200.0.45 clang-1200.0.32.28)
// swift-module-flags: -target armv7-apple-ios10.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name RoomBoxUtils
import CommonCrypto
import CoreGraphics
import CoreTelephony
import CoreText
import Darwin
import Dispatch
import Foundation
import Foundation/*.NSObject*/
import LocalAuthentication
import MobileCoreServices
import Photos
import QuartzCore
@_exported import RoomBoxUtils
import RxSwift
import Security
import Swift
import SystemConfiguration
import UIKit.UIImage
import UIKit
import WebKit
extension Array {
  @inlinable internal init(reserveCapacity: Swift.Int) {
    self = Array<Element>()
    self.reserveCapacity(reserveCapacity)
  }
  @inlinable internal var slice: Swift.ArraySlice<Element> {
    get {
    self[self.startIndex ..< self.endIndex]
  }
  }
}
extension Array where Element == Swift.UInt8 {
  public init(hex: Swift.String)
  public func toHexString() -> Swift.String
}
extension Array where Element == Swift.UInt8 {
  @available(*, deprecated)
  public func chunks(size chunksize: Swift.Int) -> Swift.Array<Swift.Array<Element>>
  public func md5() -> [Element]
  public func sha1() -> [Element]
  public func sha224() -> [Element]
  public func sha256() -> [Element]
  public func sha384() -> [Element]
  public func sha512() -> [Element]
  public func sha2(_ variant: RoomBoxUtils.RBSHA2.Variant) -> [Element]
  public func sha3(_ variant: RoomBoxUtils.RBSHA3.Variant) -> [Element]
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public func crc16(seed: Swift.UInt16? = nil) -> Swift.UInt16
  public func encrypt(cipher: RoomBoxUtils.RBCipher) throws -> [Element]
  public func decrypt(cipher: RoomBoxUtils.RBCipher) throws -> [Element]
  public func authenticate<A>(with authenticator: A) throws -> [Element] where A : RoomBoxUtils.RBAuthenticator
}
extension Array where Element == Swift.UInt8 {
  public func toBase64() -> Swift.String
  public init(base64: Swift.String)
}
@_silgen_name("swift_getTypeByMangledNameInContext")
public func _getTypeByMangledNameInContext(_ name: Swift.UnsafePointer<Swift.UInt8>, _ nameLength: Swift.Int, genericContext: Swift.UnsafeRawPointer?, genericArguments: Swift.UnsafeRawPointer?) -> Any.Type?
@_silgen_name("swift_getTypeContextDescriptor")
public func _swift_getTypeContextDescriptor(_ RBMetadata: Swift.UnsafeRawPointer?) -> Swift.UnsafeRawPointer?
extension Data {
  public func checksum() -> Swift.UInt16
  public func md5() -> Foundation.Data
  public func sha1() -> Foundation.Data
  public func sha224() -> Foundation.Data
  public func sha256() -> Foundation.Data
  public func sha384() -> Foundation.Data
  public func sha512() -> Foundation.Data
  public func sha3(_ variant: RoomBoxUtils.RBSHA3.Variant) -> Foundation.Data
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Foundation.Data
  public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Foundation.Data
  public func crc16(seed: Swift.UInt16? = nil) -> Foundation.Data
  public func encrypt(cipher: RoomBoxUtils.RBCipher) throws -> Foundation.Data
  public func decrypt(cipher: RoomBoxUtils.RBCipher) throws -> Foundation.Data
  public func authenticate(with authenticator: RoomBoxUtils.RBAuthenticator) throws -> Foundation.Data
}
extension Data {
  public init(hex: Swift.String)
  public var bytes: Swift.Array<Swift.UInt8> {
    get
  }
  public func toHexString() -> Swift.String
}
extension Date {
  public func string(withFormat format: Swift.String = "dd/MM/yyyy HH:mm") -> Swift.String
}
extension Dictionary {
  public func jsonString(prettify: Swift.Bool = false) -> Swift.String?
}
extension FixedWidthInteger {
  @inlinable internal func bytes(totalBytes: Swift.Int = MemoryLayout<Self>.size) -> Swift.Array<Swift.UInt8> {
    arrayOfBytes(value: self.littleEndian, length: totalBytes)
    // TODO: adjust bytes order
    // var value = self.littleEndian
    // return withUnsafeBytes(of: &value, Array.init).reversed()
  }
}
public enum RB_AFError : Swift.Error {
  public enum MultipartEncodingFailureReason {
    case bodyPartURLInvalid(url: Foundation.URL)
    case bodyPartFilenameInvalid(in: Foundation.URL)
    case bodyPartFileNotReachable(at: Foundation.URL)
    case bodyPartFileNotReachableWithError(atURL: Foundation.URL, error: Swift.Error)
    case bodyPartFileIsDirectory(at: Foundation.URL)
    case bodyPartFileSizeNotAvailable(at: Foundation.URL)
    case bodyPartFileSizeQueryFailedWithError(forURL: Foundation.URL, error: Swift.Error)
    case bodyPartInputStreamCreationFailed(for: Foundation.URL)
    case outputStreamCreationFailed(for: Foundation.URL)
    case outputStreamFileAlreadyExists(at: Foundation.URL)
    case outputStreamURLInvalid(url: Foundation.URL)
    case outputStreamWriteFailed(error: Swift.Error)
    case inputStreamReadFailed(error: Swift.Error)
  }
  public enum ParameterEncodingFailureReason {
    case missingURL
    case jsonEncodingFailed(error: Swift.Error)
    case customEncodingFailed(error: Swift.Error)
  }
  public enum ParameterEncoderFailureReason {
    public enum RequiredComponent {
      case url
      case httpMethod(rawValue: Swift.String)
    }
    case missingRequiredComponent(RoomBoxUtils.RB_AFError.ParameterEncoderFailureReason.RequiredComponent)
    case encoderFailed(error: Swift.Error)
  }
  public enum ResponseValidationFailureReason {
    case dataFileNil
    case dataFileReadFailed(at: Foundation.URL)
    case missingContentType(acceptableContentTypes: [Swift.String])
    case unacceptableContentType(acceptableContentTypes: [Swift.String], responseContentType: Swift.String)
    case unacceptableStatusCode(code: Swift.Int)
    case customValidationFailed(error: Swift.Error)
  }
  public enum ResponseSerializationFailureReason {
    case inputDataNilOrZeroLength
    case inputFileNil
    case inputFileReadFailed(at: Foundation.URL)
    case stringSerializationFailed(encoding: Swift.String.Encoding)
    case jsonSerializationFailed(error: Swift.Error)
    case decodingFailed(error: Swift.Error)
    case customSerializationFailed(error: Swift.Error)
    case invalidEmptyResponse(type: Swift.String)
  }
  public enum ServerTrustFailureReason {
    public struct Output {
      public let host: Swift.String
      public let trust: Security.SecTrust
      public let status: Darwin.OSStatus
      public let result: Security.SecTrustResultType
    }
    case noRequiredEvaluator(host: Swift.String)
    case noCertificatesFound
    case noPublicKeysFound
    case policyApplicationFailed(trust: Security.SecTrust, policy: Security.SecPolicy, status: Darwin.OSStatus)
    case settingAnchorCertificatesFailed(status: Darwin.OSStatus, certificates: [Security.SecCertificate])
    case revocationPolicyCreationFailed
    case trustEvaluationFailed(error: Swift.Error?)
    case defaultEvaluationFailed(output: RoomBoxUtils.RB_AFError.ServerTrustFailureReason.Output)
    case hostValidationFailed(output: RoomBoxUtils.RB_AFError.ServerTrustFailureReason.Output)
    case revocationCheckFailed(output: RoomBoxUtils.RB_AFError.ServerTrustFailureReason.Output, options: RoomBoxUtils.RB_RevocationTrustEvaluator.Options)
    case certificatePinningFailed(host: Swift.String, trust: Security.SecTrust, pinnedCertificates: [Security.SecCertificate], serverCertificates: [Security.SecCertificate])
    case publicKeyPinningFailed(host: Swift.String, trust: Security.SecTrust, pinnedKeys: [Security.SecKey], serverKeys: [Security.SecKey])
    case customEvaluationFailed(error: Swift.Error)
  }
  public enum URLRequestValidationFailureReason {
    case bodyDataInGETRequest(Foundation.Data)
  }
  case createUploadableFailed(error: Swift.Error)
  case createURLRequestFailed(error: Swift.Error)
  case downloadedFileMoveFailed(error: Swift.Error, source: Foundation.URL, destination: Foundation.URL)
  case explicitlyCancelled
  case invalidURL(url: RoomBoxUtils.URLConvertible)
  case multipartEncodingFailed(reason: RoomBoxUtils.RB_AFError.MultipartEncodingFailureReason)
  case parameterEncodingFailed(reason: RoomBoxUtils.RB_AFError.ParameterEncodingFailureReason)
  case parameterEncoderFailed(reason: RoomBoxUtils.RB_AFError.ParameterEncoderFailureReason)
  case requestAdaptationFailed(error: Swift.Error)
  case requestRetryFailed(retryError: Swift.Error, originalError: Swift.Error)
  case responseValidationFailed(reason: RoomBoxUtils.RB_AFError.ResponseValidationFailureReason)
  case responseSerializationFailed(reason: RoomBoxUtils.RB_AFError.ResponseSerializationFailureReason)
  case serverTrustEvaluationFailed(reason: RoomBoxUtils.RB_AFError.ServerTrustFailureReason)
  case sessionDeinitialized
  case sessionInvalidated(error: Swift.Error?)
  case sessionTaskFailed(error: Swift.Error)
  case urlRequestValidationFailed(reason: RoomBoxUtils.RB_AFError.URLRequestValidationFailureReason)
}
extension Error {
  public var asAFError: RoomBoxUtils.RB_AFError? {
    get
  }
  public func asAFError(orFailWith message: @autoclosure () -> Swift.String, file: Swift.StaticString = #file, line: Swift.UInt = #line) -> RoomBoxUtils.RB_AFError
}
extension RB_AFError {
  public var isSessionDeinitializedError: Swift.Bool {
    get
  }
  public var isSessionInvalidatedError: Swift.Bool {
    get
  }
  public var isExplicitlyCancelledError: Swift.Bool {
    get
  }
  public var isInvalidURLError: Swift.Bool {
    get
  }
  public var isParameterEncodingError: Swift.Bool {
    get
  }
  public var isParameterEncoderError: Swift.Bool {
    get
  }
  public var isMultipartEncodingError: Swift.Bool {
    get
  }
  public var isRequestAdaptationError: Swift.Bool {
    get
  }
  public var isResponseValidationError: Swift.Bool {
    get
  }
  public var isResponseSerializationError: Swift.Bool {
    get
  }
  public var isServerTrustEvaluationError: Swift.Bool {
    get
  }
  public var isRequestRetryError: Swift.Bool {
    get
  }
  public var isCreateUploadableError: Swift.Bool {
    get
  }
  public var isCreateURLRequestError: Swift.Bool {
    get
  }
  public var isDownloadedFileMoveError: Swift.Bool {
    get
  }
  public var isSessionTaskError: Swift.Bool {
    get
  }
}
extension RB_AFError {
  public var urlConvertible: RoomBoxUtils.URLConvertible? {
    get
  }
  public var url: Foundation.URL? {
    get
  }
  public var underlyingError: Swift.Error? {
    get
  }
  public var acceptableContentTypes: [Swift.String]? {
    get
  }
  public var responseContentType: Swift.String? {
    get
  }
  public var responseCode: Swift.Int? {
    get
  }
  public var failedStringEncoding: Swift.String.Encoding? {
    get
  }
  public var sourceURL: Foundation.URL? {
    get
  }
  public var destinationURL: Foundation.URL? {
    get
  }
}
extension RB_AFError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public let RB_AF: RoomBoxUtils.RB_Session
public struct AlamofireExtension<ExtendedType> {
  public var type: ExtendedType {
    get
  }
  public init(_ type: ExtendedType)
}
public protocol AlamofireExtended {
  associatedtype ExtendedType
  static var af: RoomBoxUtils.AlamofireExtension<Self.ExtendedType>.Type { get set }
  var af: RoomBoxUtils.AlamofireExtension<Self.ExtendedType> { get set }
}
extension AlamofireExtended {
  public static var af: RoomBoxUtils.AlamofireExtension<Self>.Type {
    get
    set
  }
  public var af: RoomBoxUtils.AlamofireExtension<Self> {
    get
    set
  }
}
public protocol AuthenticationCredential {
  var requiresRefresh: Swift.Bool { get }
}
public protocol Authenticator : AnyObject {
  associatedtype Credential : RoomBoxUtils.AuthenticationCredential
  func apply(_ credential: Self.Credential, to urlRequest: inout Foundation.URLRequest)
  func refresh(_ credential: Self.Credential, for rb_session: RoomBoxUtils.RB_Session, completion: @escaping (Swift.Result<Self.Credential, Swift.Error>) -> Swift.Void)
  func didRequest(_ urlRequest: Foundation.URLRequest, with response: Foundation.HTTPURLResponse, failDueToAuthenticationError error: Swift.Error) -> Swift.Bool
  func isRequest(_ urlRequest: Foundation.URLRequest, authenticatedWith credential: Self.Credential) -> Swift.Bool
}
public enum AuthenticationError : Swift.Error {
  case missingCredential
  case excessiveRefresh
  public static func == (a: RoomBoxUtils.AuthenticationError, b: RoomBoxUtils.AuthenticationError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public class AuthenticationInterceptor<AuthenticatorType> : RoomBoxUtils.RB_RequestInterceptor where AuthenticatorType : RoomBoxUtils.Authenticator {
  public typealias Credential = AuthenticatorType.Credential
  public struct RefreshWindow {
    public let interval: Foundation.TimeInterval
    public let maximumAttempts: Swift.Int
    public init(interval: Foundation.TimeInterval = 30.0, maximumAttempts: Swift.Int = 5)
  }
  public var credential: RoomBoxUtils.AuthenticationInterceptor<AuthenticatorType>.Credential? {
    get
    set
  }
  public init(authenticator: AuthenticatorType, credential: RoomBoxUtils.AuthenticationInterceptor<AuthenticatorType>.Credential? = nil, refreshWindow: RoomBoxUtils.AuthenticationInterceptor<AuthenticatorType>.RefreshWindow? = RefreshWindow())
  public func adapt(_ urlRequest: Foundation.URLRequest, for rb_session: RoomBoxUtils.RB_Session, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  public func retry(_ rb_request: RoomBoxUtils.RB_Request, for rb_session: RoomBoxUtils.RB_Session, dueTo error: Swift.Error, completion: @escaping (RoomBoxUtils.RetryResult) -> Swift.Void)
  @objc deinit
}
public protocol CachedResponseHandler {
  func dataTask(_ task: Foundation.URLSessionDataTask, willCacheResponse response: Foundation.CachedURLResponse, completion: @escaping (Foundation.CachedURLResponse?) -> Swift.Void)
}
public struct ResponseCacher {
  public enum Behavior {
    case cache
    case doNotCache
    case modify((Foundation.URLSessionDataTask, Foundation.CachedURLResponse) -> Foundation.CachedURLResponse?)
  }
  public static let cache: RoomBoxUtils.ResponseCacher
  public static let doNotCache: RoomBoxUtils.ResponseCacher
  public let behavior: RoomBoxUtils.ResponseCacher.Behavior
  public init(behavior: RoomBoxUtils.ResponseCacher.Behavior)
}
extension ResponseCacher : RoomBoxUtils.CachedResponseHandler {
  public func dataTask(_ task: Foundation.URLSessionDataTask, willCacheResponse response: Foundation.CachedURLResponse, completion: @escaping (Foundation.CachedURLResponse?) -> Swift.Void)
}
public protocol EventMonitor {
  var queue: Dispatch.DispatchQueue { get }
  func urlSession(_ rb_session: Foundation.URLSession, didBecomeInvalidWithError error: Swift.Error?)
  func urlSession(_ rb_session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge)
  func urlSession(_ rb_session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  func urlSession(_ rb_session: Foundation.URLSession, taskNeedsNewBodyStream task: Foundation.URLSessionTask)
  func urlSession(_ rb_session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest rb_request: Foundation.URLRequest)
  func urlSession(_ rb_session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  func urlSession(_ rb_session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
  @available(OSX 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  func urlSession(_ rb_session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  func urlSession(_ rb_session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  func urlSession(_ rb_session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse)
  func urlSession(_ rb_session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  func urlSession(_ rb_session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  func urlSession(_ rb_session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didCreateInitialURLRequest urlRequest: Foundation.URLRequest)
  func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didFailToCreateURLRequestWithError error: RoomBoxUtils.RB_AFError)
  func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didAdaptInitialRequest initialRequest: Foundation.URLRequest, to adaptedRequest: Foundation.URLRequest)
  func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didFailToAdaptURLRequest initialRequest: Foundation.URLRequest, withError error: RoomBoxUtils.RB_AFError)
  func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didCreateURLRequest urlRequest: Foundation.URLRequest)
  func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didCreateTask task: Foundation.URLSessionTask)
  func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didGatherMetrics metrics: Foundation.URLSessionTaskMetrics)
  func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didFailTask task: Foundation.URLSessionTask, earlyWithError error: RoomBoxUtils.RB_AFError)
  func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didCompleteTask task: Foundation.URLSessionTask, with error: RoomBoxUtils.RB_AFError?)
  func requestIsRetrying(_ rb_request: RoomBoxUtils.RB_Request)
  func requestDidFinish(_ rb_request: RoomBoxUtils.RB_Request)
  func requestDidResume(_ rb_request: RoomBoxUtils.RB_Request)
  func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didResumeTask task: Foundation.URLSessionTask)
  func requestDidSuspend(_ rb_request: RoomBoxUtils.RB_Request)
  func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didSuspendTask task: Foundation.URLSessionTask)
  func requestDidCancel(_ rb_request: RoomBoxUtils.RB_Request)
  func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didCancelTask task: Foundation.URLSessionTask)
  func rb_request(_ rb_request: RoomBoxUtils.RB_DataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, withResult result: RoomBoxUtils.RB_Request.ValidationResult)
  func rb_request(_ rb_request: RoomBoxUtils.RB_DataRequest, didParseResponse response: RoomBoxUtils.RB_DataResponse<Foundation.Data?, RoomBoxUtils.RB_AFError>)
  func rb_request<Value>(_ rb_request: RoomBoxUtils.RB_DataRequest, didParseResponse response: RoomBoxUtils.RB_DataResponse<Value, RoomBoxUtils.RB_AFError>)
  func rb_request(_ rb_request: RoomBoxUtils.DataStreamRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, withResult result: RoomBoxUtils.RB_Request.ValidationResult)
  func rb_request<Value>(_ rb_request: RoomBoxUtils.DataStreamRequest, didParseStream result: Swift.Result<Value, RoomBoxUtils.RB_AFError>)
  func rb_request(_ rb_request: RoomBoxUtils.RB_UploadRequest, didCreateUploadable uploadable: RoomBoxUtils.RB_UploadRequest.Uploadable)
  func rb_request(_ rb_request: RoomBoxUtils.RB_UploadRequest, didFailToCreateUploadableWithError error: RoomBoxUtils.RB_AFError)
  func rb_request(_ rb_request: RoomBoxUtils.RB_UploadRequest, didProvideInputStream stream: Foundation.InputStream)
  func rb_request(_ rb_request: RoomBoxUtils.RB_DownloadRequest, didFinishDownloadingUsing task: Foundation.URLSessionTask, with result: Swift.Result<Foundation.URL, RoomBoxUtils.RB_AFError>)
  func rb_request(_ rb_request: RoomBoxUtils.RB_DownloadRequest, didCreateDestinationURL url: Foundation.URL)
  func rb_request(_ rb_request: RoomBoxUtils.RB_DownloadRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, fileURL: Foundation.URL?, withResult result: RoomBoxUtils.RB_Request.ValidationResult)
  func rb_request(_ rb_request: RoomBoxUtils.RB_DownloadRequest, didParseResponse response: RoomBoxUtils.DownloadResponse<Foundation.URL?, RoomBoxUtils.RB_AFError>)
  func rb_request<Value>(_ rb_request: RoomBoxUtils.RB_DownloadRequest, didParseResponse response: RoomBoxUtils.DownloadResponse<Value, RoomBoxUtils.RB_AFError>)
}
extension EventMonitor {
  public var queue: Dispatch.DispatchQueue {
    get
  }
  public func urlSession(_ rb_session: Foundation.URLSession, didBecomeInvalidWithError error: Swift.Error?)
  public func urlSession(_ rb_session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge)
  public func urlSession(_ rb_session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  public func urlSession(_ rb_session: Foundation.URLSession, taskNeedsNewBodyStream task: Foundation.URLSessionTask)
  public func urlSession(_ rb_session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest rb_request: Foundation.URLRequest)
  public func urlSession(_ rb_session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  public func urlSession(_ rb_session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
  public func urlSession(_ rb_session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  public func urlSession(_ rb_session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  public func urlSession(_ rb_session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse)
  public func urlSession(_ rb_session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  public func urlSession(_ rb_session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  public func urlSession(_ rb_session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  public func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didCreateInitialURLRequest urlRequest: Foundation.URLRequest)
  public func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didFailToCreateURLRequestWithError error: RoomBoxUtils.RB_AFError)
  public func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didAdaptInitialRequest initialRequest: Foundation.URLRequest, to adaptedRequest: Foundation.URLRequest)
  public func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didFailToAdaptURLRequest initialRequest: Foundation.URLRequest, withError error: RoomBoxUtils.RB_AFError)
  public func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didCreateURLRequest urlRequest: Foundation.URLRequest)
  public func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didCreateTask task: Foundation.URLSessionTask)
  public func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didGatherMetrics metrics: Foundation.URLSessionTaskMetrics)
  public func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didFailTask task: Foundation.URLSessionTask, earlyWithError error: RoomBoxUtils.RB_AFError)
  public func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didCompleteTask task: Foundation.URLSessionTask, with error: RoomBoxUtils.RB_AFError?)
  public func requestIsRetrying(_ rb_request: RoomBoxUtils.RB_Request)
  public func requestDidFinish(_ rb_request: RoomBoxUtils.RB_Request)
  public func requestDidResume(_ rb_request: RoomBoxUtils.RB_Request)
  public func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didResumeTask task: Foundation.URLSessionTask)
  public func requestDidSuspend(_ rb_request: RoomBoxUtils.RB_Request)
  public func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didSuspendTask task: Foundation.URLSessionTask)
  public func requestDidCancel(_ rb_request: RoomBoxUtils.RB_Request)
  public func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didCancelTask task: Foundation.URLSessionTask)
  public func rb_request(_ rb_request: RoomBoxUtils.RB_DataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, withResult result: RoomBoxUtils.RB_Request.ValidationResult)
  public func rb_request(_ rb_request: RoomBoxUtils.RB_DataRequest, didParseResponse response: RoomBoxUtils.RB_DataResponse<Foundation.Data?, RoomBoxUtils.RB_AFError>)
  public func rb_request<Value>(_ rb_request: RoomBoxUtils.RB_DataRequest, didParseResponse response: RoomBoxUtils.RB_DataResponse<Value, RoomBoxUtils.RB_AFError>)
  public func rb_request(_ rb_request: RoomBoxUtils.DataStreamRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, withResult result: RoomBoxUtils.RB_Request.ValidationResult)
  public func rb_request<Value>(_ rb_request: RoomBoxUtils.DataStreamRequest, didParseStream result: Swift.Result<Value, RoomBoxUtils.RB_AFError>)
  public func rb_request(_ rb_request: RoomBoxUtils.RB_UploadRequest, didCreateUploadable uploadable: RoomBoxUtils.RB_UploadRequest.Uploadable)
  public func rb_request(_ rb_request: RoomBoxUtils.RB_UploadRequest, didFailToCreateUploadableWithError error: RoomBoxUtils.RB_AFError)
  public func rb_request(_ rb_request: RoomBoxUtils.RB_UploadRequest, didProvideInputStream stream: Foundation.InputStream)
  public func rb_request(_ rb_request: RoomBoxUtils.RB_DownloadRequest, didFinishDownloadingUsing task: Foundation.URLSessionTask, with result: Swift.Result<Foundation.URL, RoomBoxUtils.RB_AFError>)
  public func rb_request(_ rb_request: RoomBoxUtils.RB_DownloadRequest, didCreateDestinationURL url: Foundation.URL)
  public func rb_request(_ rb_request: RoomBoxUtils.RB_DownloadRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, fileURL: Foundation.URL?, withResult result: RoomBoxUtils.RB_Request.ValidationResult)
  public func rb_request(_ rb_request: RoomBoxUtils.RB_DownloadRequest, didParseResponse response: RoomBoxUtils.DownloadResponse<Foundation.URL?, RoomBoxUtils.RB_AFError>)
  public func rb_request<Value>(_ rb_request: RoomBoxUtils.RB_DownloadRequest, didParseResponse response: RoomBoxUtils.DownloadResponse<Value, RoomBoxUtils.RB_AFError>)
}
@_hasMissingDesignatedInitializers final public class CompositeEventMonitor : RoomBoxUtils.EventMonitor {
  final public let queue: Dispatch.DispatchQueue
  final public func urlSession(_ rb_session: Foundation.URLSession, didBecomeInvalidWithError error: Swift.Error?)
  final public func urlSession(_ rb_session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge)
  final public func urlSession(_ rb_session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  final public func urlSession(_ rb_session: Foundation.URLSession, taskNeedsNewBodyStream task: Foundation.URLSessionTask)
  final public func urlSession(_ rb_session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest rb_request: Foundation.URLRequest)
  final public func urlSession(_ rb_session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  final public func urlSession(_ rb_session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
  @available(OSX 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  final public func urlSession(_ rb_session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  final public func urlSession(_ rb_session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  final public func urlSession(_ rb_session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse)
  final public func urlSession(_ rb_session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  final public func urlSession(_ rb_session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  final public func urlSession(_ rb_session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  final public func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didCreateInitialURLRequest urlRequest: Foundation.URLRequest)
  final public func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didFailToCreateURLRequestWithError error: RoomBoxUtils.RB_AFError)
  final public func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didAdaptInitialRequest initialRequest: Foundation.URLRequest, to adaptedRequest: Foundation.URLRequest)
  final public func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didFailToAdaptURLRequest initialRequest: Foundation.URLRequest, withError error: RoomBoxUtils.RB_AFError)
  final public func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didCreateURLRequest urlRequest: Foundation.URLRequest)
  final public func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didCreateTask task: Foundation.URLSessionTask)
  final public func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didGatherMetrics metrics: Foundation.URLSessionTaskMetrics)
  final public func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didFailTask task: Foundation.URLSessionTask, earlyWithError error: RoomBoxUtils.RB_AFError)
  final public func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didCompleteTask task: Foundation.URLSessionTask, with error: RoomBoxUtils.RB_AFError?)
  final public func requestIsRetrying(_ rb_request: RoomBoxUtils.RB_Request)
  final public func requestDidFinish(_ rb_request: RoomBoxUtils.RB_Request)
  final public func requestDidResume(_ rb_request: RoomBoxUtils.RB_Request)
  final public func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didResumeTask task: Foundation.URLSessionTask)
  final public func requestDidSuspend(_ rb_request: RoomBoxUtils.RB_Request)
  final public func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didSuspendTask task: Foundation.URLSessionTask)
  final public func requestDidCancel(_ rb_request: RoomBoxUtils.RB_Request)
  final public func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didCancelTask task: Foundation.URLSessionTask)
  final public func rb_request(_ rb_request: RoomBoxUtils.RB_DataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, withResult result: RoomBoxUtils.RB_Request.ValidationResult)
  final public func rb_request(_ rb_request: RoomBoxUtils.RB_DataRequest, didParseResponse response: RoomBoxUtils.RB_DataResponse<Foundation.Data?, RoomBoxUtils.RB_AFError>)
  final public func rb_request<Value>(_ rb_request: RoomBoxUtils.RB_DataRequest, didParseResponse response: RoomBoxUtils.RB_DataResponse<Value, RoomBoxUtils.RB_AFError>)
  final public func rb_request(_ rb_request: RoomBoxUtils.DataStreamRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, withResult result: RoomBoxUtils.RB_Request.ValidationResult)
  final public func rb_request<Value>(_ rb_request: RoomBoxUtils.DataStreamRequest, didParseStream result: Swift.Result<Value, RoomBoxUtils.RB_AFError>)
  final public func rb_request(_ rb_request: RoomBoxUtils.RB_UploadRequest, didCreateUploadable uploadable: RoomBoxUtils.RB_UploadRequest.Uploadable)
  final public func rb_request(_ rb_request: RoomBoxUtils.RB_UploadRequest, didFailToCreateUploadableWithError error: RoomBoxUtils.RB_AFError)
  final public func rb_request(_ rb_request: RoomBoxUtils.RB_UploadRequest, didProvideInputStream stream: Foundation.InputStream)
  final public func rb_request(_ rb_request: RoomBoxUtils.RB_DownloadRequest, didFinishDownloadingUsing task: Foundation.URLSessionTask, with result: Swift.Result<Foundation.URL, RoomBoxUtils.RB_AFError>)
  final public func rb_request(_ rb_request: RoomBoxUtils.RB_DownloadRequest, didCreateDestinationURL url: Foundation.URL)
  final public func rb_request(_ rb_request: RoomBoxUtils.RB_DownloadRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, fileURL: Foundation.URL?, withResult result: RoomBoxUtils.RB_Request.ValidationResult)
  final public func rb_request(_ rb_request: RoomBoxUtils.RB_DownloadRequest, didParseResponse response: RoomBoxUtils.DownloadResponse<Foundation.URL?, RoomBoxUtils.RB_AFError>)
  final public func rb_request<Value>(_ rb_request: RoomBoxUtils.RB_DownloadRequest, didParseResponse response: RoomBoxUtils.DownloadResponse<Value, RoomBoxUtils.RB_AFError>)
  @objc deinit
}
open class ClosureEventMonitor : RoomBoxUtils.EventMonitor {
  open var sessionDidBecomeInvalidWithError: ((Foundation.URLSession, Swift.Error?) -> Swift.Void)?
  open var taskDidReceiveChallenge: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.URLAuthenticationChallenge) -> Swift.Void)?
  open var taskDidSendBodyData: ((Foundation.URLSession, Foundation.URLSessionTask, Swift.Int64, Swift.Int64, Swift.Int64) -> Swift.Void)?
  open var taskNeedNewBodyStream: ((Foundation.URLSession, Foundation.URLSessionTask) -> Swift.Void)?
  open var taskWillPerformHTTPRedirection: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.HTTPURLResponse, Foundation.URLRequest) -> Swift.Void)?
  open var taskDidFinishCollectingMetrics: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.URLSessionTaskMetrics) -> Swift.Void)?
  open var taskDidComplete: ((Foundation.URLSession, Foundation.URLSessionTask, Swift.Error?) -> Swift.Void)?
  open var taskIsWaitingForConnectivity: ((Foundation.URLSession, Foundation.URLSessionTask) -> Swift.Void)?
  open var dataTaskDidReceiveData: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.Data) -> Swift.Void)?
  open var dataTaskWillCacheResponse: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.CachedURLResponse) -> Swift.Void)?
  open var downloadTaskDidFinishDownloadingToURL: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Foundation.URL) -> Swift.Void)?
  open var downloadTaskDidWriteData: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Swift.Int64, Swift.Int64, Swift.Int64) -> Swift.Void)?
  open var downloadTaskDidResumeAtOffset: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Swift.Int64, Swift.Int64) -> Swift.Void)?
  open var requestDidCreateInitialURLRequest: ((RoomBoxUtils.RB_Request, Foundation.URLRequest) -> Swift.Void)?
  open var requestDidFailToCreateURLRequestWithError: ((RoomBoxUtils.RB_Request, RoomBoxUtils.RB_AFError) -> Swift.Void)?
  open var requestDidAdaptInitialRequestToAdaptedRequest: ((RoomBoxUtils.RB_Request, Foundation.URLRequest, Foundation.URLRequest) -> Swift.Void)?
  open var requestDidFailToAdaptURLRequestWithError: ((RoomBoxUtils.RB_Request, Foundation.URLRequest, RoomBoxUtils.RB_AFError) -> Swift.Void)?
  open var requestDidCreateURLRequest: ((RoomBoxUtils.RB_Request, Foundation.URLRequest) -> Swift.Void)?
  open var requestDidCreateTask: ((RoomBoxUtils.RB_Request, Foundation.URLSessionTask) -> Swift.Void)?
  open var requestDidGatherMetrics: ((RoomBoxUtils.RB_Request, Foundation.URLSessionTaskMetrics) -> Swift.Void)?
  open var requestDidFailTaskEarlyWithError: ((RoomBoxUtils.RB_Request, Foundation.URLSessionTask, RoomBoxUtils.RB_AFError) -> Swift.Void)?
  open var requestDidCompleteTaskWithError: ((RoomBoxUtils.RB_Request, Foundation.URLSessionTask, RoomBoxUtils.RB_AFError?) -> Swift.Void)?
  open var requestIsRetrying: ((RoomBoxUtils.RB_Request) -> Swift.Void)?
  open var requestDidFinish: ((RoomBoxUtils.RB_Request) -> Swift.Void)?
  open var requestDidResume: ((RoomBoxUtils.RB_Request) -> Swift.Void)?
  open var requestDidResumeTask: ((RoomBoxUtils.RB_Request, Foundation.URLSessionTask) -> Swift.Void)?
  open var requestDidSuspend: ((RoomBoxUtils.RB_Request) -> Swift.Void)?
  open var requestDidSuspendTask: ((RoomBoxUtils.RB_Request, Foundation.URLSessionTask) -> Swift.Void)?
  open var requestDidCancel: ((RoomBoxUtils.RB_Request) -> Swift.Void)?
  open var requestDidCancelTask: ((RoomBoxUtils.RB_Request, Foundation.URLSessionTask) -> Swift.Void)?
  open var requestDidValidateRequestResponseDataWithResult: ((RoomBoxUtils.RB_DataRequest, Foundation.URLRequest?, Foundation.HTTPURLResponse, Foundation.Data?, RoomBoxUtils.RB_Request.ValidationResult) -> Swift.Void)?
  open var requestDidParseResponse: ((RoomBoxUtils.RB_DataRequest, RoomBoxUtils.RB_DataResponse<Foundation.Data?, RoomBoxUtils.RB_AFError>) -> Swift.Void)?
  open var requestDidValidateRequestResponseWithResult: ((RoomBoxUtils.DataStreamRequest, Foundation.URLRequest?, Foundation.HTTPURLResponse, RoomBoxUtils.RB_Request.ValidationResult) -> Swift.Void)?
  open var requestDidCreateUploadable: ((RoomBoxUtils.RB_UploadRequest, RoomBoxUtils.RB_UploadRequest.Uploadable) -> Swift.Void)?
  open var requestDidFailToCreateUploadableWithError: ((RoomBoxUtils.RB_UploadRequest, RoomBoxUtils.RB_AFError) -> Swift.Void)?
  open var requestDidProvideInputStream: ((RoomBoxUtils.RB_UploadRequest, Foundation.InputStream) -> Swift.Void)?
  open var requestDidFinishDownloadingUsingTaskWithResult: ((RoomBoxUtils.RB_DownloadRequest, Foundation.URLSessionTask, Swift.Result<Foundation.URL, RoomBoxUtils.RB_AFError>) -> Swift.Void)?
  open var requestDidCreateDestinationURL: ((RoomBoxUtils.RB_DownloadRequest, Foundation.URL) -> Swift.Void)?
  open var requestDidValidateRequestResponseFileURLWithResult: ((RoomBoxUtils.RB_DownloadRequest, Foundation.URLRequest?, Foundation.HTTPURLResponse, Foundation.URL?, RoomBoxUtils.RB_Request.ValidationResult) -> Swift.Void)?
  open var requestDidParseDownloadResponse: ((RoomBoxUtils.RB_DownloadRequest, RoomBoxUtils.DownloadResponse<Foundation.URL?, RoomBoxUtils.RB_AFError>) -> Swift.Void)?
  final public let queue: Dispatch.DispatchQueue
  public init(queue: Dispatch.DispatchQueue = .main)
  open func urlSession(_ rb_session: Foundation.URLSession, didBecomeInvalidWithError error: Swift.Error?)
  open func urlSession(_ rb_session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge)
  open func urlSession(_ rb_session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  open func urlSession(_ rb_session: Foundation.URLSession, taskNeedsNewBodyStream task: Foundation.URLSessionTask)
  open func urlSession(_ rb_session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest rb_request: Foundation.URLRequest)
  open func urlSession(_ rb_session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  open func urlSession(_ rb_session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
  open func urlSession(_ rb_session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  open func urlSession(_ rb_session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  open func urlSession(_ rb_session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse)
  open func urlSession(_ rb_session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  open func urlSession(_ rb_session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  open func urlSession(_ rb_session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  open func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didCreateInitialURLRequest urlRequest: Foundation.URLRequest)
  open func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didFailToCreateURLRequestWithError error: RoomBoxUtils.RB_AFError)
  open func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didAdaptInitialRequest initialRequest: Foundation.URLRequest, to adaptedRequest: Foundation.URLRequest)
  open func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didFailToAdaptURLRequest initialRequest: Foundation.URLRequest, withError error: RoomBoxUtils.RB_AFError)
  open func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didCreateURLRequest urlRequest: Foundation.URLRequest)
  open func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didCreateTask task: Foundation.URLSessionTask)
  open func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didGatherMetrics metrics: Foundation.URLSessionTaskMetrics)
  open func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didFailTask task: Foundation.URLSessionTask, earlyWithError error: RoomBoxUtils.RB_AFError)
  open func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didCompleteTask task: Foundation.URLSessionTask, with error: RoomBoxUtils.RB_AFError?)
  open func requestIsRetrying(_ rb_request: RoomBoxUtils.RB_Request)
  open func requestDidFinish(_ rb_request: RoomBoxUtils.RB_Request)
  open func requestDidResume(_ rb_request: RoomBoxUtils.RB_Request)
  public func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didResumeTask task: Foundation.URLSessionTask)
  open func requestDidSuspend(_ rb_request: RoomBoxUtils.RB_Request)
  public func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didSuspendTask task: Foundation.URLSessionTask)
  open func requestDidCancel(_ rb_request: RoomBoxUtils.RB_Request)
  public func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didCancelTask task: Foundation.URLSessionTask)
  open func rb_request(_ rb_request: RoomBoxUtils.RB_DataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, withResult result: RoomBoxUtils.RB_Request.ValidationResult)
  open func rb_request(_ rb_request: RoomBoxUtils.RB_DataRequest, didParseResponse response: RoomBoxUtils.RB_DataResponse<Foundation.Data?, RoomBoxUtils.RB_AFError>)
  public func rb_request(_ rb_request: RoomBoxUtils.DataStreamRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, withResult result: RoomBoxUtils.RB_Request.ValidationResult)
  open func rb_request(_ rb_request: RoomBoxUtils.RB_UploadRequest, didCreateUploadable uploadable: RoomBoxUtils.RB_UploadRequest.Uploadable)
  open func rb_request(_ rb_request: RoomBoxUtils.RB_UploadRequest, didFailToCreateUploadableWithError error: RoomBoxUtils.RB_AFError)
  open func rb_request(_ rb_request: RoomBoxUtils.RB_UploadRequest, didProvideInputStream stream: Foundation.InputStream)
  open func rb_request(_ rb_request: RoomBoxUtils.RB_DownloadRequest, didFinishDownloadingUsing task: Foundation.URLSessionTask, with result: Swift.Result<Foundation.URL, RoomBoxUtils.RB_AFError>)
  open func rb_request(_ rb_request: RoomBoxUtils.RB_DownloadRequest, didCreateDestinationURL url: Foundation.URL)
  open func rb_request(_ rb_request: RoomBoxUtils.RB_DownloadRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, fileURL: Foundation.URL?, withResult result: RoomBoxUtils.RB_Request.ValidationResult)
  open func rb_request(_ rb_request: RoomBoxUtils.RB_DownloadRequest, didParseResponse response: RoomBoxUtils.DownloadResponse<Foundation.URL?, RoomBoxUtils.RB_AFError>)
  @objc deinit
}
public struct RB_HTTPHeaders {
  public init()
  public init(_ headers: [RoomBoxUtils.RB_HTTPHeader])
  public init(_ dictionary: [Swift.String : Swift.String])
  public mutating func add(name: Swift.String, value: Swift.String)
  public mutating func add(_ header: RoomBoxUtils.RB_HTTPHeader)
  public mutating func update(name: Swift.String, value: Swift.String)
  public mutating func update(_ header: RoomBoxUtils.RB_HTTPHeader)
  public mutating func remove(name: Swift.String)
  public mutating func sort()
  public func sorted() -> RoomBoxUtils.RB_HTTPHeaders
  public func value(for name: Swift.String) -> Swift.String?
  public subscript(name: Swift.String) -> Swift.String? {
    get
    set
  }
  public var dictionary: [Swift.String : Swift.String] {
    get
  }
}
extension RB_HTTPHeaders : Swift.ExpressibleByDictionaryLiteral {
  public init(dictionaryLiteral elements: (Swift.String, Swift.String)...)
  public typealias Key = Swift.String
  public typealias Value = Swift.String
}
extension RB_HTTPHeaders : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: RoomBoxUtils.RB_HTTPHeader...)
  public typealias ArrayLiteralElement = RoomBoxUtils.RB_HTTPHeader
}
extension RB_HTTPHeaders : Swift.Sequence {
  public func makeIterator() -> Swift.IndexingIterator<[RoomBoxUtils.RB_HTTPHeader]>
}
extension RB_HTTPHeaders : Swift.Collection {
  public var startIndex: Swift.Int {
    get
  }
  public var endIndex: Swift.Int {
    get
  }
  public subscript(position: Swift.Int) -> RoomBoxUtils.RB_HTTPHeader {
    get
  }
  public func index(after i: Swift.Int) -> Swift.Int
  public typealias Element = RoomBoxUtils.RB_HTTPHeader
  public typealias Index = Swift.Int
  public typealias Iterator = Swift.IndexingIterator<[RoomBoxUtils.RB_HTTPHeader]>
  public typealias SubSequence = Swift.Slice<RoomBoxUtils.RB_HTTPHeaders>
  public typealias Indices = Swift.DefaultIndices<RoomBoxUtils.RB_HTTPHeaders>
}
extension RB_HTTPHeaders : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct RB_HTTPHeader : Swift.Hashable {
  public let name: Swift.String
  public let value: Swift.String
  public init(name: Swift.String, value: Swift.String)
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: RoomBoxUtils.RB_HTTPHeader, b: RoomBoxUtils.RB_HTTPHeader) -> Swift.Bool
}
extension RB_HTTPHeader : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension RB_HTTPHeader {
  public static func accept(_ value: Swift.String) -> RoomBoxUtils.RB_HTTPHeader
  public static func acceptCharset(_ value: Swift.String) -> RoomBoxUtils.RB_HTTPHeader
  public static func acceptLanguage(_ value: Swift.String) -> RoomBoxUtils.RB_HTTPHeader
  public static func acceptEncoding(_ value: Swift.String) -> RoomBoxUtils.RB_HTTPHeader
  public static func authorization(username: Swift.String, password: Swift.String) -> RoomBoxUtils.RB_HTTPHeader
  public static func authorization(bearerToken: Swift.String) -> RoomBoxUtils.RB_HTTPHeader
  public static func authorization(_ value: Swift.String) -> RoomBoxUtils.RB_HTTPHeader
  public static func contentDisposition(_ value: Swift.String) -> RoomBoxUtils.RB_HTTPHeader
  public static func contentType(_ value: Swift.String) -> RoomBoxUtils.RB_HTTPHeader
  public static func userAgent(_ value: Swift.String) -> RoomBoxUtils.RB_HTTPHeader
}
extension RB_HTTPHeaders {
  public static let `default`: RoomBoxUtils.RB_HTTPHeaders
}
extension RB_HTTPHeader {
  public static let defaultAcceptEncoding: RoomBoxUtils.RB_HTTPHeader
  public static let defaultAcceptLanguage: RoomBoxUtils.RB_HTTPHeader
  public static let defaultUserAgent: RoomBoxUtils.RB_HTTPHeader
}
extension URLRequest {
  public var headers: RoomBoxUtils.RB_HTTPHeaders {
    get
    set
  }
}
extension HTTPURLResponse {
  public var headers: RoomBoxUtils.RB_HTTPHeaders {
    get
  }
}
extension URLSessionConfiguration {
  public var headers: RoomBoxUtils.RB_HTTPHeaders {
    get
    set
  }
}
public struct RB_HTTPMethod : Swift.RawRepresentable, Swift.Equatable, Swift.Hashable {
  public static let connect: RoomBoxUtils.RB_HTTPMethod
  public static let delete: RoomBoxUtils.RB_HTTPMethod
  public static let get: RoomBoxUtils.RB_HTTPMethod
  public static let head: RoomBoxUtils.RB_HTTPMethod
  public static let options: RoomBoxUtils.RB_HTTPMethod
  public static let patch: RoomBoxUtils.RB_HTTPMethod
  public static let post: RoomBoxUtils.RB_HTTPMethod
  public static let put: RoomBoxUtils.RB_HTTPMethod
  public static let trace: RoomBoxUtils.RB_HTTPMethod
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public typealias RawValue = Swift.String
}
open class RB_MultipartFormData {
  public static let encodingMemoryThreshold: Swift.UInt64
  open var contentType: Swift.String {
    get
    set
  }
  public var contentLength: Swift.UInt64 {
    get
  }
  final public let boundary: Swift.String
  public init(fileManager: Foundation.FileManager = .default, boundary: Swift.String? = nil)
  public func append(_ data: Foundation.Data, withName name: Swift.String, fileName: Swift.String? = nil, mimeType: Swift.String? = nil)
  public func append(_ fileURL: Foundation.URL, withName name: Swift.String)
  public func append(_ fileURL: Foundation.URL, withName name: Swift.String, fileName: Swift.String, mimeType: Swift.String)
  public func append(_ stream: Foundation.InputStream, withLength length: Swift.UInt64, name: Swift.String, fileName: Swift.String, mimeType: Swift.String)
  public func append(_ stream: Foundation.InputStream, withLength length: Swift.UInt64, headers: RoomBoxUtils.RB_HTTPHeaders)
  public func encode() throws -> Foundation.Data
  public func writeEncodedData(to fileURL: Foundation.URL) throws
  @objc deinit
}
@_hasMissingDesignatedInitializers open class RB_NetworkReachabilityManager {
  public enum NetworkReachabilityStatus {
    case unknown
    case notReachable
    case reachable(RoomBoxUtils.RB_NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType)
    public enum ConnectionType {
      case ethernetOrWiFi
      case cellular
      public static func == (a: RoomBoxUtils.RB_NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType, b: RoomBoxUtils.RB_NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
    }
  }
  public typealias Listener = (RoomBoxUtils.RB_NetworkReachabilityManager.NetworkReachabilityStatus) -> Swift.Void
  public static let `default`: RoomBoxUtils.RB_NetworkReachabilityManager?
  open var isReachable: Swift.Bool {
    get
  }
  open var isReachableOnCellular: Swift.Bool {
    get
  }
  open var isReachableOnEthernetOrWiFi: Swift.Bool {
    get
  }
  final public let reachabilityQueue: Dispatch.DispatchQueue
  open var flags: SystemConfiguration.SCNetworkReachabilityFlags? {
    get
  }
  open var status: RoomBoxUtils.RB_NetworkReachabilityManager.NetworkReachabilityStatus {
    get
  }
  convenience public init?(host: Swift.String)
  convenience public init?()
  @objc deinit
  @discardableResult
  open func startListening(onQueue queue: Dispatch.DispatchQueue = .main, onUpdatePerforming listener: @escaping RoomBoxUtils.RB_NetworkReachabilityManager.Listener) -> Swift.Bool
  open func stopListening()
}
extension RB_NetworkReachabilityManager.NetworkReachabilityStatus : Swift.Equatable {
  public static func == (a: RoomBoxUtils.RB_NetworkReachabilityManager.NetworkReachabilityStatus, b: RoomBoxUtils.RB_NetworkReachabilityManager.NetworkReachabilityStatus) -> Swift.Bool
}
extension RB_Request {
  public static let didResumeNotification: Foundation.Notification.Name
  public static let didSuspendNotification: Foundation.Notification.Name
  public static let didCancelNotification: Foundation.Notification.Name
  public static let didFinishNotification: Foundation.Notification.Name
  public static let didResumeTaskNotification: Foundation.Notification.Name
  public static let didSuspendTaskNotification: Foundation.Notification.Name
  public static let didCancelTaskNotification: Foundation.Notification.Name
  public static let didCompleteTaskNotification: Foundation.Notification.Name
}
extension Notification {
  public var rb_request: RoomBoxUtils.RB_Request? {
    get
  }
}
@_hasMissingDesignatedInitializers final public class AlamofireNotifications : RoomBoxUtils.EventMonitor {
  final public func requestDidResume(_ rb_request: RoomBoxUtils.RB_Request)
  final public func requestDidSuspend(_ rb_request: RoomBoxUtils.RB_Request)
  final public func requestDidCancel(_ rb_request: RoomBoxUtils.RB_Request)
  final public func requestDidFinish(_ rb_request: RoomBoxUtils.RB_Request)
  final public func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didResumeTask task: Foundation.URLSessionTask)
  final public func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didSuspendTask task: Foundation.URLSessionTask)
  final public func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didCancelTask task: Foundation.URLSessionTask)
  final public func rb_request(_ rb_request: RoomBoxUtils.RB_Request, didCompleteTask task: Foundation.URLSessionTask, with error: RoomBoxUtils.RB_AFError?)
  @objc deinit
}
public protocol ParameterEncoder {
  func encode<RB_Parameters>(_ parameters: RB_Parameters?, into rb_request: Foundation.URLRequest) throws -> Foundation.URLRequest where RB_Parameters : Swift.Encodable
}
open class JSONParameterEncoder : RoomBoxUtils.ParameterEncoder {
  public static var `default`: RoomBoxUtils.JSONParameterEncoder {
    get
  }
  public static var prettyPrinted: RoomBoxUtils.JSONParameterEncoder {
    get
  }
  @available(OSX 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  public static var sortedKeys: RoomBoxUtils.JSONParameterEncoder {
    get
  }
  final public let encoder: Foundation.JSONEncoder
  public init(encoder: Foundation.JSONEncoder = JSONEncoder())
  open func encode<RB_Parameters>(_ parameters: RB_Parameters?, into rb_request: Foundation.URLRequest) throws -> Foundation.URLRequest where RB_Parameters : Swift.Encodable
  @objc deinit
}
open class RB_URLEncodedFormParameterEncoder : RoomBoxUtils.ParameterEncoder {
  public enum Destination {
    case methodDependent
    case queryString
    case httpBody
    public static func == (a: RoomBoxUtils.RB_URLEncodedFormParameterEncoder.Destination, b: RoomBoxUtils.RB_URLEncodedFormParameterEncoder.Destination) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public static var `default`: RoomBoxUtils.RB_URLEncodedFormParameterEncoder {
    get
  }
  final public let encoder: RoomBoxUtils.RB_URLEncodedFormEncoder
  final public let destination: RoomBoxUtils.RB_URLEncodedFormParameterEncoder.Destination
  public init(encoder: RoomBoxUtils.RB_URLEncodedFormEncoder = RB_URLEncodedFormEncoder(), destination: RoomBoxUtils.RB_URLEncodedFormParameterEncoder.Destination = .methodDependent)
  open func encode<RB_Parameters>(_ parameters: RB_Parameters?, into rb_request: Foundation.URLRequest) throws -> Foundation.URLRequest where RB_Parameters : Swift.Encodable
  @objc deinit
}
public typealias RB_Parameters = [Swift.String : Any]
public protocol RB_ParameterEncoding {
  func encode(_ urlRequest: RoomBoxUtils.RB_URLRequestConvertible, with parameters: RoomBoxUtils.RB_Parameters?) throws -> Foundation.URLRequest
}
public struct RB_URLEncoding : RoomBoxUtils.RB_ParameterEncoding {
  public enum Destination {
    case methodDependent
    case queryString
    case httpBody
    public static func == (a: RoomBoxUtils.RB_URLEncoding.Destination, b: RoomBoxUtils.RB_URLEncoding.Destination) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public enum ArrayEncoding {
    case brackets
    case noBrackets
    public static func == (a: RoomBoxUtils.RB_URLEncoding.ArrayEncoding, b: RoomBoxUtils.RB_URLEncoding.ArrayEncoding) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public enum BoolEncoding {
    case numeric
    case literal
    public static func == (a: RoomBoxUtils.RB_URLEncoding.BoolEncoding, b: RoomBoxUtils.RB_URLEncoding.BoolEncoding) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public static var `default`: RoomBoxUtils.RB_URLEncoding {
    get
  }
  public static var queryString: RoomBoxUtils.RB_URLEncoding {
    get
  }
  public static var httpBody: RoomBoxUtils.RB_URLEncoding {
    get
  }
  public let destination: RoomBoxUtils.RB_URLEncoding.Destination
  public let arrayEncoding: RoomBoxUtils.RB_URLEncoding.ArrayEncoding
  public let boolEncoding: RoomBoxUtils.RB_URLEncoding.BoolEncoding
  public init(destination: RoomBoxUtils.RB_URLEncoding.Destination = .methodDependent, arrayEncoding: RoomBoxUtils.RB_URLEncoding.ArrayEncoding = .brackets, boolEncoding: RoomBoxUtils.RB_URLEncoding.BoolEncoding = .numeric)
  public func encode(_ urlRequest: RoomBoxUtils.RB_URLRequestConvertible, with parameters: RoomBoxUtils.RB_Parameters?) throws -> Foundation.URLRequest
  public func queryComponents(fromKey key: Swift.String, value: Any) -> [(Swift.String, Swift.String)]
  public func escape(_ string: Swift.String) -> Swift.String
}
public struct RB_JSONEncoding : RoomBoxUtils.RB_ParameterEncoding {
  public static var `default`: RoomBoxUtils.RB_JSONEncoding {
    get
  }
  public static var prettyPrinted: RoomBoxUtils.RB_JSONEncoding {
    get
  }
  public let options: Foundation.JSONSerialization.WritingOptions
  public init(options: Foundation.JSONSerialization.WritingOptions = [])
  public func encode(_ urlRequest: RoomBoxUtils.RB_URLRequestConvertible, with parameters: RoomBoxUtils.RB_Parameters?) throws -> Foundation.URLRequest
  public func encode(_ urlRequest: RoomBoxUtils.RB_URLRequestConvertible, withJSONObject jsonObject: Any? = nil) throws -> Foundation.URLRequest
}
public protocol RedirectHandler {
  func task(_ task: Foundation.URLSessionTask, willBeRedirectedTo rb_request: Foundation.URLRequest, for response: Foundation.HTTPURLResponse, completion: @escaping (Foundation.URLRequest?) -> Swift.Void)
}
public struct Redirector {
  public enum Behavior {
    case follow
    case doNotFollow
    case modify((Foundation.URLSessionTask, Foundation.URLRequest, Foundation.HTTPURLResponse) -> Foundation.URLRequest?)
  }
  public static let follow: RoomBoxUtils.Redirector
  public static let doNotFollow: RoomBoxUtils.Redirector
  public let behavior: RoomBoxUtils.Redirector.Behavior
  public init(behavior: RoomBoxUtils.Redirector.Behavior)
}
extension Redirector : RoomBoxUtils.RedirectHandler {
  public func task(_ task: Foundation.URLSessionTask, willBeRedirectedTo rb_request: Foundation.URLRequest, for response: Foundation.HTTPURLResponse, completion: @escaping (Foundation.URLRequest?) -> Swift.Void)
}
@_hasMissingDesignatedInitializers public class RB_Request {
  public enum State {
    case initialized
    case resumed
    case suspended
    case cancelled
    case finished
    public static func == (a: RoomBoxUtils.RB_Request.State, b: RoomBoxUtils.RB_Request.State) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  final public let id: Foundation.UUID
  final public let underlyingQueue: Dispatch.DispatchQueue
  final public let serializationQueue: Dispatch.DispatchQueue
  final public let eventMonitor: RoomBoxUtils.EventMonitor?
  final public let interceptor: RoomBoxUtils.RB_RequestInterceptor?
  weak public var delegate: RoomBoxUtils.RequestDelegate? {
    get
  }
  public var state: RoomBoxUtils.RB_Request.State {
    get
  }
  public var isInitialized: Swift.Bool {
    get
  }
  public var isResumed: Swift.Bool {
    get
  }
  public var isSuspended: Swift.Bool {
    get
  }
  public var isCancelled: Swift.Bool {
    get
  }
  public var isFinished: Swift.Bool {
    get
  }
  public typealias ProgressHandler = (Foundation.Progress) -> Swift.Void
  final public let uploadProgress: Foundation.Progress
  final public let downloadProgress: Foundation.Progress
  public var redirectHandler: RoomBoxUtils.RedirectHandler? {
    get
  }
  public var cachedResponseHandler: RoomBoxUtils.CachedResponseHandler? {
    get
  }
  public var credential: Foundation.URLCredential? {
    get
  }
  public var requests: [Foundation.URLRequest] {
    get
  }
  public var firstRequest: Foundation.URLRequest? {
    get
  }
  public var lastRequest: Foundation.URLRequest? {
    get
  }
  public var rb_request: Foundation.URLRequest? {
    get
  }
  public var performedRequests: [Foundation.URLRequest] {
    get
  }
  public var response: Foundation.HTTPURLResponse? {
    get
  }
  public var tasks: [Foundation.URLSessionTask] {
    get
  }
  public var firstTask: Foundation.URLSessionTask? {
    get
  }
  public var lastTask: Foundation.URLSessionTask? {
    get
  }
  public var task: Foundation.URLSessionTask? {
    get
  }
  public var allMetrics: [Foundation.URLSessionTaskMetrics] {
    get
  }
  public var firstMetrics: Foundation.URLSessionTaskMetrics? {
    get
  }
  public var lastMetrics: Foundation.URLSessionTaskMetrics? {
    get
  }
  public var metrics: Foundation.URLSessionTaskMetrics? {
    get
  }
  public var retryCount: Swift.Int {
    get
  }
  public var error: RoomBoxUtils.RB_AFError? {
    get
  }
  @discardableResult
  public func cancel() -> Self
  @discardableResult
  public func suspend() -> Self
  @discardableResult
  public func resume() -> Self
  @discardableResult
  public func authenticate(username: Swift.String, password: Swift.String, persistence: Foundation.URLCredential.Persistence = .forSession) -> Self
  @discardableResult
  public func authenticate(with credential: Foundation.URLCredential) -> Self
  @discardableResult
  public func downloadProgress(queue: Dispatch.DispatchQueue = .main, closure: @escaping RoomBoxUtils.RB_Request.ProgressHandler) -> Self
  @discardableResult
  public func uploadProgress(queue: Dispatch.DispatchQueue = .main, closure: @escaping RoomBoxUtils.RB_Request.ProgressHandler) -> Self
  @discardableResult
  public func redirect(using handler: RoomBoxUtils.RedirectHandler) -> Self
  @discardableResult
  public func cacheResponse(using handler: RoomBoxUtils.CachedResponseHandler) -> Self
  @discardableResult
  public func cURLDescription(on queue: Dispatch.DispatchQueue, calling handler: @escaping (Swift.String) -> Swift.Void) -> Self
  @discardableResult
  public func cURLDescription(calling handler: @escaping (Swift.String) -> Swift.Void) -> Self
  @discardableResult
  public func onURLRequestCreation(on queue: Dispatch.DispatchQueue = .main, perform handler: @escaping (Foundation.URLRequest) -> Swift.Void) -> Self
  @discardableResult
  public func onURLSessionTaskCreation(on queue: Dispatch.DispatchQueue = .main, perform handler: @escaping (Foundation.URLSessionTask) -> Swift.Void) -> Self
  @objc deinit
}
extension RB_Request : Swift.Equatable {
  public static func == (lhs: RoomBoxUtils.RB_Request, rhs: RoomBoxUtils.RB_Request) -> Swift.Bool
}
extension RB_Request : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension RB_Request : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension RB_Request {
  public func cURLDescription() -> Swift.String
}
public protocol RequestDelegate : AnyObject {
  var sessionConfiguration: Foundation.URLSessionConfiguration { get }
  var startImmediately: Swift.Bool { get }
  func cleanup(after rb_request: RoomBoxUtils.RB_Request)
  func retryResult(for rb_request: RoomBoxUtils.RB_Request, dueTo error: RoomBoxUtils.RB_AFError, completion: @escaping (RoomBoxUtils.RetryResult) -> Swift.Void)
  func retryRequest(_ rb_request: RoomBoxUtils.RB_Request, withDelay timeDelay: Foundation.TimeInterval?)
}
@_hasMissingDesignatedInitializers public class RB_DataRequest : RoomBoxUtils.RB_Request {
  final public let convertible: RoomBoxUtils.RB_URLRequestConvertible
  public var data: Foundation.Data? {
    get
  }
  @discardableResult
  public func validate(_ validation: @escaping RoomBoxUtils.RB_DataRequest.Validation) -> Self
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DataStreamRequest : RoomBoxUtils.RB_Request {
  public typealias Handler<Success, Failure> = (RoomBoxUtils.DataStreamRequest.Stream<Success, Failure>) throws -> Swift.Void where Failure : Swift.Error
  public struct Stream<Success, Failure> where Failure : Swift.Error {
    public let event: RoomBoxUtils.DataStreamRequest.Event<Success, Failure>
    public let token: RoomBoxUtils.DataStreamRequest.CancellationToken
    public func cancel()
  }
  public enum Event<Success, Failure> where Failure : Swift.Error {
    case stream(Swift.Result<Success, Failure>)
    case complete(RoomBoxUtils.DataStreamRequest.Completion)
  }
  public struct Completion {
    public let rb_request: Foundation.URLRequest?
    public let response: Foundation.HTTPURLResponse?
    public let metrics: Foundation.URLSessionTaskMetrics?
    public let error: RoomBoxUtils.RB_AFError?
  }
  public struct CancellationToken {
    public func cancel()
  }
  final public let convertible: RoomBoxUtils.RB_URLRequestConvertible
  final public let automaticallyCancelOnStreamError: Swift.Bool
  @discardableResult
  final public func validate(_ validation: @escaping RoomBoxUtils.DataStreamRequest.Validation) -> Self
  final public func asInputStream(bufferSize: Swift.Int = 1024) -> Foundation.InputStream?
  @objc deinit
}
extension DataStreamRequest.Stream {
  public var result: Swift.Result<Success, Failure>? {
    get
  }
  public var value: Success? {
    get
  }
  public var error: Failure? {
    get
  }
  public var completion: RoomBoxUtils.DataStreamRequest.Completion? {
    get
  }
}
@_hasMissingDesignatedInitializers public class RB_DownloadRequest : RoomBoxUtils.RB_Request {
  public struct Options : Swift.OptionSet {
    public static let createIntermediateDirectories: RoomBoxUtils.RB_DownloadRequest.Options
    public static let removePreviousFile: RoomBoxUtils.RB_DownloadRequest.Options
    public let rawValue: Swift.Int
    public init(rawValue: Swift.Int)
    public typealias Element = RoomBoxUtils.RB_DownloadRequest.Options
    public typealias ArrayLiteralElement = RoomBoxUtils.RB_DownloadRequest.Options
    public typealias RawValue = Swift.Int
  }
  public typealias Destination = (Foundation.URL, Foundation.HTTPURLResponse) -> (destinationURL: Foundation.URL, options: RoomBoxUtils.RB_DownloadRequest.Options)
  public class func suggestedDownloadDestination(for directory: Foundation.FileManager.SearchPathDirectory = .documentDirectory, in domain: Foundation.FileManager.SearchPathDomainMask = .userDomainMask, options: RoomBoxUtils.RB_DownloadRequest.Options = []) -> RoomBoxUtils.RB_DownloadRequest.Destination
  public enum Downloadable {
    case rb_request(RoomBoxUtils.RB_URLRequestConvertible)
    case resumeData(Foundation.Data)
  }
  public var resumeData: Foundation.Data? {
    get
  }
  public var fileURL: Foundation.URL? {
    get
  }
  final public let downloadable: RoomBoxUtils.RB_DownloadRequest.Downloadable
  public func task(forResumeData data: Foundation.Data, using rb_session: Foundation.URLSession) -> Foundation.URLSessionTask
  @discardableResult
  override public func cancel() -> Self
  @discardableResult
  public func cancel(producingResumeData shouldProduceResumeData: Swift.Bool) -> Self
  @discardableResult
  public func cancel(byProducingResumeData completionHandler: @escaping (Foundation.Data?) -> Swift.Void) -> Self
  @discardableResult
  public func validate(_ validation: @escaping RoomBoxUtils.RB_DownloadRequest.Validation) -> Self
  @objc deinit
}
@_hasMissingDesignatedInitializers public class RB_UploadRequest : RoomBoxUtils.RB_DataRequest {
  public enum Uploadable {
    case data(Foundation.Data)
    case file(Foundation.URL, shouldRemove: Swift.Bool)
    case stream(Foundation.InputStream)
  }
  final public let rb_upload: RoomBoxUtils.UploadableConvertible
  final public let fileManager: Foundation.FileManager
  public var uploadable: RoomBoxUtils.RB_UploadRequest.Uploadable?
  public func cleanup()
  @objc deinit
}
public protocol UploadableConvertible {
  func createUploadable() throws -> RoomBoxUtils.RB_UploadRequest.Uploadable
}
extension RB_UploadRequest.Uploadable : RoomBoxUtils.UploadableConvertible {
  public func createUploadable() throws -> RoomBoxUtils.RB_UploadRequest.Uploadable
}
public protocol RB_UploadConvertible : RoomBoxUtils.RB_URLRequestConvertible, RoomBoxUtils.UploadableConvertible {
}
public protocol RequestAdapter {
  func adapt(_ urlRequest: Foundation.URLRequest, for rb_session: RoomBoxUtils.RB_Session, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
}
public enum RetryResult {
  case retry
  case retryWithDelay(Foundation.TimeInterval)
  case doNotRetry
  case doNotRetryWithError(Swift.Error)
}
public protocol RequestRetrier {
  func retry(_ rb_request: RoomBoxUtils.RB_Request, for rb_session: RoomBoxUtils.RB_Session, dueTo error: Swift.Error, completion: @escaping (RoomBoxUtils.RetryResult) -> Swift.Void)
}
public protocol RB_RequestInterceptor : RoomBoxUtils.RequestAdapter, RoomBoxUtils.RequestRetrier {
}
extension RB_RequestInterceptor {
  public func adapt(_ urlRequest: Foundation.URLRequest, for rb_session: RoomBoxUtils.RB_Session, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  public func retry(_ rb_request: RoomBoxUtils.RB_Request, for rb_session: RoomBoxUtils.RB_Session, dueTo error: Swift.Error, completion: @escaping (RoomBoxUtils.RetryResult) -> Swift.Void)
}
public typealias AdaptHandler = (Foundation.URLRequest, RoomBoxUtils.RB_Session, @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void) -> Swift.Void
public typealias RetryHandler = (RoomBoxUtils.RB_Request, RoomBoxUtils.RB_Session, Swift.Error, @escaping (RoomBoxUtils.RetryResult) -> Swift.Void) -> Swift.Void
open class Adapter : RoomBoxUtils.RB_RequestInterceptor {
  public init(_ adaptHandler: @escaping RoomBoxUtils.AdaptHandler)
  open func adapt(_ urlRequest: Foundation.URLRequest, for rb_session: RoomBoxUtils.RB_Session, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  @objc deinit
}
open class Retrier : RoomBoxUtils.RB_RequestInterceptor {
  public init(_ retryHandler: @escaping RoomBoxUtils.RetryHandler)
  open func retry(_ rb_request: RoomBoxUtils.RB_Request, for rb_session: RoomBoxUtils.RB_Session, dueTo error: Swift.Error, completion: @escaping (RoomBoxUtils.RetryResult) -> Swift.Void)
  @objc deinit
}
open class Interceptor : RoomBoxUtils.RB_RequestInterceptor {
  final public let adapters: [RoomBoxUtils.RequestAdapter]
  final public let retriers: [RoomBoxUtils.RequestRetrier]
  public init(adaptHandler: @escaping RoomBoxUtils.AdaptHandler, retryHandler: @escaping RoomBoxUtils.RetryHandler)
  public init(adapter: RoomBoxUtils.RequestAdapter, retrier: RoomBoxUtils.RequestRetrier)
  public init(adapters: [RoomBoxUtils.RequestAdapter] = [], retriers: [RoomBoxUtils.RequestRetrier] = [], interceptors: [RoomBoxUtils.RB_RequestInterceptor] = [])
  open func adapt(_ urlRequest: Foundation.URLRequest, for rb_session: RoomBoxUtils.RB_Session, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  open func retry(_ rb_request: RoomBoxUtils.RB_Request, for rb_session: RoomBoxUtils.RB_Session, dueTo error: Swift.Error, completion: @escaping (RoomBoxUtils.RetryResult) -> Swift.Void)
  @objc deinit
}
public typealias AFDataResponse<Success> = RoomBoxUtils.RB_DataResponse<Success, RoomBoxUtils.RB_AFError>
public typealias AFDownloadResponse<Success> = RoomBoxUtils.DownloadResponse<Success, RoomBoxUtils.RB_AFError>
public struct RB_DataResponse<Success, Failure> where Failure : Swift.Error {
  public let rb_request: Foundation.URLRequest?
  public let response: Foundation.HTTPURLResponse?
  public let data: Foundation.Data?
  public let metrics: Foundation.URLSessionTaskMetrics?
  public let serializationDuration: Foundation.TimeInterval
  public let result: Swift.Result<Success, Failure>
  public var value: Success? {
    get
  }
  public var error: Failure? {
    get
  }
  public init(rb_request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, metrics: Foundation.URLSessionTaskMetrics?, serializationDuration: Foundation.TimeInterval, result: Swift.Result<Success, Failure>)
}
extension RB_DataResponse : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension RB_DataResponse {
  public func map<NewSuccess>(_ transform: (Success) -> NewSuccess) -> RoomBoxUtils.RB_DataResponse<NewSuccess, Failure>
  public func tryMap<NewSuccess>(_ transform: (Success) throws -> NewSuccess) -> RoomBoxUtils.RB_DataResponse<NewSuccess, Swift.Error>
  public func mapError<NewFailure>(_ transform: (Failure) -> NewFailure) -> RoomBoxUtils.RB_DataResponse<Success, NewFailure> where NewFailure : Swift.Error
  public func tryMapError<NewFailure>(_ transform: (Failure) throws -> NewFailure) -> RoomBoxUtils.RB_DataResponse<Success, Swift.Error> where NewFailure : Swift.Error
}
public struct DownloadResponse<Success, Failure> where Failure : Swift.Error {
  public let rb_request: Foundation.URLRequest?
  public let response: Foundation.HTTPURLResponse?
  public let fileURL: Foundation.URL?
  public let resumeData: Foundation.Data?
  public let metrics: Foundation.URLSessionTaskMetrics?
  public let serializationDuration: Foundation.TimeInterval
  public let result: Swift.Result<Success, Failure>
  public var value: Success? {
    get
  }
  public var error: Failure? {
    get
  }
  public init(rb_request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, fileURL: Foundation.URL?, resumeData: Foundation.Data?, metrics: Foundation.URLSessionTaskMetrics?, serializationDuration: Foundation.TimeInterval, result: Swift.Result<Success, Failure>)
}
extension DownloadResponse : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension DownloadResponse {
  public func map<NewSuccess>(_ transform: (Success) -> NewSuccess) -> RoomBoxUtils.DownloadResponse<NewSuccess, Failure>
  public func tryMap<NewSuccess>(_ transform: (Success) throws -> NewSuccess) -> RoomBoxUtils.DownloadResponse<NewSuccess, Swift.Error>
  public func mapError<NewFailure>(_ transform: (Failure) -> NewFailure) -> RoomBoxUtils.DownloadResponse<Success, NewFailure> where NewFailure : Swift.Error
  public func tryMapError<NewFailure>(_ transform: (Failure) throws -> NewFailure) -> RoomBoxUtils.DownloadResponse<Success, Swift.Error> where NewFailure : Swift.Error
}
public protocol DataResponseSerializerProtocol {
  associatedtype SerializedObject
  func serialize(rb_request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) throws -> Self.SerializedObject
}
public protocol DownloadResponseSerializerProtocol {
  associatedtype SerializedObject
  func serializeDownload(rb_request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, fileURL: Foundation.URL?, error: Swift.Error?) throws -> Self.SerializedObject
}
public protocol ResponseSerializer : RoomBoxUtils.DataResponseSerializerProtocol, RoomBoxUtils.DownloadResponseSerializerProtocol {
  var dataPreprocessor: RoomBoxUtils.DataPreprocessor { get }
  var emptyRequestMethods: Swift.Set<RoomBoxUtils.RB_HTTPMethod> { get }
  var emptyResponseCodes: Swift.Set<Swift.Int> { get }
}
public protocol DataPreprocessor {
  func preprocess(_ data: Foundation.Data) throws -> Foundation.Data
}
public struct PassthroughPreprocessor : RoomBoxUtils.DataPreprocessor {
  public init()
  public func preprocess(_ data: Foundation.Data) throws -> Foundation.Data
}
public struct GoogleXSSIPreprocessor : RoomBoxUtils.DataPreprocessor {
  public init()
  public func preprocess(_ data: Foundation.Data) throws -> Foundation.Data
}
extension ResponseSerializer {
  public static var defaultDataPreprocessor: RoomBoxUtils.DataPreprocessor {
    get
  }
  public static var defaultEmptyRequestMethods: Swift.Set<RoomBoxUtils.RB_HTTPMethod> {
    get
  }
  public static var defaultEmptyResponseCodes: Swift.Set<Swift.Int> {
    get
  }
  public var dataPreprocessor: RoomBoxUtils.DataPreprocessor {
    get
  }
  public var emptyRequestMethods: Swift.Set<RoomBoxUtils.RB_HTTPMethod> {
    get
  }
  public var emptyResponseCodes: Swift.Set<Swift.Int> {
    get
  }
  public func requestAllowsEmptyResponseData(_ rb_request: Foundation.URLRequest?) -> Swift.Bool?
  public func responseAllowsEmptyResponseData(_ response: Foundation.HTTPURLResponse?) -> Swift.Bool?
  public func emptyResponseAllowed(forRequest rb_request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?) -> Swift.Bool
}
extension DownloadResponseSerializerProtocol where Self : RoomBoxUtils.DataResponseSerializerProtocol {
  public func serializeDownload(rb_request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, fileURL: Foundation.URL?, error: Swift.Error?) throws -> Self.SerializedObject
}
extension RB_DataRequest {
  @discardableResult
  public func response(queue: Dispatch.DispatchQueue = .main, completionHandler: @escaping (RoomBoxUtils.AFDataResponse<Foundation.Data?>) -> Swift.Void) -> Self
  @discardableResult
  public func response<Serializer>(queue: Dispatch.DispatchQueue = .main, responseSerializer: Serializer, completionHandler: @escaping (RoomBoxUtils.AFDataResponse<Serializer.SerializedObject>) -> Swift.Void) -> Self where Serializer : RoomBoxUtils.DataResponseSerializerProtocol
}
extension RB_DownloadRequest {
  @discardableResult
  public func response(queue: Dispatch.DispatchQueue = .main, completionHandler: @escaping (RoomBoxUtils.AFDownloadResponse<Foundation.URL?>) -> Swift.Void) -> Self
  @discardableResult
  public func response<Serializer>(queue: Dispatch.DispatchQueue = .main, responseSerializer: Serializer, completionHandler: @escaping (RoomBoxUtils.AFDownloadResponse<Serializer.SerializedObject>) -> Swift.Void) -> Self where Serializer : RoomBoxUtils.DownloadResponseSerializerProtocol
}
final public class DataResponseSerializer : RoomBoxUtils.ResponseSerializer {
  final public let dataPreprocessor: RoomBoxUtils.DataPreprocessor
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<RoomBoxUtils.RB_HTTPMethod>
  public init(dataPreprocessor: RoomBoxUtils.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<RoomBoxUtils.RB_HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods)
  final public func serialize(rb_request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) throws -> Foundation.Data
  @objc deinit
  public typealias SerializedObject = Foundation.Data
}
extension RB_DataRequest {
  @discardableResult
  public func rb_responseData(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: RoomBoxUtils.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<RoomBoxUtils.RB_HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods, completionHandler: @escaping (RoomBoxUtils.AFDataResponse<Foundation.Data>) -> Swift.Void) -> Self
}
extension RB_DownloadRequest {
  @discardableResult
  public func rb_responseData(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: RoomBoxUtils.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<RoomBoxUtils.RB_HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods, completionHandler: @escaping (RoomBoxUtils.AFDownloadResponse<Foundation.Data>) -> Swift.Void) -> Self
}
final public class StringResponseSerializer : RoomBoxUtils.ResponseSerializer {
  final public let dataPreprocessor: RoomBoxUtils.DataPreprocessor
  final public let encoding: Swift.String.Encoding?
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<RoomBoxUtils.RB_HTTPMethod>
  public init(dataPreprocessor: RoomBoxUtils.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<RoomBoxUtils.RB_HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods)
  final public func serialize(rb_request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) throws -> Swift.String
  @objc deinit
  public typealias SerializedObject = Swift.String
}
extension RB_DataRequest {
  @discardableResult
  public func responseString(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: RoomBoxUtils.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<RoomBoxUtils.RB_HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods, completionHandler: @escaping (RoomBoxUtils.AFDataResponse<Swift.String>) -> Swift.Void) -> Self
}
extension RB_DownloadRequest {
  @discardableResult
  public func responseString(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: RoomBoxUtils.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<RoomBoxUtils.RB_HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods, completionHandler: @escaping (RoomBoxUtils.AFDownloadResponse<Swift.String>) -> Swift.Void) -> Self
}
final public class JSONResponseSerializer : RoomBoxUtils.ResponseSerializer {
  final public let dataPreprocessor: RoomBoxUtils.DataPreprocessor
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<RoomBoxUtils.RB_HTTPMethod>
  final public let options: Foundation.JSONSerialization.ReadingOptions
  public init(dataPreprocessor: RoomBoxUtils.DataPreprocessor = JSONResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = JSONResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<RoomBoxUtils.RB_HTTPMethod> = JSONResponseSerializer.defaultEmptyRequestMethods, options: Foundation.JSONSerialization.ReadingOptions = .allowFragments)
  final public func serialize(rb_request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) throws -> Any
  @objc deinit
  public typealias SerializedObject = Any
}
extension RB_DataRequest {
  @discardableResult
  public func responseJSON(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: RoomBoxUtils.DataPreprocessor = JSONResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = JSONResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<RoomBoxUtils.RB_HTTPMethod> = JSONResponseSerializer.defaultEmptyRequestMethods, options: Foundation.JSONSerialization.ReadingOptions = .allowFragments, completionHandler: @escaping (RoomBoxUtils.AFDataResponse<Any>) -> Swift.Void) -> Self
}
extension RB_DownloadRequest {
  @discardableResult
  public func responseJSON(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: RoomBoxUtils.DataPreprocessor = JSONResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = JSONResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<RoomBoxUtils.RB_HTTPMethod> = JSONResponseSerializer.defaultEmptyRequestMethods, options: Foundation.JSONSerialization.ReadingOptions = .allowFragments, completionHandler: @escaping (RoomBoxUtils.AFDownloadResponse<Any>) -> Swift.Void) -> Self
}
public protocol EmptyResponse {
  static func emptyValue() -> Self
}
public struct Empty : Swift.Codable {
  public static let value: RoomBoxUtils.Empty
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension Empty : RoomBoxUtils.EmptyResponse {
  public static func emptyValue() -> RoomBoxUtils.Empty
}
public protocol DataDecoder {
  func decode<D>(_ type: D.Type, from data: Foundation.Data) throws -> D where D : Swift.Decodable
}
extension JSONDecoder : RoomBoxUtils.DataDecoder {
}
extension PropertyListDecoder : RoomBoxUtils.DataDecoder {
}
final public class DecodableResponseSerializer<T> : RoomBoxUtils.ResponseSerializer where T : Swift.Decodable {
  final public let dataPreprocessor: RoomBoxUtils.DataPreprocessor
  final public let decoder: RoomBoxUtils.DataDecoder
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<RoomBoxUtils.RB_HTTPMethod>
  public init(dataPreprocessor: RoomBoxUtils.DataPreprocessor = DecodableResponseSerializer.defaultDataPreprocessor, decoder: RoomBoxUtils.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<RoomBoxUtils.RB_HTTPMethod> = DecodableResponseSerializer.defaultEmptyRequestMethods)
  final public func serialize(rb_request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) throws -> T
  @objc deinit
  public typealias SerializedObject = T
}
extension RB_DataRequest {
  @discardableResult
  public func responseDecodable<T>(of type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, dataPreprocessor: RoomBoxUtils.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: RoomBoxUtils.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<RoomBoxUtils.RB_HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods, completionHandler: @escaping (RoomBoxUtils.AFDataResponse<T>) -> Swift.Void) -> Self where T : Swift.Decodable
}
extension RB_DownloadRequest {
  @discardableResult
  public func responseDecodable<T>(of type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, dataPreprocessor: RoomBoxUtils.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: RoomBoxUtils.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<RoomBoxUtils.RB_HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods, completionHandler: @escaping (RoomBoxUtils.AFDownloadResponse<T>) -> Swift.Void) -> Self where T : Swift.Decodable
}
public protocol DataStreamSerializer {
  associatedtype SerializedObject
  func serialize(_ data: Foundation.Data) throws -> Self.SerializedObject
}
public struct DecodableStreamSerializer<T> : RoomBoxUtils.DataStreamSerializer where T : Swift.Decodable {
  public let decoder: RoomBoxUtils.DataDecoder
  public let dataPreprocessor: RoomBoxUtils.DataPreprocessor
  public init(decoder: RoomBoxUtils.DataDecoder = JSONDecoder(), dataPreprocessor: RoomBoxUtils.DataPreprocessor = PassthroughPreprocessor())
  public func serialize(_ data: Foundation.Data) throws -> T
  public typealias SerializedObject = T
}
public struct PassthroughStreamSerializer : RoomBoxUtils.DataStreamSerializer {
  public func serialize(_ data: Foundation.Data) throws -> Foundation.Data
  public typealias SerializedObject = Foundation.Data
}
public struct StringStreamSerializer : RoomBoxUtils.DataStreamSerializer {
  public func serialize(_ data: Foundation.Data) throws -> Swift.String
  public typealias SerializedObject = Swift.String
}
extension DataStreamRequest {
  @discardableResult
  final public func responseStream(on queue: Dispatch.DispatchQueue = .main, stream: @escaping RoomBoxUtils.DataStreamRequest.Handler<Foundation.Data, Swift.Never>) -> Self
  @discardableResult
  final public func responseStream<Serializer>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main, stream: @escaping RoomBoxUtils.DataStreamRequest.Handler<Serializer.SerializedObject, RoomBoxUtils.RB_AFError>) -> Self where Serializer : RoomBoxUtils.DataStreamSerializer
  @discardableResult
  final public func responseStreamString(on queue: Dispatch.DispatchQueue = .main, stream: @escaping RoomBoxUtils.DataStreamRequest.Handler<Swift.String, Swift.Never>) -> Self
  @discardableResult
  final public func responseStreamDecodable<T>(of type: T.Type = T.self, on queue: Dispatch.DispatchQueue = .main, using decoder: RoomBoxUtils.DataDecoder = JSONDecoder(), preprocessor: RoomBoxUtils.DataPreprocessor = PassthroughPreprocessor(), stream: @escaping RoomBoxUtils.DataStreamRequest.Handler<T, RoomBoxUtils.RB_AFError>) -> Self where T : Swift.Decodable
}
public typealias AFResult<Success> = Swift.Result<Success, RoomBoxUtils.RB_AFError>
open class RetryPolicy : RoomBoxUtils.RB_RequestInterceptor {
  public static let defaultRetryLimit: Swift.UInt
  public static let defaultExponentialBackoffBase: Swift.UInt
  public static let defaultExponentialBackoffScale: Swift.Double
  public static let defaultRetryableHTTPMethods: Swift.Set<RoomBoxUtils.RB_HTTPMethod>
  public static let defaultRetryableHTTPStatusCodes: Swift.Set<Swift.Int>
  public static let defaultRetryableURLErrorCodes: Swift.Set<Foundation.URLError.Code>
  final public let retryLimit: Swift.UInt
  final public let exponentialBackoffBase: Swift.UInt
  final public let exponentialBackoffScale: Swift.Double
  final public let retryableHTTPMethods: Swift.Set<RoomBoxUtils.RB_HTTPMethod>
  final public let retryableHTTPStatusCodes: Swift.Set<Swift.Int>
  final public let retryableURLErrorCodes: Swift.Set<Foundation.URLError.Code>
  public init(retryLimit: Swift.UInt = RetryPolicy.defaultRetryLimit, exponentialBackoffBase: Swift.UInt = RetryPolicy.defaultExponentialBackoffBase, exponentialBackoffScale: Swift.Double = RetryPolicy.defaultExponentialBackoffScale, retryableHTTPMethods: Swift.Set<RoomBoxUtils.RB_HTTPMethod> = RetryPolicy.defaultRetryableHTTPMethods, retryableHTTPStatusCodes: Swift.Set<Swift.Int> = RetryPolicy.defaultRetryableHTTPStatusCodes, retryableURLErrorCodes: Swift.Set<Foundation.URLError.Code> = RetryPolicy.defaultRetryableURLErrorCodes)
  open func retry(_ rb_request: RoomBoxUtils.RB_Request, for rb_session: RoomBoxUtils.RB_Session, dueTo error: Swift.Error, completion: @escaping (RoomBoxUtils.RetryResult) -> Swift.Void)
  open func shouldRetry(rb_request: RoomBoxUtils.RB_Request, dueTo error: Swift.Error) -> Swift.Bool
  @objc deinit
}
open class ConnectionLostRetryPolicy : RoomBoxUtils.RetryPolicy {
  public init(retryLimit: Swift.UInt = RetryPolicy.defaultRetryLimit, exponentialBackoffBase: Swift.UInt = RetryPolicy.defaultExponentialBackoffBase, exponentialBackoffScale: Swift.Double = RetryPolicy.defaultExponentialBackoffScale, retryableHTTPMethods: Swift.Set<RoomBoxUtils.RB_HTTPMethod> = RetryPolicy.defaultRetryableHTTPMethods)
  @objc deinit
  override public init(retryLimit: Swift.UInt = super, exponentialBackoffBase: Swift.UInt = super, exponentialBackoffScale: Swift.Double = super, retryableHTTPMethods: Swift.Set<RoomBoxUtils.RB_HTTPMethod> = super, retryableHTTPStatusCodes: Swift.Set<Swift.Int> = super, retryableURLErrorCodes: Swift.Set<Foundation.URLError.Code> = super)
}
open class RB_ServerTrustManager {
  final public let allHostsMustBeEvaluated: Swift.Bool
  final public let evaluators: [Swift.String : RoomBoxUtils.RB_ServerTrustEvaluating]
  public init(allHostsMustBeEvaluated: Swift.Bool = true, evaluators: [Swift.String : RoomBoxUtils.RB_ServerTrustEvaluating])
  open func serverTrustEvaluator(forHost host: Swift.String) throws -> RoomBoxUtils.RB_ServerTrustEvaluating?
  @objc deinit
}
public protocol RB_ServerTrustEvaluating {
  func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
}
final public class RB_DefaultTrustEvaluator : RoomBoxUtils.RB_ServerTrustEvaluating {
  public init(validateHost: Swift.Bool = true)
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
final public class RB_RevocationTrustEvaluator : RoomBoxUtils.RB_ServerTrustEvaluating {
  public struct Options : Swift.OptionSet {
    public static let crl: RoomBoxUtils.RB_RevocationTrustEvaluator.Options
    public static let networkAccessDisabled: RoomBoxUtils.RB_RevocationTrustEvaluator.Options
    public static let ocsp: RoomBoxUtils.RB_RevocationTrustEvaluator.Options
    public static let preferCRL: RoomBoxUtils.RB_RevocationTrustEvaluator.Options
    public static let requirePositiveResponse: RoomBoxUtils.RB_RevocationTrustEvaluator.Options
    public static let any: RoomBoxUtils.RB_RevocationTrustEvaluator.Options
    public let rawValue: CoreFoundation.CFOptionFlags
    public init(rawValue: CoreFoundation.CFOptionFlags)
    public typealias Element = RoomBoxUtils.RB_RevocationTrustEvaluator.Options
    public typealias ArrayLiteralElement = RoomBoxUtils.RB_RevocationTrustEvaluator.Options
    public typealias RawValue = CoreFoundation.CFOptionFlags
  }
  public init(performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true, options: RoomBoxUtils.RB_RevocationTrustEvaluator.Options = .any)
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
final public class RB_PinnedCertificatesTrustEvaluator : RoomBoxUtils.RB_ServerTrustEvaluating {
  public init(certificates: [Security.SecCertificate] = Bundle.main.af.certificates, acceptSelfSignedCertificates: Swift.Bool = false, performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true)
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
final public class RB_PublicKeysTrustEvaluator : RoomBoxUtils.RB_ServerTrustEvaluating {
  public init(keys: [Security.SecKey] = Bundle.main.af.publicKeys, performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true)
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
final public class RB_CompositeTrustEvaluator : RoomBoxUtils.RB_ServerTrustEvaluating {
  public init(evaluators: [RoomBoxUtils.RB_ServerTrustEvaluating])
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
@available(*, deprecated, renamed: "DisabledTrustEvaluator", message: "RB_DisabledEvaluator has been renamed DisabledTrustEvaluator.")
public typealias RB_DisabledEvaluator = RoomBoxUtils.DisabledTrustEvaluator
final public class DisabledTrustEvaluator : RoomBoxUtils.RB_ServerTrustEvaluating {
  public init()
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
extension Array where Element == RoomBoxUtils.RB_ServerTrustEvaluating {
  public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
}
extension Bundle : RoomBoxUtils.AlamofireExtended {
  public typealias ExtendedType = Foundation.Bundle
}
extension AlamofireExtension where ExtendedType : Foundation.Bundle {
  public var certificates: [Security.SecCertificate] {
    get
  }
  public var publicKeys: [Security.SecKey] {
    get
  }
  public func paths(forResourcesOfTypes types: [Swift.String]) -> [Swift.String]
}
extension SecTrust : RoomBoxUtils.AlamofireExtended {
  public typealias ExtendedType = Security.SecTrust
}
extension AlamofireExtension where ExtendedType == Security.SecTrust {
  @available(iOS 12, OSX 10.14, tvOS 12, watchOS 5, *)
  public func evaluate(afterApplying policy: Security.SecPolicy) throws
  @available(iOS, introduced: 10, deprecated: 12, renamed: "evaluate(afterApplying:)")
  @available(OSX, introduced: 10.12, deprecated: 10.14, renamed: "evaluate(afterApplying:)")
  @available(tvOS, introduced: 10, deprecated: 12, renamed: "evaluate(afterApplying:)")
  @available(watchOS, introduced: 3, deprecated: 5, renamed: "evaluate(afterApplying:)")
  public func validate(policy: Security.SecPolicy, errorProducer: (Darwin.OSStatus, Security.SecTrustResultType) -> Swift.Error) throws
  public func apply(policy: Security.SecPolicy) throws -> Security.SecTrust
  @available(iOS 12, OSX 10.14, tvOS 12, watchOS 5, *)
  public func evaluate() throws
  @available(iOS, introduced: 10, deprecated: 12, renamed: "evaluate()")
  @available(OSX, introduced: 10.12, deprecated: 10.14, renamed: "evaluate()")
  @available(tvOS, introduced: 10, deprecated: 12, renamed: "evaluate()")
  @available(watchOS, introduced: 3, deprecated: 5, renamed: "evaluate()")
  public func validate(errorProducer: (Darwin.OSStatus, Security.SecTrustResultType) -> Swift.Error) throws
  public func setAnchorCertificates(_ certificates: [Security.SecCertificate]) throws
  public var publicKeys: [Security.SecKey] {
    get
  }
  public var certificates: [Security.SecCertificate] {
    get
  }
  public var certificateData: [Foundation.Data] {
    get
  }
  public func performDefaultValidation(forHost host: Swift.String) throws
  public func performValidation(forHost host: Swift.String) throws
}
extension SecPolicy : RoomBoxUtils.AlamofireExtended {
  public typealias ExtendedType = Security.SecPolicy
}
extension AlamofireExtension where ExtendedType == Security.SecPolicy {
  public static let `default`: Security.SecPolicy
  public static func hostname(_ hostname: Swift.String) -> Security.SecPolicy
  public static func revocation(options: RoomBoxUtils.RB_RevocationTrustEvaluator.Options) throws -> Security.SecPolicy
}
extension Array : RoomBoxUtils.AlamofireExtended {
  public typealias ExtendedType = Swift.Array<Element>
}
extension AlamofireExtension where ExtendedType == [Security.SecCertificate] {
  public var data: [Foundation.Data] {
    get
  }
  public var publicKeys: [Security.SecKey] {
    get
  }
}
extension SecCertificate : RoomBoxUtils.AlamofireExtended {
  public typealias ExtendedType = Security.SecCertificate
}
extension AlamofireExtension where ExtendedType == Security.SecCertificate {
  public var publicKey: Security.SecKey? {
    get
  }
}
extension Int32 : RoomBoxUtils.AlamofireExtended {
  public typealias ExtendedType = Swift.Int32
}
extension AlamofireExtension where ExtendedType == Darwin.OSStatus {
  public var isSuccess: Swift.Bool {
    get
  }
}
extension SecTrustResultType : RoomBoxUtils.AlamofireExtended {
  public typealias ExtendedType = Security.SecTrustResultType
}
extension AlamofireExtension where ExtendedType == Security.SecTrustResultType {
  public var isSuccess: Swift.Bool {
    get
  }
}
open class RB_Session {
  public static let `default`: RoomBoxUtils.RB_Session
  final public let rb_session: Foundation.URLSession
  final public let delegate: RoomBoxUtils.RB_SessionDelegate
  final public let rootQueue: Dispatch.DispatchQueue
  final public let startRequestsImmediately: Swift.Bool
  final public let requestQueue: Dispatch.DispatchQueue
  final public let serializationQueue: Dispatch.DispatchQueue
  final public let interceptor: RoomBoxUtils.RB_RequestInterceptor?
  final public let serverTrustManager: RoomBoxUtils.RB_ServerTrustManager?
  final public let redirectHandler: RoomBoxUtils.RedirectHandler?
  final public let cachedResponseHandler: RoomBoxUtils.CachedResponseHandler?
  final public let eventMonitor: RoomBoxUtils.CompositeEventMonitor
  final public let defaultEventMonitors: [RoomBoxUtils.EventMonitor]
  public init(rb_session: Foundation.URLSession, delegate: RoomBoxUtils.RB_SessionDelegate, rootQueue: Dispatch.DispatchQueue, startRequestsImmediately: Swift.Bool = true, requestQueue: Dispatch.DispatchQueue? = nil, serializationQueue: Dispatch.DispatchQueue? = nil, interceptor: RoomBoxUtils.RB_RequestInterceptor? = nil, serverTrustManager: RoomBoxUtils.RB_ServerTrustManager? = nil, redirectHandler: RoomBoxUtils.RedirectHandler? = nil, cachedResponseHandler: RoomBoxUtils.CachedResponseHandler? = nil, eventMonitors: [RoomBoxUtils.EventMonitor] = [])
  convenience public init(configuration: Foundation.URLSessionConfiguration = URLSessionConfiguration.af.default, delegate: RoomBoxUtils.RB_SessionDelegate = RB_SessionDelegate(), rootQueue: Dispatch.DispatchQueue = DispatchQueue(label: "org.alamofire.rb_session.rootQueue"), startRequestsImmediately: Swift.Bool = true, requestQueue: Dispatch.DispatchQueue? = nil, serializationQueue: Dispatch.DispatchQueue? = nil, interceptor: RoomBoxUtils.RB_RequestInterceptor? = nil, serverTrustManager: RoomBoxUtils.RB_ServerTrustManager? = nil, redirectHandler: RoomBoxUtils.RedirectHandler? = nil, cachedResponseHandler: RoomBoxUtils.CachedResponseHandler? = nil, eventMonitors: [RoomBoxUtils.EventMonitor] = [])
  @objc deinit
  public func withAllRequests(perform action: @escaping (Swift.Set<RoomBoxUtils.RB_Request>) -> Swift.Void)
  public func rb_cancelAllRequests(completingOnQueue queue: Dispatch.DispatchQueue = .main, completion: (() -> Swift.Void)? = nil)
  public typealias RequestModifier = (inout Foundation.URLRequest) throws -> Swift.Void
  open func rb_request(_ convertible: RoomBoxUtils.URLConvertible, method: RoomBoxUtils.RB_HTTPMethod = .get, parameters: RoomBoxUtils.RB_Parameters? = nil, encoding: RoomBoxUtils.RB_ParameterEncoding = RB_URLEncoding.default, headers: RoomBoxUtils.RB_HTTPHeaders? = nil, interceptor: RoomBoxUtils.RB_RequestInterceptor? = nil, requestModifier: RoomBoxUtils.RB_Session.RequestModifier? = nil) -> RoomBoxUtils.RB_DataRequest
  open func rb_request<RB_Parameters>(_ convertible: RoomBoxUtils.URLConvertible, method: RoomBoxUtils.RB_HTTPMethod = .get, parameters: RB_Parameters? = nil, encoder: RoomBoxUtils.ParameterEncoder = RB_URLEncodedFormParameterEncoder.default, headers: RoomBoxUtils.RB_HTTPHeaders? = nil, interceptor: RoomBoxUtils.RB_RequestInterceptor? = nil, requestModifier: RoomBoxUtils.RB_Session.RequestModifier? = nil) -> RoomBoxUtils.RB_DataRequest where RB_Parameters : Swift.Encodable
  open func rb_request(_ convertible: RoomBoxUtils.RB_URLRequestConvertible, interceptor: RoomBoxUtils.RB_RequestInterceptor? = nil) -> RoomBoxUtils.RB_DataRequest
  open func streamRequest<RB_Parameters>(_ convertible: RoomBoxUtils.URLConvertible, method: RoomBoxUtils.RB_HTTPMethod = .get, parameters: RB_Parameters? = nil, encoder: RoomBoxUtils.ParameterEncoder = RB_URLEncodedFormParameterEncoder.default, headers: RoomBoxUtils.RB_HTTPHeaders? = nil, automaticallyCancelOnStreamError: Swift.Bool = false, interceptor: RoomBoxUtils.RB_RequestInterceptor? = nil, requestModifier: RoomBoxUtils.RB_Session.RequestModifier? = nil) -> RoomBoxUtils.DataStreamRequest where RB_Parameters : Swift.Encodable
  open func streamRequest(_ convertible: RoomBoxUtils.URLConvertible, method: RoomBoxUtils.RB_HTTPMethod = .get, headers: RoomBoxUtils.RB_HTTPHeaders? = nil, automaticallyCancelOnStreamError: Swift.Bool = false, interceptor: RoomBoxUtils.RB_RequestInterceptor? = nil, requestModifier: RoomBoxUtils.RB_Session.RequestModifier? = nil) -> RoomBoxUtils.DataStreamRequest
  open func streamRequest(_ convertible: RoomBoxUtils.RB_URLRequestConvertible, automaticallyCancelOnStreamError: Swift.Bool = false, interceptor: RoomBoxUtils.RB_RequestInterceptor? = nil) -> RoomBoxUtils.DataStreamRequest
  open func rb_download(_ convertible: RoomBoxUtils.URLConvertible, method: RoomBoxUtils.RB_HTTPMethod = .get, parameters: RoomBoxUtils.RB_Parameters? = nil, encoding: RoomBoxUtils.RB_ParameterEncoding = RB_URLEncoding.default, headers: RoomBoxUtils.RB_HTTPHeaders? = nil, interceptor: RoomBoxUtils.RB_RequestInterceptor? = nil, requestModifier: RoomBoxUtils.RB_Session.RequestModifier? = nil, to destination: RoomBoxUtils.RB_DownloadRequest.Destination? = nil) -> RoomBoxUtils.RB_DownloadRequest
  open func rb_download<RB_Parameters>(_ convertible: RoomBoxUtils.URLConvertible, method: RoomBoxUtils.RB_HTTPMethod = .get, parameters: RB_Parameters? = nil, encoder: RoomBoxUtils.ParameterEncoder = RB_URLEncodedFormParameterEncoder.default, headers: RoomBoxUtils.RB_HTTPHeaders? = nil, interceptor: RoomBoxUtils.RB_RequestInterceptor? = nil, requestModifier: RoomBoxUtils.RB_Session.RequestModifier? = nil, to destination: RoomBoxUtils.RB_DownloadRequest.Destination? = nil) -> RoomBoxUtils.RB_DownloadRequest where RB_Parameters : Swift.Encodable
  open func rb_download(_ convertible: RoomBoxUtils.RB_URLRequestConvertible, interceptor: RoomBoxUtils.RB_RequestInterceptor? = nil, to destination: RoomBoxUtils.RB_DownloadRequest.Destination? = nil) -> RoomBoxUtils.RB_DownloadRequest
  open func rb_download(resumingWith data: Foundation.Data, interceptor: RoomBoxUtils.RB_RequestInterceptor? = nil, to destination: RoomBoxUtils.RB_DownloadRequest.Destination? = nil) -> RoomBoxUtils.RB_DownloadRequest
  open func rb_upload(_ data: Foundation.Data, to convertible: RoomBoxUtils.URLConvertible, method: RoomBoxUtils.RB_HTTPMethod = .post, headers: RoomBoxUtils.RB_HTTPHeaders? = nil, interceptor: RoomBoxUtils.RB_RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default, requestModifier: RoomBoxUtils.RB_Session.RequestModifier? = nil) -> RoomBoxUtils.RB_UploadRequest
  open func rb_upload(_ data: Foundation.Data, with convertible: RoomBoxUtils.RB_URLRequestConvertible, interceptor: RoomBoxUtils.RB_RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default) -> RoomBoxUtils.RB_UploadRequest
  open func rb_upload(_ fileURL: Foundation.URL, to convertible: RoomBoxUtils.URLConvertible, method: RoomBoxUtils.RB_HTTPMethod = .post, headers: RoomBoxUtils.RB_HTTPHeaders? = nil, interceptor: RoomBoxUtils.RB_RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default, requestModifier: RoomBoxUtils.RB_Session.RequestModifier? = nil) -> RoomBoxUtils.RB_UploadRequest
  open func rb_upload(_ fileURL: Foundation.URL, with convertible: RoomBoxUtils.RB_URLRequestConvertible, interceptor: RoomBoxUtils.RB_RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default) -> RoomBoxUtils.RB_UploadRequest
  open func rb_upload(_ stream: Foundation.InputStream, to convertible: RoomBoxUtils.URLConvertible, method: RoomBoxUtils.RB_HTTPMethod = .post, headers: RoomBoxUtils.RB_HTTPHeaders? = nil, interceptor: RoomBoxUtils.RB_RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default, requestModifier: RoomBoxUtils.RB_Session.RequestModifier? = nil) -> RoomBoxUtils.RB_UploadRequest
  open func rb_upload(_ stream: Foundation.InputStream, with convertible: RoomBoxUtils.RB_URLRequestConvertible, interceptor: RoomBoxUtils.RB_RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default) -> RoomBoxUtils.RB_UploadRequest
  open func rb_upload(multipartFormData: @escaping (RoomBoxUtils.RB_MultipartFormData) -> Swift.Void, to url: RoomBoxUtils.URLConvertible, usingThreshold encodingMemoryThreshold: Swift.UInt64 = RB_MultipartFormData.encodingMemoryThreshold, method: RoomBoxUtils.RB_HTTPMethod = .post, headers: RoomBoxUtils.RB_HTTPHeaders? = nil, interceptor: RoomBoxUtils.RB_RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default, requestModifier: RoomBoxUtils.RB_Session.RequestModifier? = nil) -> RoomBoxUtils.RB_UploadRequest
  open func rb_upload(multipartFormData: @escaping (RoomBoxUtils.RB_MultipartFormData) -> Swift.Void, with rb_request: RoomBoxUtils.RB_URLRequestConvertible, usingThreshold encodingMemoryThreshold: Swift.UInt64 = RB_MultipartFormData.encodingMemoryThreshold, interceptor: RoomBoxUtils.RB_RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default) -> RoomBoxUtils.RB_UploadRequest
  open func rb_upload(multipartFormData: RoomBoxUtils.RB_MultipartFormData, to url: RoomBoxUtils.URLConvertible, usingThreshold encodingMemoryThreshold: Swift.UInt64 = RB_MultipartFormData.encodingMemoryThreshold, method: RoomBoxUtils.RB_HTTPMethod = .post, headers: RoomBoxUtils.RB_HTTPHeaders? = nil, interceptor: RoomBoxUtils.RB_RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default, requestModifier: RoomBoxUtils.RB_Session.RequestModifier? = nil) -> RoomBoxUtils.RB_UploadRequest
  open func rb_upload(multipartFormData: RoomBoxUtils.RB_MultipartFormData, with rb_request: RoomBoxUtils.RB_URLRequestConvertible, usingThreshold encodingMemoryThreshold: Swift.UInt64 = RB_MultipartFormData.encodingMemoryThreshold, interceptor: RoomBoxUtils.RB_RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default) -> RoomBoxUtils.RB_UploadRequest
}
extension RB_Session : RoomBoxUtils.RequestDelegate {
  public var sessionConfiguration: Foundation.URLSessionConfiguration {
    get
  }
  public var startImmediately: Swift.Bool {
    get
  }
  public func cleanup(after rb_request: RoomBoxUtils.RB_Request)
  public func retryResult(for rb_request: RoomBoxUtils.RB_Request, dueTo error: RoomBoxUtils.RB_AFError, completion: @escaping (RoomBoxUtils.RetryResult) -> Swift.Void)
  public func retryRequest(_ rb_request: RoomBoxUtils.RB_Request, withDelay timeDelay: Foundation.TimeInterval?)
}
@objc open class RB_SessionDelegate : ObjectiveC.NSObject {
  public init(fileManager: Foundation.FileManager = .default)
  @objc override dynamic public init()
  @objc deinit
}
extension RB_SessionDelegate : Foundation.URLSessionDelegate {
  @objc dynamic open func urlSession(_ rb_session: Foundation.URLSession, didBecomeInvalidWithError error: Swift.Error?)
}
extension RB_SessionDelegate : Foundation.URLSessionTaskDelegate {
  @objc dynamic open func urlSession(_ rb_session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  @objc dynamic open func urlSession(_ rb_session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  @objc dynamic open func urlSession(_ rb_session: Foundation.URLSession, task: Foundation.URLSessionTask, needNewBodyStream completionHandler: @escaping (Foundation.InputStream?) -> Swift.Void)
  @objc dynamic open func urlSession(_ rb_session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest rb_request: Foundation.URLRequest, completionHandler: @escaping (Foundation.URLRequest?) -> Swift.Void)
  @objc dynamic open func urlSession(_ rb_session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  @objc dynamic open func urlSession(_ rb_session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
  @available(OSX 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  @objc dynamic open func urlSession(_ rb_session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
}
extension RB_SessionDelegate : Foundation.URLSessionDataDelegate {
  @objc dynamic open func urlSession(_ rb_session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  @objc dynamic open func urlSession(_ rb_session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse, completionHandler: @escaping (Foundation.CachedURLResponse?) -> Swift.Void)
}
extension RB_SessionDelegate : Foundation.URLSessionDownloadDelegate {
  @objc dynamic open func urlSession(_ rb_session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  @objc dynamic open func urlSession(_ rb_session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  @objc dynamic open func urlSession(_ rb_session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
}
public protocol URLConvertible {
  func asURL() throws -> Foundation.URL
}
extension String : RoomBoxUtils.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
extension URL : RoomBoxUtils.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
extension URLComponents : RoomBoxUtils.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
public protocol RB_URLRequestConvertible {
  func asURLRequest() throws -> Foundation.URLRequest
}
extension RB_URLRequestConvertible {
  public var urlRequest: Foundation.URLRequest? {
    get
  }
}
extension URLRequest : RoomBoxUtils.RB_URLRequestConvertible {
  public func asURLRequest() throws -> Foundation.URLRequest
}
extension URLRequest {
  public init(url: RoomBoxUtils.URLConvertible, method: RoomBoxUtils.RB_HTTPMethod, headers: RoomBoxUtils.RB_HTTPHeaders? = nil) throws
}
final public class RB_URLEncodedFormEncoder {
  public enum ArrayEncoding {
    case brackets
    case noBrackets
    public static func == (a: RoomBoxUtils.RB_URLEncodedFormEncoder.ArrayEncoding, b: RoomBoxUtils.RB_URLEncodedFormEncoder.ArrayEncoding) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public enum BoolEncoding {
    case numeric
    case literal
    public static func == (a: RoomBoxUtils.RB_URLEncodedFormEncoder.BoolEncoding, b: RoomBoxUtils.RB_URLEncodedFormEncoder.BoolEncoding) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public enum DataEncoding {
    case deferredToData
    case base64
    case custom((Foundation.Data) throws -> Swift.String)
  }
  public enum DateEncoding {
    case deferredToDate
    case secondsSince1970
    case millisecondsSince1970
    case iso8601
    case formatted(Foundation.DateFormatter)
    case custom((Foundation.Date) throws -> Swift.String)
  }
  public enum KeyEncoding {
    case useDefaultKeys
    case convertToSnakeCase
    case convertToKebabCase
    case capitalized
    case uppercased
    case lowercased
    case custom((Swift.String) -> Swift.String)
  }
  public enum SpaceEncoding {
    case percentEscaped
    case plusReplaced
    public static func == (a: RoomBoxUtils.RB_URLEncodedFormEncoder.SpaceEncoding, b: RoomBoxUtils.RB_URLEncodedFormEncoder.SpaceEncoding) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public enum Error : Swift.Error {
    case invalidRootObject(Swift.String)
  }
  final public let alphabetizeKeyValuePairs: Swift.Bool
  final public let arrayEncoding: RoomBoxUtils.RB_URLEncodedFormEncoder.ArrayEncoding
  final public let boolEncoding: RoomBoxUtils.RB_URLEncodedFormEncoder.BoolEncoding
  final public let dataEncoding: RoomBoxUtils.RB_URLEncodedFormEncoder.DataEncoding
  final public let dateEncoding: RoomBoxUtils.RB_URLEncodedFormEncoder.DateEncoding
  final public let keyEncoding: RoomBoxUtils.RB_URLEncodedFormEncoder.KeyEncoding
  final public let spaceEncoding: RoomBoxUtils.RB_URLEncodedFormEncoder.SpaceEncoding
  final public var allowedCharacters: Foundation.CharacterSet
  public init(alphabetizeKeyValuePairs: Swift.Bool = true, arrayEncoding: RoomBoxUtils.RB_URLEncodedFormEncoder.ArrayEncoding = .brackets, boolEncoding: RoomBoxUtils.RB_URLEncodedFormEncoder.BoolEncoding = .numeric, dataEncoding: RoomBoxUtils.RB_URLEncodedFormEncoder.DataEncoding = .base64, dateEncoding: RoomBoxUtils.RB_URLEncodedFormEncoder.DateEncoding = .deferredToDate, keyEncoding: RoomBoxUtils.RB_URLEncodedFormEncoder.KeyEncoding = .useDefaultKeys, spaceEncoding: RoomBoxUtils.RB_URLEncodedFormEncoder.SpaceEncoding = .percentEscaped, allowedCharacters: Foundation.CharacterSet = .afURLQueryAllowed)
  final public func encode(_ value: Swift.Encodable) throws -> Swift.String
  final public func encode(_ value: Swift.Encodable) throws -> Foundation.Data
  @objc deinit
}
extension CharacterSet {
  public static let afURLQueryAllowed: Foundation.CharacterSet
}
extension URLRequest {
  public var method: RoomBoxUtils.RB_HTTPMethod? {
    get
    set
  }
  public func validate() throws
}
extension URLSessionConfiguration : RoomBoxUtils.AlamofireExtended {
  public typealias ExtendedType = Foundation.URLSessionConfiguration
}
extension AlamofireExtension where ExtendedType : Foundation.URLSessionConfiguration {
  public static var `default`: Foundation.URLSessionConfiguration {
    get
  }
}
extension RB_Request {
  public typealias ValidationResult = Swift.Result<Swift.Void, Swift.Error>
}
extension RB_DataRequest {
  public typealias Validation = (Foundation.URLRequest?, Foundation.HTTPURLResponse, Foundation.Data?) -> RoomBoxUtils.RB_DataRequest.ValidationResult
  @discardableResult
  public func validate<S>(statusCode acceptableStatusCodes: S) -> Self where S : Swift.Sequence, S.Element == Swift.Int
  @discardableResult
  public func validate<S>(contentType acceptableContentTypes: @autoclosure @escaping () -> S) -> Self where S : Swift.Sequence, S.Element == Swift.String
  @discardableResult
  public func validate() -> Self
}
extension DataStreamRequest {
  public typealias Validation = (Foundation.URLRequest?, Foundation.HTTPURLResponse) -> RoomBoxUtils.DataStreamRequest.ValidationResult
  @discardableResult
  final public func validate<S>(statusCode acceptableStatusCodes: S) -> Self where S : Swift.Sequence, S.Element == Swift.Int
  @discardableResult
  final public func validate<S>(contentType acceptableContentTypes: @autoclosure @escaping () -> S) -> Self where S : Swift.Sequence, S.Element == Swift.String
  @discardableResult
  final public func validate() -> Self
}
extension RB_DownloadRequest {
  public typealias Validation = (Foundation.URLRequest?, Foundation.HTTPURLResponse, Foundation.URL?) -> RoomBoxUtils.RB_DownloadRequest.ValidationResult
  @discardableResult
  public func validate<S>(statusCode acceptableStatusCodes: S) -> Self where S : Swift.Sequence, S.Element == Swift.Int
  @discardableResult
  public func validate<S>(contentType acceptableContentTypes: @autoclosure @escaping () -> S) -> Self where S : Swift.Sequence, S.Element == Swift.String
  @discardableResult
  public func validate() -> Self
}
public protocol RBAEAD {
  static var kLen: Swift.Int { get }
  static var ivRange: Swift.Range<Swift.Int> { get }
}
@_hasMissingDesignatedInitializers final public class RBAEADChaCha20Poly1305 : RoomBoxUtils.RBAEAD {
  public static let kLen: Swift.Int
  public static var ivRange: Swift.Range<Swift.Int>
  public static func encrypt(_ plainText: Swift.Array<Swift.UInt8>, key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>, authenticationHeader: Swift.Array<Swift.UInt8>) throws -> (cipherText: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>)
  public static func decrypt(_ cipherText: Swift.Array<Swift.UInt8>, key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>, authenticationHeader: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>) throws -> (plainText: Swift.Array<Swift.UInt8>, success: Swift.Bool)
  @objc deinit
}
extension RBAES {
  convenience public init(key: Swift.String, iv: Swift.String, padding: RoomBoxUtils.RBPadding = .pkcs7) throws
}
extension RBAES : RoomBoxUtils.RBCryptors {
  @inlinable final public func makeEncryptor() throws -> RoomBoxUtils.RBCryptor & RoomBoxUtils.RBUpdatable {
    let blockSize = blockMode.customBlockSize ?? RBAES.blockSize
    let worker = try blockMode.worker(blockSize: blockSize, cipherOperation: encrypt, encryptionOperation: encrypt)
    if worker is StreamModeWorker {
      return try RBStreamEncryptor(blockSize: blockSize, padding: padding, worker)
    }
    return try RBBlockEncryptor(blockSize: blockSize, padding: padding, worker)
  }
  @inlinable final public func makeDecryptor() throws -> RoomBoxUtils.RBCryptor & RoomBoxUtils.RBUpdatable {
    let blockSize = blockMode.customBlockSize ?? RBAES.blockSize
    let cipherOperation: RBCipherOperationOnBlock = blockMode.options.contains(.useEncryptToDecrypt) == true ? encrypt : decrypt
    let worker = try blockMode.worker(blockSize: blockSize, cipherOperation: cipherOperation, encryptionOperation: encrypt)
    if worker is StreamModeWorker {
      return try RBStreamDecryptor(blockSize: blockSize, padding: padding, worker)
    }
    return try RBBlockDecryptor(blockSize: blockSize, padding: padding, worker)
  }
}
final public class RBAES {
  public enum Error : Swift.Error {
    case invalidKeySize
    case dataPaddingRequired
    case invalidData
    public static func == (a: RoomBoxUtils.RBAES.Error, b: RoomBoxUtils.RBAES.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public enum Variant : Swift.Int {
    case aes128, aes192, aes256
    public typealias RawValue = Swift.Int
    public init?(rawValue: Swift.Int)
    public var rawValue: Swift.Int {
      get
    }
  }
  @usableFromInline
  final internal let variantNr: Swift.Int
  @usableFromInline
  final internal let variantNb: Swift.Int
  @usableFromInline
  final internal let variantNk: Swift.Int
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  final public let variant: RoomBoxUtils.RBAES.Variant
  @usableFromInline
  final internal let blockMode: RoomBoxUtils.RBBlockMode
  @usableFromInline
  final internal let padding: RoomBoxUtils.RBPadding
  @usableFromInline
  final internal var expandedKey: Swift.Array<Swift.Array<Swift.UInt32>> {
    get
    set
  }
  @usableFromInline
  final internal var expandedKeyInv: Swift.Array<Swift.Array<Swift.UInt32>> {
    get
    set
  }
  @usableFromInline
  internal static let T0: [Swift.UInt32]
  @usableFromInline
  internal static let T0_INV: [Swift.UInt32]
  @usableFromInline
  internal static let T1: [Swift.UInt32]
  @usableFromInline
  internal static let T1_INV: [Swift.UInt32]
  @usableFromInline
  internal static let T2: [Swift.UInt32]
  @usableFromInline
  internal static let T2_INV: [Swift.UInt32]
  @usableFromInline
  internal static let T3: [Swift.UInt32]
  @usableFromInline
  internal static let T3_INV: [Swift.UInt32]
  @usableFromInline
  internal static let U1: [Swift.UInt32]
  @usableFromInline
  internal static let U2: [Swift.UInt32]
  @usableFromInline
  internal static let U3: [Swift.UInt32]
  @usableFromInline
  internal static let U4: [Swift.UInt32]
  public init(key: Swift.Array<Swift.UInt8>, blockMode: RoomBoxUtils.RBBlockMode, padding: RoomBoxUtils.RBPadding = .pkcs7) throws
  @inlinable final internal func encrypt(block: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>? {
    if self.blockMode.options.contains(.paddingRequired) && block.count != RBAES.blockSize {
      return Array(block)
    }

    let rounds = self.variantNr
    let rk = self.expandedKey

    let b00 = UInt32(block[block.startIndex.advanced(by: 0)])
    let b01 = UInt32(block[block.startIndex.advanced(by: 1)]) << 8
    let b02 = UInt32(block[block.startIndex.advanced(by: 2)]) << 16
    let b03 = UInt32(block[block.startIndex.advanced(by: 3)]) << 24
    var b0 = b00 | b01 | b02 | b03

    let b10 = UInt32(block[block.startIndex.advanced(by: 4)])
    let b11 = UInt32(block[block.startIndex.advanced(by: 5)]) << 8
    let b12 = UInt32(block[block.startIndex.advanced(by: 6)]) << 16
    let b13 = UInt32(block[block.startIndex.advanced(by: 7)]) << 24
    var b1 = b10 | b11 | b12 | b13

    let b20 = UInt32(block[block.startIndex.advanced(by: 8)])
    let b21 = UInt32(block[block.startIndex.advanced(by: 9)]) << 8
    let b22 = UInt32(block[block.startIndex.advanced(by: 10)]) << 16
    let b23 = UInt32(block[block.startIndex.advanced(by: 11)]) << 24
    var b2 = b20 | b21 | b22 | b23

    let b30 = UInt32(block[block.startIndex.advanced(by: 12)])
    let b31 = UInt32(block[block.startIndex.advanced(by: 13)]) << 8
    let b32 = UInt32(block[block.startIndex.advanced(by: 14)]) << 16
    let b33 = UInt32(block[block.startIndex.advanced(by: 15)]) << 24
    var b3 = b30 | b31 | b32 | b33

    let tLength = 4
    let t = UnsafeMutablePointer<UInt32>.allocate(capacity: tLength)
    t.initialize(repeating: 0, count: tLength)
    defer {
      t.deinitialize(count: tLength)
      t.deallocate()
    }

    for r in 0..<rounds - 1 {
      t[0] = b0 ^ rk[r][0]
      t[1] = b1 ^ rk[r][1]
      t[2] = b2 ^ rk[r][2]
      t[3] = b3 ^ rk[r][3]

      let lb00 = RBAES.T0[Int(t[0] & 0xff)]
      let lb01 = RBAES.T1[Int((t[1] >> 8) & 0xff)]
      let lb02 = RBAES.T2[Int((t[2] >> 16) & 0xff)]
      let lb03 = RBAES.T3[Int(t[3] >> 24)]
      b0 = lb00 ^ lb01 ^ lb02 ^ lb03

      let lb10 = RBAES.T0[Int(t[1] & 0xff)]
      let lb11 = RBAES.T1[Int((t[2] >> 8) & 0xff)]
      let lb12 = RBAES.T2[Int((t[3] >> 16) & 0xff)]
      let lb13 = RBAES.T3[Int(t[0] >> 24)]
      b1 = lb10 ^ lb11 ^ lb12 ^ lb13

      let lb20 = RBAES.T0[Int(t[2] & 0xff)]
      let lb21 = RBAES.T1[Int((t[3] >> 8) & 0xff)]
      let lb22 = RBAES.T2[Int((t[0] >> 16) & 0xff)]
      let lb23 = RBAES.T3[Int(t[1] >> 24)]
      b2 = lb20 ^ lb21 ^ lb22 ^ lb23

      let lb30 = RBAES.T0[Int(t[3] & 0xff)]
      let lb31 = RBAES.T1[Int((t[0] >> 8) & 0xff)]
      let lb32 = RBAES.T2[Int((t[1] >> 16) & 0xff)]
      let lb33 = RBAES.T3[Int(t[2] >> 24)]
      b3 = lb30 ^ lb31 ^ lb32 ^ lb33
    }

    // last round
    let r = rounds - 1

    t[0] = b0 ^ rk[r][0]
    t[1] = b1 ^ rk[r][1]
    t[2] = b2 ^ rk[r][2]
    t[3] = b3 ^ rk[r][3]

    // rounds
    b0 = F1(t[0], t[1], t[2], t[3]) ^ rk[rounds][0]
    b1 = F1(t[1], t[2], t[3], t[0]) ^ rk[rounds][1]
    b2 = F1(t[2], t[3], t[0], t[1]) ^ rk[rounds][2]
    b3 = F1(t[3], t[0], t[1], t[2]) ^ rk[rounds][3]

    let encrypted: Array<UInt8> = [
      UInt8(b0 & 0xff), UInt8((b0 >> 8) & 0xff), UInt8((b0 >> 16) & 0xff), UInt8((b0 >> 24) & 0xff),
      UInt8(b1 & 0xff), UInt8((b1 >> 8) & 0xff), UInt8((b1 >> 16) & 0xff), UInt8((b1 >> 24) & 0xff),
      UInt8(b2 & 0xff), UInt8((b2 >> 8) & 0xff), UInt8((b2 >> 16) & 0xff), UInt8((b2 >> 24) & 0xff),
      UInt8(b3 & 0xff), UInt8((b3 >> 8) & 0xff), UInt8((b3 >> 16) & 0xff), UInt8((b3 >> 24) & 0xff)
    ]
    return encrypted
  }
  @usableFromInline
  final internal func decrypt(block: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>?
  @objc deinit
}
extension RBAES {
  @usableFromInline
  @inline(__always) final internal func F1(_ x0: Swift.UInt32, _ x1: Swift.UInt32, _ x2: Swift.UInt32, _ x3: Swift.UInt32) -> Swift.UInt32
}
extension RBAES : RoomBoxUtils.RBCipher {
  @inlinable final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    let blockSize = self.blockMode.customBlockSize ?? RBAES.blockSize
    let chunks = bytes.batched(by: blockSize)

    var oneTimeCryptor = try makeEncryptor()
    var out = Array<UInt8>(reserveCapacity: bytes.count)
    for chunk in chunks {
      out += try oneTimeCryptor.update(withBytes: chunk, isLast: false)
    }
    // Padding may be added at the very end
    out += try oneTimeCryptor.finish()

    if self.blockMode.options.contains(.paddingRequired) && (out.count % RBAES.blockSize != 0) {
      throw Error.dataPaddingRequired
    }

    return out
  }
  @inlinable final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    if self.blockMode.options.contains(.paddingRequired) && (bytes.count % RBAES.blockSize != 0) {
      throw Error.dataPaddingRequired
    }

    var oneTimeCryptor = try makeDecryptor()
    let chunks = bytes.batched(by: RBAES.blockSize)
    if chunks.isEmpty {
      throw Error.invalidData
    }

    var out = Array<UInt8>(reserveCapacity: bytes.count)

    var lastIdx = chunks.startIndex
    chunks.indices.formIndex(&lastIdx, offsetBy: chunks.count - 1)

    // To properly remove padding, `isLast` has to be known when called with the last chunk of ciphertext
    // Last chunk of ciphertext may contains padded data so next call to update(..) won't be able to remove it
    for idx in chunks.indices {
      out += try oneTimeCryptor.update(withBytes: chunks[idx], isLast: idx == lastIdx)
    }
    return out
  }
}
@objc @_inheritsConvenienceInitializers final public class RBAnimatedButton : RoomBoxUtils.RBAnimatedControl {
  final public func setPlayRange(fromProgress: RoomBoxUtils.AnimationProgressTime, toProgress: RoomBoxUtils.AnimationProgressTime, event: UIKit.UIControl.Event)
  final public func setPlayRange(fromMarker fromName: Swift.String, toMarker toName: Swift.String, event: UIKit.UIControl.Event)
  override public init(animation: RoomBoxUtils.RBAnimation)
  @objc override dynamic public init()
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc override final public func beginTracking(_ touch: UIKit.UITouch, with event: UIKit.UIEvent?) -> Swift.Bool
  @objc override final public func endTracking(_ touch: UIKit.UITouch?, with event: UIKit.UIEvent?)
  @objc deinit
}
@objc open class RBAnimatedControl : UIKit.UIControl {
  final public let animationView: RoomBoxUtils.RBAnimationView
  public var animation: RoomBoxUtils.RBAnimation? {
    get
    set
  }
  public var animationSpeed: CoreGraphics.CGFloat {
    get
    set
  }
  public func setLayer(named: Swift.String, forState: UIKit.UIControl.State)
  public func setValueProvider(_ valueProvider: RoomBoxUtils.RBAnyValueProvider, keypath: RoomBoxUtils.RBAnimationKeypath)
  public init(animation: RoomBoxUtils.RBAnimation)
  @objc dynamic public init()
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc override dynamic open var isEnabled: Swift.Bool {
    @objc get
    @objc set
  }
  @objc override dynamic open var isSelected: Swift.Bool {
    @objc get
    @objc set
  }
  @objc override dynamic open var isHighlighted: Swift.Bool {
    @objc get
    @objc set
  }
  @objc override dynamic open func beginTracking(_ touch: UIKit.UITouch, with event: UIKit.UIEvent?) -> Swift.Bool
  @objc override dynamic open func continueTracking(_ touch: UIKit.UITouch, with event: UIKit.UIEvent?) -> Swift.Bool
  @objc override dynamic open func endTracking(_ touch: UIKit.UITouch?, with event: UIKit.UIEvent?)
  @objc override dynamic open func cancelTracking(with event: UIKit.UIEvent?)
  @objc override dynamic open var intrinsicContentSize: CoreGraphics.CGSize {
    @objc get
  }
  open func animationDidSet()
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers final public class RBAnimatedSwitch : RoomBoxUtils.RBAnimatedControl {
  public enum CancelBehavior {
    case reverse
    case none
    public static func == (a: RoomBoxUtils.RBAnimatedSwitch.CancelBehavior, b: RoomBoxUtils.RBAnimatedSwitch.CancelBehavior) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  final public var isOn: Swift.Bool {
    get
    set
  }
  final public var cancelBehavior: RoomBoxUtils.RBAnimatedSwitch.CancelBehavior
  final public func setIsOn(_ isOn: Swift.Bool, animated: Swift.Bool, shouldFireHaptics: Swift.Bool = true)
  final public func setProgressForState(fromProgress: RoomBoxUtils.AnimationProgressTime, toProgress: RoomBoxUtils.AnimationProgressTime, forOnState: Swift.Bool)
  override public init(animation: RoomBoxUtils.RBAnimation)
  @objc override dynamic public init()
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc override final public func endTracking(_ touch: UIKit.UITouch?, with event: UIKit.UIEvent?)
  override final public func animationDidSet()
  @objc deinit
}
public enum CoordinateSpace : Swift.Int, Swift.Codable {
  case type2d
  case type3d
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
final public class RBAnimation : Swift.Codable {
  final public let startFrame: RoomBoxUtils.AnimationFrameTime
  final public let endFrame: RoomBoxUtils.AnimationFrameTime
  final public let framerate: Swift.Double
  final public var markerNames: [Swift.String] {
    get
  }
  required public init(from decoder: Swift.Decoder) throws
  @objc deinit
  final public func encode(to encoder: Swift.Encoder) throws
}
public protocol RBAnimationCacheProvider {
  func animation(forKey: Swift.String) -> RoomBoxUtils.RBAnimation?
  func setAnimation(_ animation: RoomBoxUtils.RBAnimation, forKey: Swift.String)
  func clearCache()
}
public typealias LottieCompletionBlock = (Swift.Bool) -> Swift.Void
public protocol RBAnimationFontProvider {
  func fontFor(family: Swift.String, size: CoreGraphics.CGFloat) -> CoreText.CTFont?
}
final public class DefaultFontProvider : RoomBoxUtils.RBAnimationFontProvider {
  final public func fontFor(family: Swift.String, size: CoreGraphics.CGFloat) -> CoreText.CTFont?
  public init()
  @objc deinit
}
public protocol RBAnimationImageProvider {
  func imageForAsset(asset: RoomBoxUtils.RBImageAsset) -> CoreGraphics.CGImage?
}
public struct RBAnimationKeypath {
  public init(keypath: Swift.String)
  public init(keys: [Swift.String])
}
extension RBAnimation {
  public static func named(_ name: Swift.String, bundle: Foundation.Bundle = Bundle.main, subdirectory: Swift.String? = nil, animationCache: RoomBoxUtils.RBAnimationCacheProvider? = nil) -> RoomBoxUtils.RBAnimation?
  public static func filepath(_ filepath: Swift.String, animationCache: RoomBoxUtils.RBAnimationCacheProvider? = nil) -> RoomBoxUtils.RBAnimation?
  public typealias DownloadClosure = (RoomBoxUtils.RBAnimation?) -> Swift.Void
  public static func loadedFrom(url: Foundation.URL, closure: @escaping RoomBoxUtils.RBAnimation.DownloadClosure, animationCache: RoomBoxUtils.RBAnimationCacheProvider?)
  final public func progressTime(forMarker named: Swift.String) -> RoomBoxUtils.AnimationProgressTime?
  final public func frameTime(forMarker named: Swift.String) -> RoomBoxUtils.AnimationFrameTime?
  final public func progressTime(forFrame frameTime: RoomBoxUtils.AnimationFrameTime) -> RoomBoxUtils.AnimationProgressTime
  final public func frameTime(forProgress progressTime: RoomBoxUtils.AnimationProgressTime) -> RoomBoxUtils.AnimationFrameTime
  final public func time(forFrame frameTime: RoomBoxUtils.AnimationFrameTime) -> Foundation.TimeInterval
  final public func frameTime(forTime time: Foundation.TimeInterval) -> RoomBoxUtils.AnimationFrameTime
  final public var duration: Foundation.TimeInterval {
    get
  }
  final public var bounds: CoreGraphics.CGRect {
    get
  }
  final public var size: CoreGraphics.CGSize {
    get
  }
}
@objc @_inheritsConvenienceInitializers final public class RBAnimationSubview : UIKit.UIView {
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
public protocol RBAnimationTextProvider : AnyObject {
  func textFor(keypathName: Swift.String, sourceText: Swift.String) -> Swift.String
}
final public class DictionaryTextProvider : RoomBoxUtils.RBAnimationTextProvider {
  public init(_ values: [Swift.String : Swift.String])
  final public func textFor(keypathName: Swift.String, sourceText: Swift.String) -> Swift.String
  @objc deinit
}
final public class DefaultTextProvider : RoomBoxUtils.RBAnimationTextProvider {
  final public func textFor(keypathName: Swift.String, sourceText: Swift.String) -> Swift.String
  public init()
  @objc deinit
}
public typealias AnimationFrameTime = CoreGraphics.CGFloat
public typealias AnimationProgressTime = CoreGraphics.CGFloat
public enum LottieBackgroundBehavior {
  case stop
  case pause
  case pauseAndRestore
  case forceFinish
  public static func == (a: RoomBoxUtils.LottieBackgroundBehavior, b: RoomBoxUtils.LottieBackgroundBehavior) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public enum LottieLoopMode {
  case playOnce
  case loop
  case autoReverse
  case `repeat`(Swift.Float)
  case repeatBackwards(Swift.Float)
}
extension LottieLoopMode : Swift.Equatable {
  public static func == (lhs: RoomBoxUtils.LottieLoopMode, rhs: RoomBoxUtils.LottieLoopMode) -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers @IBDesignable final public class RBAnimationView : RoomBoxUtils.RBLottieView {
  final public var animation: RoomBoxUtils.RBAnimation? {
    get
    set
  }
  final public var backgroundBehavior: RoomBoxUtils.LottieBackgroundBehavior
  final public var imageProvider: RoomBoxUtils.RBAnimationImageProvider {
    get
    set
  }
  final public var textProvider: RoomBoxUtils.RBAnimationTextProvider {
    get
    set
  }
  final public var fontProvider: RoomBoxUtils.RBAnimationFontProvider {
    get
    set
  }
  final public var isAnimationPlaying: Swift.Bool {
    get
  }
  final public var isAnimationQueued: Swift.Bool {
    get
  }
  final public var loopMode: RoomBoxUtils.LottieLoopMode {
    get
    set
  }
  final public var shouldRasterizeWhenIdle: Swift.Bool {
    get
    set
  }
  final public var currentProgress: RoomBoxUtils.AnimationProgressTime {
    get
    set
  }
  final public var currentTime: Foundation.TimeInterval {
    get
    set
  }
  final public var currentFrame: RoomBoxUtils.AnimationFrameTime {
    get
    set
  }
  final public var realtimeAnimationFrame: RoomBoxUtils.AnimationFrameTime {
    get
  }
  final public var realtimeAnimationProgress: RoomBoxUtils.AnimationProgressTime {
    get
  }
  final public var animationSpeed: CoreGraphics.CGFloat {
    get
    set
  }
  final public var respectAnimationFrameRate: Swift.Bool {
    get
    set
  }
  final public var viewportFrame: CoreGraphics.CGRect? {
    get
    set
  }
  final public func play(completion: RoomBoxUtils.LottieCompletionBlock? = nil)
  final public func play(fromProgress: RoomBoxUtils.AnimationProgressTime? = nil, toProgress: RoomBoxUtils.AnimationProgressTime, loopMode: RoomBoxUtils.LottieLoopMode? = nil, completion: RoomBoxUtils.LottieCompletionBlock? = nil)
  final public func play(fromFrame: RoomBoxUtils.AnimationFrameTime? = nil, toFrame: RoomBoxUtils.AnimationFrameTime, loopMode: RoomBoxUtils.LottieLoopMode? = nil, completion: RoomBoxUtils.LottieCompletionBlock? = nil)
  final public func play(fromMarker: Swift.String? = nil, toMarker: Swift.String, loopMode: RoomBoxUtils.LottieLoopMode? = nil, completion: RoomBoxUtils.LottieCompletionBlock? = nil)
  final public func stop()
  final public func pause()
  final public func reloadImages()
  final public func forceDisplayUpdate()
  final public func setValueProvider(_ valueProvider: RoomBoxUtils.RBAnyValueProvider, keypath: RoomBoxUtils.RBAnimationKeypath)
  final public func getValue(for keypath: RoomBoxUtils.RBAnimationKeypath, atFrame: RoomBoxUtils.AnimationFrameTime?) -> Any?
  final public func logHierarchyKeypaths()
  final public func addSubview(_ subview: RoomBoxUtils.RBAnimationSubview, forLayerAt keypath: RoomBoxUtils.RBAnimationKeypath)
  final public func convert(_ rect: CoreGraphics.CGRect, toLayerAt keypath: RoomBoxUtils.RBAnimationKeypath?) -> CoreGraphics.CGRect?
  final public func convert(_ point: CoreGraphics.CGPoint, toLayerAt keypath: RoomBoxUtils.RBAnimationKeypath?) -> CoreGraphics.CGPoint?
  final public func setNodeIsEnabled(isEnabled: Swift.Bool, keypath: RoomBoxUtils.RBAnimationKeypath)
  final public func progressTime(forMarker named: Swift.String) -> RoomBoxUtils.AnimationProgressTime?
  final public func frameTime(forMarker named: Swift.String) -> RoomBoxUtils.AnimationFrameTime?
  public init(animation: RoomBoxUtils.RBAnimation?, imageProvider: RoomBoxUtils.RBAnimationImageProvider? = nil, textProvider: RoomBoxUtils.RBAnimationTextProvider = DefaultTextProvider(), fontProvider: RoomBoxUtils.RBAnimationFontProvider = DefaultFontProvider())
  @objc dynamic public init()
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc override final public var intrinsicContentSize: CoreGraphics.CGSize {
    @objc get
  }
  @objc deinit
}
extension RBAnimationView {
  convenience public init(name: Swift.String, bundle: Foundation.Bundle = Bundle.main, imageProvider: RoomBoxUtils.RBAnimationImageProvider? = nil, animationCache: RoomBoxUtils.RBAnimationCacheProvider? = RBLRUAnimationCache.sharedCache)
  convenience public init(filePath: Swift.String, imageProvider: RoomBoxUtils.RBAnimationImageProvider? = nil, animationCache: RoomBoxUtils.RBAnimationCacheProvider? = RBLRUAnimationCache.sharedCache)
  convenience public init(url: Foundation.URL, imageProvider: RoomBoxUtils.RBAnimationImageProvider? = nil, closure: @escaping RoomBoxUtils.RBAnimationView.DownloadClosure, animationCache: RoomBoxUtils.RBAnimationCacheProvider? = RBLRUAnimationCache.sharedCache)
  public typealias DownloadClosure = (Swift.Error?) -> Swift.Void
}
@objc public protocol RBPhotoBrowserAnimatorDelegate {
  @objc func willPresent(_ browser: RoomBoxUtils.RBPhotoBrowser)
  @objc func willDismiss(_ browser: RoomBoxUtils.RBPhotoBrowser)
}
public protocol RBAnyValueProvider {
  var valueType: Any.Type { get }
  func hasUpdate(frame: RoomBoxUtils.AnimationFrameTime) -> Swift.Bool
  func value(frame: RoomBoxUtils.AnimationFrameTime) -> Any
}
@objc @_inheritsConvenienceInitializers public class RBAPPUtils : ObjectiveC.NSObject {
  public class func isCNLanguage() -> Swift.Bool
  public class func language() -> Swift.String
  public typealias ResultCallback = (Swift.Bool) -> Swift.Void
  @objc public class func screenshot(view: UIKit.UIView, callback: @escaping RoomBoxUtils.RBAPPUtils.ResultCallback)
  @objc public class func savePhoto(savedImage: UIKit.UIImage, callback: @escaping RoomBoxUtils.RBAPPUtils.ResultCallback)
  @objc public class func base64Encode(from: Foundation.NSString) -> Foundation.NSString
  @objc public class func base64Decode(from: Foundation.NSString) -> Foundation.NSString
  public class func keyWindow() -> UIKit.UIWindow?
  public class func currentTopVC() -> UIKit.UIViewController?
  @objc deinit
  @objc override dynamic public init()
}
public class RBAsset : Swift.Codable {
  final public let id: Swift.String
  required public init(from decoder: Swift.Decoder) throws
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
}
public protocol RBAuthenticator {
  func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
@objc @_inheritsConvenienceInitializers public class RBBaseFoundationImage : UIKit.UIImage {
  @objc public class func roomboxBundle() -> Foundation.Bundle
  @objc public class func baseFoundationImage(imageName fro: Swift.String) -> UIKit.UIImage?
  @objc public class func publicFoundationImage(imageName fro: Swift.String) -> UIKit.UIImage?
  @objc public class func rb_roombox_resource_bundle() -> Foundation.Bundle
  @objc deinit
  @objc override dynamic public init?(contentsOfFile path: Swift.String)
  @objc override dynamic public init?(data: Foundation.Data)
  @available(iOS 6.0, *)
  @objc override dynamic public init?(data: Foundation.Data, scale: CoreGraphics.CGFloat)
  @objc override dynamic public init(cgImage: CoreGraphics.CGImage)
  @available(iOS 4.0, *)
  @objc override dynamic public init(cgImage: CoreGraphics.CGImage, scale: CoreGraphics.CGFloat, orientation: UIKit.UIImage.Orientation)
  @available(iOS 5.0, *)
  @objc override dynamic public init(ciImage: CoreImage.CIImage)
  @available(iOS 6.0, *)
  @objc override dynamic public init(ciImage: CoreImage.CIImage, scale: CoreGraphics.CGFloat, orientation: UIKit.UIImage.Orientation)
  @objc override dynamic public init()
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
@usableFromInline
internal struct RBBatchedCollectionIndex<Base> where Base : Swift.Collection {
}
extension RBBatchedCollectionIndex : Swift.Comparable {
  @usableFromInline
  internal static func == <Base>(lhs: RoomBoxUtils.RBBatchedCollectionIndex<Base>, rhs: RoomBoxUtils.RBBatchedCollectionIndex<Base>) -> Swift.Bool where Base : Swift.Collection
  @usableFromInline
  internal static func < <Base>(lhs: RoomBoxUtils.RBBatchedCollectionIndex<Base>, rhs: RoomBoxUtils.RBBatchedCollectionIndex<Base>) -> Swift.Bool where Base : Swift.Collection
}
@usableFromInline
internal struct BatchedCollection<Base> : Swift.Collection where Base : Swift.Collection {
  @usableFromInline
  internal init(base: Base, size: Swift.Int)
  @usableFromInline
  internal typealias Index = RoomBoxUtils.RBBatchedCollectionIndex<Base>
  @usableFromInline
  internal var startIndex: RoomBoxUtils.BatchedCollection<Base>.Index {
    get
  }
  @usableFromInline
  internal var endIndex: RoomBoxUtils.BatchedCollection<Base>.Index {
    get
  }
  @usableFromInline
  internal func index(after idx: RoomBoxUtils.BatchedCollection<Base>.Index) -> RoomBoxUtils.BatchedCollection<Base>.Index
  @usableFromInline
  internal subscript(idx: RoomBoxUtils.BatchedCollection<Base>.Index) -> Base.SubSequence {
    get
  }
  @usableFromInline
  internal typealias Element = Base.SubSequence
  @usableFromInline
  internal typealias Iterator = Swift.IndexingIterator<RoomBoxUtils.BatchedCollection<Base>>
  @usableFromInline
  internal typealias SubSequence = Swift.Slice<RoomBoxUtils.BatchedCollection<Base>>
  @usableFromInline
  internal typealias Indices = Swift.DefaultIndices<RoomBoxUtils.BatchedCollection<Base>>
}
extension Collection {
  @inlinable internal func batched(by size: Swift.Int) -> RoomBoxUtils.BatchedCollection<Self> {
    BatchedCollection(base: self, size: size)
  }
}
public enum RBBit : Swift.Int {
  case zero
  case one
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
extension RBBit {
  @inlinable internal func inverted() -> RoomBoxUtils.RBBit {
    self == .zero ? .one : .zero
  }
}
public class RBBlockDecryptor : RoomBoxUtils.RBCryptor, RoomBoxUtils.RBUpdatable {
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal let padding: RoomBoxUtils.RBPadding
  @usableFromInline
  internal var worker: RoomBoxUtils.RBCipherModeWorker
  @usableFromInline
  internal var accumulated: [Swift.UInt8]
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: RoomBoxUtils.RBPadding, _ worker: RoomBoxUtils.RBCipherModeWorker) throws
  @inlinable public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    // If a worker (eg GCM) can combine ciphertext + tag
    // we need to remove tag from the ciphertext.
    if !isLast && self.accumulated.count < self.blockSize + self.worker.additionalBufferSize {
      return []
    }

    let accumulatedWithoutSuffix: Array<UInt8>
    if self.worker.additionalBufferSize > 0 {
      // FIXME: how slow is that?
      accumulatedWithoutSuffix = Array(self.accumulated.prefix(self.accumulated.count - self.worker.additionalBufferSize))
    } else {
      accumulatedWithoutSuffix = self.accumulated
    }

    var processedBytesCount = 0
    var plaintext = Array<UInt8>(reserveCapacity: accumulatedWithoutSuffix.count)
    // Processing in a block-size manner. It's good for block modes, but bad for stream modes.
    for var chunk in accumulatedWithoutSuffix.batched(by: self.blockSize) {
      if isLast || (accumulatedWithoutSuffix.count - processedBytesCount) >= blockSize {
        let isLastChunk = processedBytesCount + chunk.count == accumulatedWithoutSuffix.count

        if isLast, isLastChunk, var finalizingWorker = worker as? FinalizingDecryptModeWorker {
          chunk = try finalizingWorker.willDecryptLast(bytes: chunk + accumulated.suffix(worker.additionalBufferSize)) // tag size
        }

        if !chunk.isEmpty {
          plaintext += worker.decrypt(block: chunk)
        }

        if isLast, isLastChunk, var finalizingWorker = worker as? FinalizingDecryptModeWorker {
          plaintext = Array(try finalizingWorker.didDecryptLast(bytes: plaintext.slice))
        }

        processedBytesCount += chunk.count
      }
    }
    accumulated.removeFirst(processedBytesCount) // super-slow

    if isLast {
      if accumulatedWithoutSuffix.isEmpty, var finalizingWorker = worker as? FinalizingDecryptModeWorker {
        try finalizingWorker.willDecryptLast(bytes: self.accumulated.suffix(self.worker.additionalBufferSize))
        plaintext = Array(try finalizingWorker.didDecryptLast(bytes: plaintext.slice))
      }
      plaintext = self.padding.remove(from: plaintext, blockSize: self.blockSize)
    }

    return plaintext
  }
  public func seek(to position: Swift.Int) throws
  @objc deinit
}
@usableFromInline
final internal class RBBlockEncryptor : RoomBoxUtils.RBCryptor, RoomBoxUtils.RBUpdatable {
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: RoomBoxUtils.RBPadding, _ worker: RoomBoxUtils.RBCipherModeWorker) throws
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8>
  @usableFromInline
  final internal func seek(to: Swift.Int) throws
  @objc @usableFromInline
  deinit
}
public typealias RBCipherOperationOnBlock = (Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>?
public protocol RBBlockMode {
  var options: RoomBoxUtils.RBBlockModeOption { get }
  @inlinable func worker(blockSize: Swift.Int, cipherOperation: @escaping RoomBoxUtils.RBCipherOperationOnBlock, encryptionOperation: @escaping RoomBoxUtils.RBCipherOperationOnBlock) throws -> RoomBoxUtils.RBCipherModeWorker
  var customBlockSize: Swift.Int? { get }
}
public struct RBBlockModeOption : Swift.OptionSet {
  public let rawValue: Swift.Int
  public init(rawValue: Swift.Int)
  @usableFromInline
  internal static let none: RoomBoxUtils.RBBlockModeOption
  @usableFromInline
  internal static let initializationVectorRequired: RoomBoxUtils.RBBlockModeOption
  @usableFromInline
  internal static let paddingRequired: RoomBoxUtils.RBBlockModeOption
  @usableFromInline
  internal static let useEncryptToDecrypt: RoomBoxUtils.RBBlockModeOption
  public typealias Element = RoomBoxUtils.RBBlockModeOption
  public typealias ArrayLiteralElement = RoomBoxUtils.RBBlockModeOption
  public typealias RawValue = Swift.Int
}
extension RBBlowfish {
  convenience public init(key: Swift.String, iv: Swift.String, padding: RoomBoxUtils.RBPadding = .pkcs7) throws
}
final public class RBBlowfish {
  public enum Error : Swift.Error {
    case dataPaddingRequired
    case invalidKeyOrInitializationVector
    case invalidInitializationVector
    case invalidBlockMode
    public static func == (a: RoomBoxUtils.RBBlowfish.Error, b: RoomBoxUtils.RBBlowfish.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>, blockMode: RoomBoxUtils.RBBlockMode = RBCBC(iv: Array<UInt8>(repeating: 0, count: RBBlowfish.blockSize)), padding: RoomBoxUtils.RBPadding) throws
  @objc deinit
}
extension RBBlowfish : RoomBoxUtils.RBCipher {
  final public func encrypt<C>(_ bytes: C) throws -> Swift.Array<Swift.UInt8> where C : Swift.Collection, C.Element == Swift.UInt8, C.Index == Swift.Int
  final public func decrypt<C>(_ bytes: C) throws -> Swift.Array<Swift.UInt8> where C : Swift.Collection, C.Element == Swift.UInt8, C.Index == Swift.Int
}
public class RBBundleImageProvider : RoomBoxUtils.RBAnimationImageProvider {
  public init(bundle: Foundation.Bundle, searchPath: Swift.String?)
  public func imageForAsset(asset: RoomBoxUtils.RBImageAsset) -> CoreGraphics.CGImage?
  @objc deinit
}
@_hasMissingDesignatedInitializers open class RBCache {
  public static let sharedCache: RoomBoxUtils.RBCache
  open var imageCache: RoomBoxUtils.RBCacheable
  open func imageForKey(_ key: Swift.String) -> UIKit.UIImage?
  open func setImage(_ image: UIKit.UIImage, forKey key: Swift.String)
  open func removeImageForKey(_ key: Swift.String)
  open func removeAllImages()
  open func imageForRequest(_ request: Foundation.URLRequest) -> UIKit.UIImage?
  open func setImageData(_ data: Foundation.Data, response: Foundation.URLResponse, request: Foundation.URLRequest?)
  @objc deinit
}
public protocol RBCacheable {
}
public protocol RBImageCacheable : RoomBoxUtils.RBCacheable {
  func imageForKey(_ key: Swift.String) -> UIKit.UIImage?
  func setImage(_ image: UIKit.UIImage, forKey key: Swift.String)
  func removeImageForKey(_ key: Swift.String)
  func removeAllImages()
}
public protocol RBRequestResponseCacheable : RoomBoxUtils.RBCacheable {
  func cachedResponseForRequest(_ request: Foundation.URLRequest) -> Foundation.CachedURLResponse?
  func storeCachedResponse(_ cachedResponse: Foundation.CachedURLResponse, forRequest request: Foundation.URLRequest)
}
@objc @_inheritsConvenienceInitializers open class RBCaptionView : UIKit.UIView {
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  convenience public init(photo: RoomBoxUtils.RBPhotoProtocol)
  @objc override dynamic open func sizeThatFits(_ size: CoreGraphics.CGSize) -> CoreGraphics.CGSize
  @objc deinit
}
public struct RBCBC : RoomBoxUtils.RBBlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: RoomBoxUtils.RBCBC.Error, b: RoomBoxUtils.RBCBC.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public let options: RoomBoxUtils.RBBlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping RoomBoxUtils.RBCipherOperationOnBlock, encryptionOperation: @escaping RoomBoxUtils.RBCipherOperationOnBlock) throws -> RoomBoxUtils.RBCipherModeWorker
}
@_inheritsConvenienceInitializers final public class RBCBCMAC : RoomBoxUtils.RBCMAC {
  override final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
  override public init(key: Swift.Array<Swift.UInt8>) throws
}
public struct RBCCM {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    case invalidParameter
    case fail
    public static func == (a: RoomBoxUtils.RBCCM.Error, b: RoomBoxUtils.RBCCM.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public let options: RoomBoxUtils.RBBlockModeOption
  public let customBlockSize: Swift.Int?
  public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(iv: Swift.Array<Swift.UInt8>, tagLength: Swift.Int, messageLength: Swift.Int, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil)
  public init(iv: Swift.Array<Swift.UInt8>, tagLength: Swift.Int, messageLength: Swift.Int, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping RoomBoxUtils.RBCipherOperationOnBlock, encryptionOperation: @escaping RoomBoxUtils.RBCipherOperationOnBlock) throws -> RoomBoxUtils.RBCipherModeWorker
}
public struct RBCFB : RoomBoxUtils.RBBlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: RoomBoxUtils.RBCFB.Error, b: RoomBoxUtils.RBCFB.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public enum SegmentSize : Swift.Int {
    case cfb8
    case cfb128
    public typealias RawValue = Swift.Int
    public init?(rawValue: Swift.Int)
    public var rawValue: Swift.Int {
      get
    }
  }
  public let options: RoomBoxUtils.RBBlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>, segmentSize: RoomBoxUtils.RBCFB.SegmentSize = .cfb128)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping RoomBoxUtils.RBCipherOperationOnBlock, encryptionOperation: @escaping RoomBoxUtils.RBCipherOperationOnBlock) throws -> RoomBoxUtils.RBCipherModeWorker
}
extension RBChaCha20 {
  convenience public init(key: Swift.String, iv: Swift.String) throws
}
final public class RBChaCha20 {
  public enum Error : Swift.Error {
    case invalidKeyOrInitializationVector
    case notSupported
    public static func == (a: RoomBoxUtils.RBChaCha20.Error, b: RoomBoxUtils.RBChaCha20.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>, iv nonce: Swift.Array<Swift.UInt8>) throws
  @objc deinit
}
extension RBChaCha20 : RoomBoxUtils.RBCipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension RBChaCha20 {
  public struct ChaChaEncryptor : RoomBoxUtils.RBCryptor, RoomBoxUtils.RBUpdatable {
    public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
    public func seek(to: Swift.Int) throws
  }
}
extension RBChaCha20 {
  public struct ChaChaDecryptor : RoomBoxUtils.RBCryptor, RoomBoxUtils.RBUpdatable {
    public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = true) throws -> Swift.Array<Swift.UInt8>
    public func seek(to: Swift.Int) throws
  }
}
extension RBChaCha20 : RoomBoxUtils.RBCryptors {
  final public func makeEncryptor() -> RoomBoxUtils.RBCryptor & RoomBoxUtils.RBUpdatable
  final public func makeDecryptor() -> RoomBoxUtils.RBCryptor & RoomBoxUtils.RBUpdatable
}
final public class RBChecksum {
  @usableFromInline
  internal static let table32: [Swift.UInt32]
  @usableFromInline
  internal static let table32c: [Swift.UInt32]
  @usableFromInline
  internal static let table16: [Swift.UInt16]
  @usableFromInline
  internal init()
  @inlinable final internal func crc32(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    var crc: UInt32 = seed != nil ? seed! : 0xFFFF_FFFF
    for chunk in message.batched(by: 256) {
      for b in chunk {
        let idx = Int((crc ^ UInt32(reflect ? b : reversed(b))) & 0xFF)
        crc = (crc >> 8) ^ RBChecksum.table32[idx]
      }
    }
    return (reflect ? crc : reversed(crc)) ^ 0xFFFF_FFFF
  }
  @inlinable final internal func crc32c(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    var crc: UInt32 = seed != nil ? seed! : 0xFFFF_FFFF
    for chunk in message.batched(by: 256) {
      for b in chunk {
        let idx = Int((crc ^ UInt32(reflect ? b : reversed(b))) & 0xFF)
        crc = (crc >> 8) ^ RBChecksum.table32c[idx]
      }
    }
    return (reflect ? crc : reversed(crc)) ^ 0xFFFF_FFFF
  }
  @inlinable final internal func crc16(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt16? = nil) -> Swift.UInt16 {
    var crc: UInt16 = seed != nil ? seed! : 0x0000
    for chunk in message.batched(by: 256) {
      for b in chunk {
        crc = (crc >> 8) ^ RBChecksum.table16[Int((crc ^ UInt16(b)) & 0xFF)]
      }
    }
    return crc
  }
  @objc deinit
}
extension RBChecksum {
  @inlinable public static func crc32(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    RBChecksum().crc32(message, seed: seed, reflect: reflect)
  }
  @inlinable public static func crc32c(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    RBChecksum().crc32c(message, seed: seed, reflect: reflect)
  }
  @inlinable public static func crc16(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt16? = nil) -> Swift.UInt16 {
    RBChecksum().crc16(message, seed: seed)
  }
}
public enum CipherError : Swift.Error {
  case encrypt
  case decrypt
  public static func == (a: RoomBoxUtils.CipherError, b: RoomBoxUtils.CipherError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol RBCipher : AnyObject {
  var keySize: Swift.Int { get }
  func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func encrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func decrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension RBCipher {
  public func encrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public func decrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
public protocol RBCipherModeWorker {
  var cipherOperation: RoomBoxUtils.RBCipherOperationOnBlock { get }
  var additionalBufferSize: Swift.Int { get }
  @inlinable mutating func encrypt(block plaintext: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @inlinable mutating func decrypt(block ciphertext: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
}
public protocol BlockModeWorker : RoomBoxUtils.RBCipherModeWorker {
  var blockSize: Swift.Int { get }
}
public protocol CounterModeWorker : RoomBoxUtils.RBCipherModeWorker {
  associatedtype Counter
  var counter: Self.Counter { get set }
}
public protocol SeekableModeWorker : RoomBoxUtils.RBCipherModeWorker {
  mutating func seek(to position: Swift.Int) throws
}
public protocol StreamModeWorker : RoomBoxUtils.RBCipherModeWorker {
}
public protocol FinalizingEncryptModeWorker : RoomBoxUtils.RBCipherModeWorker {
  mutating func finalize(encrypt ciphertext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
}
public protocol FinalizingDecryptModeWorker : RoomBoxUtils.RBCipherModeWorker {
  @discardableResult
  mutating func willDecryptLast(bytes ciphertext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
  mutating func didDecryptLast(bytes plaintext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
  mutating func finalize(decrypt plaintext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
}
public class RBClearMessage : RoomBoxUtils.RBMessage {
  final public let data: Foundation.Data
  required public init(data: Foundation.Data)
  convenience public init(string: Swift.String, using encoding: Swift.String.Encoding) throws
  public func string(encoding: Swift.String.Encoding) throws -> Swift.String
  public func encrypted(with key: RoomBoxUtils.RBPublicKey, padding: RoomBoxUtils.Padding) throws -> RoomBoxUtils.RBEncryptedMessage
  public func signed(with key: RoomBoxUtils.RBPrivateKey, digestType: RoomBoxUtils.RBSignature.DigestType) throws -> RoomBoxUtils.RBSignature
  public func verify(with key: RoomBoxUtils.RBPublicKey, signature: RoomBoxUtils.RBSignature, digestType: RoomBoxUtils.RBSignature.DigestType) throws -> Swift.Bool
  @objc deinit
}
public class RBCMAC : RoomBoxUtils.RBAuthenticator {
  public enum Error : Swift.Error {
    case wrongKeyLength
    public static func == (a: RoomBoxUtils.RBCMAC.Error, b: RoomBoxUtils.RBCMAC.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public init(key: Swift.Array<Swift.UInt8>) throws
  public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public func authenticate(_ bytes: Swift.Array<Swift.UInt8>, cipher: RoomBoxUtils.RBCipher) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension Collection where Self.Element == Swift.UInt8, Self.Index == Swift.Int {
  @inlinable internal func toUInt32Array() -> Swift.Array<Swift.UInt32> {
    guard !isEmpty else {
      return []
    }

    let c = strideCount(from: startIndex, to: endIndex, by: 4)
    return Array<UInt32>(unsafeUninitializedCapacity: c) { buf, count in
      var counter = 0
      for idx in stride(from: startIndex, to: endIndex, by: 4) {
        let val = UInt32(bytes: self, fromIndex: idx).bigEndian
        buf[counter] = val
        counter += 1
      }
      count = counter
      assert(counter == c)
    }
  }
  @inlinable internal func toUInt64Array() -> Swift.Array<Swift.UInt64> {
    guard !isEmpty else {
      return []
    }

    let c = strideCount(from: startIndex, to: endIndex, by: 8)
    return Array<UInt64>(unsafeUninitializedCapacity: c) { buf, count in
      var counter = 0
      for idx in stride(from: startIndex, to: endIndex, by: 8) {
        let val = UInt64(bytes: self, fromIndex: idx).bigEndian
        buf[counter] = val
        counter += 1
      }
      count = counter
      assert(counter == c)
    }
  }
}
@usableFromInline
internal func strideCount(from: Swift.Int, to: Swift.Int, by: Swift.Int) -> Swift.Int
public enum ColorFormatDenominator {
  case One
  case OneHundred
  case TwoFiftyFive
  public static func == (a: RoomBoxUtils.ColorFormatDenominator, b: RoomBoxUtils.ColorFormatDenominator) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public struct RBColor {
  public var r: Swift.Double
  public var g: Swift.Double
  public var b: Swift.Double
  public var a: Swift.Double
  public init(r: Swift.Double, g: Swift.Double, b: Swift.Double, a: Swift.Double, denominator: RoomBoxUtils.ColorFormatDenominator = .One)
}
extension RBColor : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
final public class RBColorValueProvider : RoomBoxUtils.RBAnyValueProvider {
  public typealias ColorValueBlock = (CoreGraphics.CGFloat) -> RoomBoxUtils.RBColor
  final public var color: RoomBoxUtils.RBColor {
    get
    set
  }
  public init(block: @escaping RoomBoxUtils.RBColorValueProvider.ColorValueBlock)
  public init(_ color: RoomBoxUtils.RBColor)
  final public var valueType: Any.Type {
    get
  }
  final public func hasUpdate(frame: CoreGraphics.CGFloat) -> Swift.Bool
  final public func value(frame: CoreGraphics.CGFloat) -> Any
  @objc deinit
}
@objc final public class RBCompatibleAnimationKeypath : ObjectiveC.NSObject {
  @objc public init(keypath: Swift.String)
  @objc public init(keys: [Swift.String])
  final public let animationKeypath: RoomBoxUtils.RBAnimationKeypath
  @objc deinit
  @objc override dynamic public init()
}
@objc final public class CompatibleAnimation : ObjectiveC.NSObject {
  @objc public init(name: Swift.String, bundle: Foundation.Bundle = Bundle.main)
  @objc deinit
  @objc override dynamic public init()
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc final public class RBCompatibleAnimationView : UIKit.UIView {
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc final public var compatibleAnimation: RoomBoxUtils.CompatibleAnimation? {
    @objc get
    @objc set
  }
  @objc final public var loopAnimationCount: CoreGraphics.CGFloat {
    @objc get
    @objc set
  }
  @objc override final public var contentMode: UIKit.UIView.ContentMode {
    @objc get
    @objc set
  }
  @objc final public var shouldRasterizeWhenIdle: Swift.Bool {
    @objc get
    @objc set
  }
  @objc final public var currentProgress: CoreGraphics.CGFloat {
    @objc get
    @objc set
  }
  @objc final public var currentTime: Foundation.TimeInterval {
    @objc get
    @objc set
  }
  @objc final public var currentFrame: CoreGraphics.CGFloat {
    @objc get
    @objc set
  }
  @objc final public var realtimeAnimationFrame: CoreGraphics.CGFloat {
    @objc get
  }
  @objc final public var realtimeAnimationProgress: CoreGraphics.CGFloat {
    @objc get
  }
  @objc final public var animationSpeed: CoreGraphics.CGFloat {
    @objc get
    @objc set
  }
  @objc final public var respectAnimationFrameRate: Swift.Bool {
    @objc get
    @objc set
  }
  @objc final public var isAnimationPlaying: Swift.Bool {
    @objc get
  }
  @objc final public func play()
  @objc final public func play(completion: ((Swift.Bool) -> Swift.Void)?)
  @objc final public func play(fromProgress: CoreGraphics.CGFloat, toProgress: CoreGraphics.CGFloat, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @objc final public func play(fromFrame: CoreGraphics.CGFloat, toFrame: CoreGraphics.CGFloat, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @objc final public func play(fromMarker: Swift.String, toMarker: Swift.String, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @objc final public func stop()
  @objc final public func pause()
  @objc final public func reloadImages()
  @objc final public func forceDisplayUpdate()
  @objc final public func getValue(for keypath: RoomBoxUtils.RBCompatibleAnimationKeypath, atFrame: CoreGraphics.CGFloat) -> Any?
  @objc final public func logHierarchyKeypaths()
  @objc final public func setColorValue(_ color: UIKit.UIColor, forKeypath keypath: RoomBoxUtils.RBCompatibleAnimationKeypath)
  @objc final public func getColorValue(for keypath: RoomBoxUtils.RBCompatibleAnimationKeypath, atFrame: CoreGraphics.CGFloat) -> UIKit.UIColor?
  @objc final public func addSubview(_ subview: RoomBoxUtils.RBAnimationSubview, forLayerAt keypath: RoomBoxUtils.RBCompatibleAnimationKeypath)
  @objc final public func convert(rect: CoreGraphics.CGRect, toLayerAt keypath: RoomBoxUtils.RBCompatibleAnimationKeypath?) -> CoreGraphics.CGRect
  @objc final public func convert(point: CoreGraphics.CGPoint, toLayerAt keypath: RoomBoxUtils.RBCompatibleAnimationKeypath?) -> CoreGraphics.CGPoint
  @objc final public func progressTime(forMarker named: Swift.String) -> CoreGraphics.CGFloat
  @objc final public func frameTime(forMarker named: Swift.String) -> CoreGraphics.CGFloat
  @objc deinit
}
public struct DeserializeOptions : Swift.OptionSet {
  public let rawValue: Swift.Int
  public static let caseInsensitive: RoomBoxUtils.DeserializeOptions
  public static let defaultOptions: RoomBoxUtils.DeserializeOptions
  public init(rawValue: Swift.Int)
  public typealias Element = RoomBoxUtils.DeserializeOptions
  public typealias ArrayLiteralElement = RoomBoxUtils.DeserializeOptions
  public typealias RawValue = Swift.Int
}
public enum DebugMode : Swift.Int {
  case verbose
  case debug
  case error
  case none
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public struct RBHandyJSONConfiguration {
  public static var debugMode: RoomBoxUtils.DebugMode {
    get
    set
  }
  public static var deserializeOptions: RoomBoxUtils.DeserializeOptions
}
@_hasMissingDesignatedInitializers final public class RBConstraint {
  final public var layoutConstraints: [RoomBoxUtils.RBLayoutConstraint]
  final public var isActive: Swift.Bool {
    get
    set
  }
  @available(*, deprecated, message: "Use activate().")
  final public func install()
  @available(*, deprecated, message: "Use deactivate().")
  final public func uninstall()
  final public func activate()
  final public func deactivate()
  @discardableResult
  final public func update(offset: RoomBoxUtils.RBConstraintOffsetTarget) -> RoomBoxUtils.RBConstraint
  @discardableResult
  final public func update(inset: RoomBoxUtils.RBConstraintInsetTarget) -> RoomBoxUtils.RBConstraint
  @available(iOS 11.0, tvOS 11.0, *)
  @discardableResult
  final public func update(inset: RoomBoxUtils.RBConstraintDirectionalInsetTarget) -> RoomBoxUtils.RBConstraint
  @discardableResult
  final public func update(priority: RoomBoxUtils.RBConstraintPriorityTarget) -> RoomBoxUtils.RBConstraint
  @discardableResult
  final public func update(priority: RoomBoxUtils.RBConstraintPriority) -> RoomBoxUtils.RBConstraint
  @available(*, deprecated, message: "Use update(offset: ConstraintOffsetTarget) instead.")
  final public func updateOffset(amount: RoomBoxUtils.RBConstraintOffsetTarget)
  @available(*, deprecated, message: "Use update(inset: ConstraintInsetTarget) instead.")
  final public func updateInsets(amount: RoomBoxUtils.RBConstraintInsetTarget)
  @available(*, deprecated, message: "Use update(priority: ConstraintPriorityTarget) instead.")
  final public func updatePriority(amount: RoomBoxUtils.RBConstraintPriorityTarget)
  @available(*, deprecated, message: "Use update(priority: ConstraintPriorityTarget) instead.")
  final public func updatePriorityRequired()
  @available(*, deprecated, message: "Use update(priority: ConstraintPriorityTarget) instead.")
  final public func updatePriorityHigh()
  @available(*, deprecated, message: "Use update(priority: ConstraintPriorityTarget) instead.")
  final public func updatePriorityMedium()
  @available(*, deprecated, message: "Use update(priority: ConstraintPriorityTarget) instead.")
  final public func updatePriorityLow()
  @objc deinit
}
public typealias RBConstraintInterfaceLayoutDirection = UIKit.UIUserInterfaceLayoutDirection
public struct RBConstraintConfig {
  public static var interfaceLayoutDirection: RoomBoxUtils.RBConstraintInterfaceLayoutDirection
}
public protocol RBConstraintConstantTarget {
}
extension CGPoint : RoomBoxUtils.RBConstraintConstantTarget {
}
extension CGSize : RoomBoxUtils.RBConstraintConstantTarget {
}
extension UIEdgeInsets : RoomBoxUtils.RBConstraintConstantTarget {
}
@available(iOS 11.0, tvOS 11.0, *)
extension NSDirectionalEdgeInsets : RoomBoxUtils.RBConstraintConstantTarget {
}
@_hasMissingDesignatedInitializers public class RBConstraintDescription {
  @objc deinit
}
@available(iOS 11.0, tvOS 11.0, *)
public typealias RBConstraintDirectionalInsets = UIKit.NSDirectionalEdgeInsets
public protocol RBConstraintDirectionalInsetTarget : RoomBoxUtils.RBConstraintConstantTarget {
}
@available(iOS 11.0, tvOS 11.0, *)
extension NSDirectionalEdgeInsets : RoomBoxUtils.RBConstraintDirectionalInsetTarget {
}
public protocol RBConstraintDSL {
  var target: Swift.AnyObject? { get }
  func setLabel(_ value: Swift.String?)
  func label() -> Swift.String?
}
extension RBConstraintDSL {
  public func setLabel(_ value: Swift.String?)
  public func label() -> Swift.String?
}
public protocol RBConstraintBasicAttributesDSL : RoomBoxUtils.RBConstraintDSL {
}
extension RBConstraintBasicAttributesDSL {
  public var left: RoomBoxUtils.RBConstraintItem {
    get
  }
  public var top: RoomBoxUtils.RBConstraintItem {
    get
  }
  public var right: RoomBoxUtils.RBConstraintItem {
    get
  }
  public var bottom: RoomBoxUtils.RBConstraintItem {
    get
  }
  public var leading: RoomBoxUtils.RBConstraintItem {
    get
  }
  public var trailing: RoomBoxUtils.RBConstraintItem {
    get
  }
  public var width: RoomBoxUtils.RBConstraintItem {
    get
  }
  public var height: RoomBoxUtils.RBConstraintItem {
    get
  }
  public var centerX: RoomBoxUtils.RBConstraintItem {
    get
  }
  public var centerY: RoomBoxUtils.RBConstraintItem {
    get
  }
  public var edges: RoomBoxUtils.RBConstraintItem {
    get
  }
  public var directionalEdges: RoomBoxUtils.RBConstraintItem {
    get
  }
  public var size: RoomBoxUtils.RBConstraintItem {
    get
  }
  public var center: RoomBoxUtils.RBConstraintItem {
    get
  }
}
public protocol RBConstraintAttributesDSL : RoomBoxUtils.RBConstraintBasicAttributesDSL {
}
extension RBConstraintAttributesDSL {
  @available(*, deprecated, message: "Use .lastBaseline instead")
  public var baseline: RoomBoxUtils.RBConstraintItem {
    get
  }
  @available(iOS 8.0, OSX 10.11, *)
  public var lastBaseline: RoomBoxUtils.RBConstraintItem {
    get
  }
  @available(iOS 8.0, OSX 10.11, *)
  public var firstBaseline: RoomBoxUtils.RBConstraintItem {
    get
  }
  @available(iOS 8.0, *)
  public var leftMargin: RoomBoxUtils.RBConstraintItem {
    get
  }
  @available(iOS 8.0, *)
  public var topMargin: RoomBoxUtils.RBConstraintItem {
    get
  }
  @available(iOS 8.0, *)
  public var rightMargin: RoomBoxUtils.RBConstraintItem {
    get
  }
  @available(iOS 8.0, *)
  public var bottomMargin: RoomBoxUtils.RBConstraintItem {
    get
  }
  @available(iOS 8.0, *)
  public var leadingMargin: RoomBoxUtils.RBConstraintItem {
    get
  }
  @available(iOS 8.0, *)
  public var trailingMargin: RoomBoxUtils.RBConstraintItem {
    get
  }
  @available(iOS 8.0, *)
  public var centerXWithinMargins: RoomBoxUtils.RBConstraintItem {
    get
  }
  @available(iOS 8.0, *)
  public var centerYWithinMargins: RoomBoxUtils.RBConstraintItem {
    get
  }
  @available(iOS 8.0, *)
  public var margins: RoomBoxUtils.RBConstraintItem {
    get
  }
  @available(iOS 8.0, *)
  public var directionalMargins: RoomBoxUtils.RBConstraintItem {
    get
  }
  @available(iOS 8.0, *)
  public var centerWithinMargins: RoomBoxUtils.RBConstraintItem {
    get
  }
}
public typealias RBConstraintInsets = UIKit.UIEdgeInsets
public protocol RBConstraintInsetTarget : RoomBoxUtils.RBConstraintConstantTarget {
}
extension Int : RoomBoxUtils.RBConstraintInsetTarget {
}
extension UInt : RoomBoxUtils.RBConstraintInsetTarget {
}
extension Float : RoomBoxUtils.RBConstraintInsetTarget {
}
extension Double : RoomBoxUtils.RBConstraintInsetTarget {
}
extension CGFloat : RoomBoxUtils.RBConstraintInsetTarget {
}
extension UIEdgeInsets : RoomBoxUtils.RBConstraintInsetTarget {
}
@_hasMissingDesignatedInitializers final public class RBConstraintItem {
  @objc deinit
}
public func == (lhs: RoomBoxUtils.RBConstraintItem, rhs: RoomBoxUtils.RBConstraintItem) -> Swift.Bool
@available(iOS 9.0, OSX 10.11, *)
extension UILayoutGuide {
  public var rb_snp: RoomBoxUtils.RBConstraintLayoutGuideDSL {
    get
  }
}
@available(iOS 9.0, *)
public typealias RBConstraintLayoutGuide = UIKit.UILayoutGuide
@available(iOS 9.0, OSX 10.11, *)
public struct RBConstraintLayoutGuideDSL : RoomBoxUtils.RBConstraintAttributesDSL {
  @discardableResult
  public func prepareConstraints(_ closure: (RoomBoxUtils.RBConstraintMaker) -> Swift.Void) -> [RoomBoxUtils.RBConstraint]
  public func makeConstraints(_ closure: (RoomBoxUtils.RBConstraintMaker) -> Swift.Void)
  public func remakeConstraints(_ closure: (RoomBoxUtils.RBConstraintMaker) -> Swift.Void)
  public func updateConstraints(_ closure: (RoomBoxUtils.RBConstraintMaker) -> Swift.Void)
  public func removeConstraints()
  public var target: Swift.AnyObject? {
    get
  }
}
@available(iOS 8.0, *)
public typealias RBConstraintLayoutSupport = UIKit.UILayoutSupport
@available(iOS 8.0, *)
public struct RBConstraintLayoutSupportDSL : RoomBoxUtils.RBConstraintDSL {
  public var target: Swift.AnyObject? {
    get
  }
  public var top: RoomBoxUtils.RBConstraintItem {
    get
  }
  public var bottom: RoomBoxUtils.RBConstraintItem {
    get
  }
  public var height: RoomBoxUtils.RBConstraintItem {
    get
  }
}
@_hasMissingDesignatedInitializers public class RBConstraintMaker {
  public var left: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  public var top: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  public var bottom: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  public var right: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  public var leading: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  public var trailing: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  public var width: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  public var height: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  public var centerX: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  public var centerY: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  @available(*, deprecated, message: "Use lastBaseline instead")
  public var baseline: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  public var lastBaseline: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  @available(iOS 8.0, OSX 10.11, *)
  public var firstBaseline: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  @available(iOS 8.0, *)
  public var leftMargin: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  @available(iOS 8.0, *)
  public var rightMargin: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  @available(iOS 8.0, *)
  public var topMargin: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  @available(iOS 8.0, *)
  public var bottomMargin: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  @available(iOS 8.0, *)
  public var leadingMargin: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  @available(iOS 8.0, *)
  public var trailingMargin: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  @available(iOS 8.0, *)
  public var centerXWithinMargins: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  @available(iOS 8.0, *)
  public var centerYWithinMargins: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  public var edges: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  public var directionalEdges: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  public var size: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  public var center: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  @available(iOS 8.0, *)
  public var margins: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  @available(iOS 8.0, *)
  public var directionalMargins: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  @available(iOS 8.0, *)
  public var centerWithinMargins: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class RBConstraintMakerEditable : RoomBoxUtils.RBConstraintMakerPriortizable {
  @discardableResult
  public func multipliedBy(_ amount: RoomBoxUtils.RBConstraintMultiplierTarget) -> RoomBoxUtils.RBConstraintMakerEditable
  @discardableResult
  public func dividedBy(_ amount: RoomBoxUtils.RBConstraintMultiplierTarget) -> RoomBoxUtils.RBConstraintMakerEditable
  @discardableResult
  public func offset(_ amount: RoomBoxUtils.RBConstraintOffsetTarget) -> RoomBoxUtils.RBConstraintMakerEditable
  @discardableResult
  public func inset(_ amount: RoomBoxUtils.RBConstraintInsetTarget) -> RoomBoxUtils.RBConstraintMakerEditable
  @available(iOS 11.0, tvOS 11.0, *)
  @discardableResult
  public func inset(_ amount: RoomBoxUtils.RBConstraintDirectionalInsetTarget) -> RoomBoxUtils.RBConstraintMakerEditable
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class RBConstraintMakerExtendable : RoomBoxUtils.RBConstraintMakerRelatable {
  public var left: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  public var top: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  public var bottom: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  public var right: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  public var leading: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  public var trailing: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  public var width: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  public var height: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  public var centerX: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  public var centerY: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  @available(*, deprecated, message: "Use lastBaseline instead")
  public var baseline: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  public var lastBaseline: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  @available(iOS 8.0, OSX 10.11, *)
  public var firstBaseline: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  @available(iOS 8.0, *)
  public var leftMargin: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  @available(iOS 8.0, *)
  public var rightMargin: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  @available(iOS 8.0, *)
  public var topMargin: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  @available(iOS 8.0, *)
  public var bottomMargin: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  @available(iOS 8.0, *)
  public var leadingMargin: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  @available(iOS 8.0, *)
  public var trailingMargin: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  @available(iOS 8.0, *)
  public var centerXWithinMargins: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  @available(iOS 8.0, *)
  public var centerYWithinMargins: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  public var edges: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  public var directionalEdges: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  public var size: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  @available(iOS 8.0, *)
  public var margins: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  @available(iOS 8.0, *)
  public var directionalMargins: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  @available(iOS 8.0, *)
  public var centerWithinMargins: RoomBoxUtils.RBConstraintMakerExtendable {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers public class RBConstraintMakerFinalizable {
  @discardableResult
  public func labeled(_ label: Swift.String) -> RoomBoxUtils.RBConstraintMakerFinalizable
  public var constraint: RoomBoxUtils.RBConstraint {
    get
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class RBConstraintMakerPriortizable : RoomBoxUtils.RBConstraintMakerFinalizable {
  @discardableResult
  public func priority(_ amount: RoomBoxUtils.RBConstraintPriority) -> RoomBoxUtils.RBConstraintMakerFinalizable
  @discardableResult
  public func priority(_ amount: RoomBoxUtils.RBConstraintPriorityTarget) -> RoomBoxUtils.RBConstraintMakerFinalizable
  @available(*, deprecated, message: "Use priority(.required) instead.")
  @discardableResult
  public func priorityRequired() -> RoomBoxUtils.RBConstraintMakerFinalizable
  @available(*, deprecated, message: "Use priority(.high) instead.")
  @discardableResult
  public func priorityHigh() -> RoomBoxUtils.RBConstraintMakerFinalizable
  @available(*, deprecated, message: "Use priority(.medium) instead.")
  @discardableResult
  public func priorityMedium() -> RoomBoxUtils.RBConstraintMakerFinalizable
  @available(*, deprecated, message: "Use priority(.low) instead.")
  @discardableResult
  public func priorityLow() -> RoomBoxUtils.RBConstraintMakerFinalizable
  @objc deinit
}
@_hasMissingDesignatedInitializers public class RBConstraintMakerRelatable {
  @discardableResult
  public func equalTo(_ other: RoomBoxUtils.RBConstraintRelatableTarget, _ file: Swift.String = #file, _ line: Swift.UInt = #line) -> RoomBoxUtils.RBConstraintMakerEditable
  @discardableResult
  public func equalToSuperview(_ file: Swift.String = #file, _ line: Swift.UInt = #line) -> RoomBoxUtils.RBConstraintMakerEditable
  @discardableResult
  public func lessThanOrEqualTo(_ other: RoomBoxUtils.RBConstraintRelatableTarget, _ file: Swift.String = #file, _ line: Swift.UInt = #line) -> RoomBoxUtils.RBConstraintMakerEditable
  @discardableResult
  public func lessThanOrEqualToSuperview(_ file: Swift.String = #file, _ line: Swift.UInt = #line) -> RoomBoxUtils.RBConstraintMakerEditable
  @discardableResult
  public func greaterThanOrEqualTo(_ other: RoomBoxUtils.RBConstraintRelatableTarget, _ file: Swift.String = #file, line: Swift.UInt = #line) -> RoomBoxUtils.RBConstraintMakerEditable
  @discardableResult
  public func greaterThanOrEqualToSuperview(_ file: Swift.String = #file, line: Swift.UInt = #line) -> RoomBoxUtils.RBConstraintMakerEditable
  @objc deinit
}
public protocol RBConstraintMultiplierTarget {
  var constraintMultiplierTargetValue: CoreGraphics.CGFloat { get }
}
extension Int : RoomBoxUtils.RBConstraintMultiplierTarget {
  public var constraintMultiplierTargetValue: CoreGraphics.CGFloat {
    get
  }
}
extension UInt : RoomBoxUtils.RBConstraintMultiplierTarget {
  public var constraintMultiplierTargetValue: CoreGraphics.CGFloat {
    get
  }
}
extension Float : RoomBoxUtils.RBConstraintMultiplierTarget {
  public var constraintMultiplierTargetValue: CoreGraphics.CGFloat {
    get
  }
}
extension Double : RoomBoxUtils.RBConstraintMultiplierTarget {
  public var constraintMultiplierTargetValue: CoreGraphics.CGFloat {
    get
  }
}
extension CGFloat : RoomBoxUtils.RBConstraintMultiplierTarget {
  public var constraintMultiplierTargetValue: CoreGraphics.CGFloat {
    get
  }
}
public protocol RBConstraintOffsetTarget : RoomBoxUtils.RBConstraintConstantTarget {
}
extension Int : RoomBoxUtils.RBConstraintOffsetTarget {
}
extension UInt : RoomBoxUtils.RBConstraintOffsetTarget {
}
extension Float : RoomBoxUtils.RBConstraintOffsetTarget {
}
extension Double : RoomBoxUtils.RBConstraintOffsetTarget {
}
extension CGFloat : RoomBoxUtils.RBConstraintOffsetTarget {
}
public struct RBConstraintPriority : Swift.ExpressibleByFloatLiteral, Swift.Equatable, Swift.Strideable {
  public typealias RBFloatLiteralType = Swift.Float
  public let value: Swift.Float
  public init(floatLiteral value: Swift.Float)
  public init(_ value: Swift.Float)
  public static var required: RoomBoxUtils.RBConstraintPriority {
    get
  }
  public static var high: RoomBoxUtils.RBConstraintPriority {
    get
  }
  public static var medium: RoomBoxUtils.RBConstraintPriority {
    get
  }
  public static var low: RoomBoxUtils.RBConstraintPriority {
    get
  }
  public static func == (lhs: RoomBoxUtils.RBConstraintPriority, rhs: RoomBoxUtils.RBConstraintPriority) -> Swift.Bool
  public func advanced(by n: RoomBoxUtils.RBConstraintPriority.RBFloatLiteralType) -> RoomBoxUtils.RBConstraintPriority
  public func distance(to other: RoomBoxUtils.RBConstraintPriority) -> RoomBoxUtils.RBConstraintPriority.RBFloatLiteralType
  public typealias FloatLiteralType = Swift.Float
  public typealias Stride = RoomBoxUtils.RBConstraintPriority.RBFloatLiteralType
}
public protocol RBConstraintPriorityTarget {
  var constraintPriorityTargetValue: Swift.Float { get }
}
extension Int : RoomBoxUtils.RBConstraintPriorityTarget {
  public var constraintPriorityTargetValue: Swift.Float {
    get
  }
}
extension UInt : RoomBoxUtils.RBConstraintPriorityTarget {
  public var constraintPriorityTargetValue: Swift.Float {
    get
  }
}
extension Float : RoomBoxUtils.RBConstraintPriorityTarget {
  public var constraintPriorityTargetValue: Swift.Float {
    get
  }
}
extension Double : RoomBoxUtils.RBConstraintPriorityTarget {
  public var constraintPriorityTargetValue: Swift.Float {
    get
  }
}
extension CGFloat : RoomBoxUtils.RBConstraintPriorityTarget {
  public var constraintPriorityTargetValue: Swift.Float {
    get
  }
}
extension UILayoutPriority : RoomBoxUtils.RBConstraintPriorityTarget {
  public var constraintPriorityTargetValue: Swift.Float {
    get
  }
}
public protocol RBConstraintRelatableTarget {
}
extension Int : RoomBoxUtils.RBConstraintRelatableTarget {
}
extension UInt : RoomBoxUtils.RBConstraintRelatableTarget {
}
extension Float : RoomBoxUtils.RBConstraintRelatableTarget {
}
extension Double : RoomBoxUtils.RBConstraintRelatableTarget {
}
extension CGFloat : RoomBoxUtils.RBConstraintRelatableTarget {
}
extension CGSize : RoomBoxUtils.RBConstraintRelatableTarget {
}
extension CGPoint : RoomBoxUtils.RBConstraintRelatableTarget {
}
extension UIEdgeInsets : RoomBoxUtils.RBConstraintRelatableTarget {
}
@available(iOS 11.0, tvOS 11.0, *)
extension NSDirectionalEdgeInsets : RoomBoxUtils.RBConstraintRelatableTarget {
}
extension RBConstraintItem : RoomBoxUtils.RBConstraintRelatableTarget {
}
extension UIView : RoomBoxUtils.RBConstraintRelatableTarget {
}
@available(iOS 9.0, OSX 10.11, *)
extension UILayoutGuide : RoomBoxUtils.RBConstraintRelatableTarget {
}
extension UIView {
  @available(*, deprecated, message: "Use newer snp.* syntax.")
  public var rb_snp_left: RoomBoxUtils.RBConstraintItem {
    get
  }
  @available(*, deprecated, message: "Use newer snp.* syntax.")
  public var rb_snp_top: RoomBoxUtils.RBConstraintItem {
    get
  }
  @available(*, deprecated, message: "Use newer snp.* syntax.")
  public var rb_snp_right: RoomBoxUtils.RBConstraintItem {
    get
  }
  @available(*, deprecated, message: "Use newer snp.* syntax.")
  public var rb_snp_bottom: RoomBoxUtils.RBConstraintItem {
    get
  }
  @available(*, deprecated, message: "Use newer snp.* syntax.")
  public var rb_snp_leading: RoomBoxUtils.RBConstraintItem {
    get
  }
  @available(*, deprecated, message: "Use newer snp.* syntax.")
  public var rb_snp_trailing: RoomBoxUtils.RBConstraintItem {
    get
  }
  @available(*, deprecated, message: "Use newer snp.* syntax.")
  public var rb_snp_width: RoomBoxUtils.RBConstraintItem {
    get
  }
  @available(*, deprecated, message: "Use newer snp.* syntax.")
  public var rb_snp_height: RoomBoxUtils.RBConstraintItem {
    get
  }
  @available(*, deprecated, message: "Use newer snp.* syntax.")
  public var rb_snp_centerX: RoomBoxUtils.RBConstraintItem {
    get
  }
  @available(*, deprecated, message: "Use newer snp.* syntax.")
  public var rb_snp_centerY: RoomBoxUtils.RBConstraintItem {
    get
  }
  @available(*, deprecated, message: "Use newer snp.* syntax.")
  public var rb_snp_baseline: RoomBoxUtils.RBConstraintItem {
    get
  }
  @available(iOS 8.0, OSX 10.11, *)
  @available(*, deprecated, message: "Use newer snp.* syntax.")
  public var rb_snp_lastBaseline: RoomBoxUtils.RBConstraintItem {
    get
  }
  @available(iOS 8.0, OSX 10.11, *)
  @available(iOS, deprecated, message: "Use newer snp.* syntax.")
  public var rb_snp_firstBaseline: RoomBoxUtils.RBConstraintItem {
    get
  }
  @available(iOS 8.0, *)
  @available(iOS, deprecated, message: "Use newer snp.* syntax.")
  public var rb_snp_leftMargin: RoomBoxUtils.RBConstraintItem {
    get
  }
  @available(iOS 8.0, *)
  @available(iOS, deprecated, message: "Use newer snp.* syntax.")
  public var rb_snp_topMargin: RoomBoxUtils.RBConstraintItem {
    get
  }
  @available(iOS 8.0, *)
  @available(iOS, deprecated, message: "Use newer snp.* syntax.")
  public var rb_snp_rightMargin: RoomBoxUtils.RBConstraintItem {
    get
  }
  @available(iOS 8.0, *)
  @available(iOS, deprecated, message: "Use newer snp.* syntax.")
  public var rb_snp_bottomMargin: RoomBoxUtils.RBConstraintItem {
    get
  }
  @available(iOS 8.0, *)
  @available(iOS, deprecated, message: "Use newer snp.* syntax.")
  public var rb_snp_leadingMargin: RoomBoxUtils.RBConstraintItem {
    get
  }
  @available(iOS 8.0, *)
  @available(iOS, deprecated, message: "Use newer snp.* syntax.")
  public var rb_snp_trailingMargin: RoomBoxUtils.RBConstraintItem {
    get
  }
  @available(iOS 8.0, *)
  @available(iOS, deprecated, message: "Use newer snp.* syntax.")
  public var rb_snp_centerXWithinMargins: RoomBoxUtils.RBConstraintItem {
    get
  }
  @available(iOS 8.0, *)
  @available(iOS, deprecated, message: "Use newer snp.* syntax.")
  public var rb_snp_centerYWithinMargins: RoomBoxUtils.RBConstraintItem {
    get
  }
  @available(*, deprecated, message: "Use newer snp.* syntax.")
  public var rb_snp_edges: RoomBoxUtils.RBConstraintItem {
    get
  }
  @available(*, deprecated, message: "Use newer snp.* syntax.")
  public var rb_snp_size: RoomBoxUtils.RBConstraintItem {
    get
  }
  @available(*, deprecated, message: "Use newer snp.* syntax.")
  public var rb_snp_center: RoomBoxUtils.RBConstraintItem {
    get
  }
  @available(iOS 8.0, *)
  @available(iOS, deprecated, message: "Use newer snp.* syntax.")
  public var rb_snp_margins: RoomBoxUtils.RBConstraintItem {
    get
  }
  @available(iOS 8.0, *)
  @available(iOS, deprecated, message: "Use newer snp.* syntax.")
  public var rb_snp_centerWithinMargins: RoomBoxUtils.RBConstraintItem {
    get
  }
  @available(*, deprecated, message: "Use newer snp.* syntax.")
  public func rb_snp_prepareConstraints(_ closure: (RoomBoxUtils.RBConstraintMaker) -> Swift.Void) -> [RoomBoxUtils.RBConstraint]
  @available(*, deprecated, message: "Use newer snp.* syntax.")
  public func rb_snp_makeConstraints(_ closure: (RoomBoxUtils.RBConstraintMaker) -> Swift.Void)
  @available(*, deprecated, message: "Use newer snp.* syntax.")
  public func rb_snp_remakeConstraints(_ closure: (RoomBoxUtils.RBConstraintMaker) -> Swift.Void)
  @available(*, deprecated, message: "Use newer snp.* syntax.")
  public func rb_snp_updateConstraints(_ closure: (RoomBoxUtils.RBConstraintMaker) -> Swift.Void)
  @available(*, deprecated, message: "Use newer snp.* syntax.")
  public func rb_snp_removeConstraints()
  public var rb_snp: RoomBoxUtils.RBConstraintViewDSL {
    get
  }
}
public typealias RBConstraintView = UIKit.UIView
public struct RBConstraintViewDSL : RoomBoxUtils.RBConstraintAttributesDSL {
  @discardableResult
  public func prepareConstraints(_ closure: (RoomBoxUtils.RBConstraintMaker) -> Swift.Void) -> [RoomBoxUtils.RBConstraint]
  public func makeConstraints(_ closure: (RoomBoxUtils.RBConstraintMaker) -> Swift.Void)
  public func remakeConstraints(_ closure: (RoomBoxUtils.RBConstraintMaker) -> Swift.Void)
  public func updateConstraints(_ closure: (RoomBoxUtils.RBConstraintMaker) -> Swift.Void)
  public func removeConstraints()
  public var contentHuggingHorizontalPriority: Swift.Float {
    get
    nonmutating set
  }
  public var contentHuggingVerticalPriority: Swift.Float {
    get
    nonmutating set
  }
  public var contentCompressionResistanceHorizontalPriority: Swift.Float {
    get
    nonmutating set
  }
  public var contentCompressionResistanceVerticalPriority: Swift.Float {
    get
    nonmutating set
  }
  public var target: Swift.AnyObject? {
    get
  }
}
public protocol RBCryptor {
  mutating func seek(to: Swift.Int) throws
}
public protocol RBCryptors : AnyObject {
  func makeEncryptor() throws -> RoomBoxUtils.RBCryptor & RoomBoxUtils.RBUpdatable
  func makeDecryptor() throws -> RoomBoxUtils.RBCryptor & RoomBoxUtils.RBUpdatable
  static func randomIV(_ blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
}
extension RBCryptors {
  public static func randomIV(_ count: Swift.Int) -> Swift.Array<Swift.UInt8>
}
public struct RBCTR {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: RoomBoxUtils.RBCTR.Error, b: RoomBoxUtils.RBCTR.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public let options: RoomBoxUtils.RBBlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>, counter: Swift.Int = 0)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping RoomBoxUtils.RBCipherOperationOnBlock, encryptionOperation: @escaping RoomBoxUtils.RBCipherOperationOnBlock) throws -> RoomBoxUtils.RBCipherModeWorker
}
open class RBCustomDateFormatTransform : RoomBoxUtils.RBDateFormatterTransform {
  public init(formatString: Swift.String)
  @objc deinit
  override public init(dateFormatter: Foundation.DateFormatter)
}
extension Data : RoomBoxUtils.RBDownloadCompatible {
}
extension RBNetworkWrapper where Base == Foundation.Data {
  public var md5: Swift.String {
    get
  }
  public var sha1: Swift.String {
    get
  }
  public var sha256: Swift.String {
    get
  }
  public var sha512: Swift.String {
    get
  }
}
open class RBDataTransform : RoomBoxUtils.RBTransformType {
  public typealias Object = Foundation.Data
  public typealias JSON = Swift.String
  public init()
  open func transformFromJSON(_ value: Any?) -> Foundation.Data?
  open func transformToJSON(_ value: Foundation.Data?) -> Swift.String?
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class RBDataTypeConverHelper : ObjectiveC.NSObject {
  public class func toInt32Value(_ obj: Any?, def: Swift.Int32) -> Swift.Int32
  public class func toUint8Value(_ obj: Any?, def: Swift.UInt8) -> Swift.UInt8
  public class func toUint16Value(_ obj: Any?, def: Swift.UInt16) -> Swift.UInt16
  public class func toUint32Value(_ obj: Any?, def: Swift.UInt32) -> Swift.UInt32
  public class func toUint64Value(_ obj: Any?, def: Swift.UInt64) -> Swift.UInt64
  public class func toIntValue(_ obj: Any?, def: Swift.Int) -> Swift.Int
  public class func toStringValue(_ obj: Any?, def: Swift.String) -> Swift.String
  public class func toBoolValue(_ obj: Any?, def: Swift.Bool) -> Swift.Bool
  public class func toDictionaryValue(_ obj: Any?) -> Foundation.NSDictionary
  public class func toArrayValue(_ obj: Any?) -> Foundation.NSArray
  @objc deinit
  @objc override dynamic public init()
}
open class RBDateFormatterTransform : RoomBoxUtils.RBTransformType {
  public typealias Object = Foundation.Date
  public typealias JSON = Swift.String
  final public let dateFormatter: Foundation.DateFormatter
  public init(dateFormatter: Foundation.DateFormatter)
  open func transformFromJSON(_ value: Any?) -> Foundation.Date?
  open func transformToJSON(_ value: Foundation.Date?) -> Swift.String?
  @objc deinit
}
open class RBDateTransform : RoomBoxUtils.RBTransformType {
  public typealias Object = Foundation.Date
  public typealias JSON = Swift.Double
  public init()
  open func transformFromJSON(_ value: Any?) -> Foundation.Date?
  open func transformToJSON(_ value: Foundation.Date?) -> Swift.Double?
  @objc deinit
}
extension RBLayoutConstraint {
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
}
extension RBHandyJSON {
  public static func deserialize(from dict: Foundation.NSDictionary?, designatedPath: Swift.String? = nil) -> Self?
  public static func deserialize(from dict: [Swift.String : Any]?, designatedPath: Swift.String? = nil) -> Self?
  public static func deserialize(from json: Swift.String?, designatedPath: Swift.String? = nil) -> Self?
}
extension Array where Element : RoomBoxUtils.RBHandyJSON {
  public static func deserialize(from json: Swift.String?, designatedPath: Swift.String? = nil) -> [Element?]?
  public static func deserialize(from array: Foundation.NSArray?) -> [Element?]?
  public static func deserialize(from array: [Any]?) -> [Element?]?
}
@_hasMissingDesignatedInitializers public class JSONDeserializer<T> where T : RoomBoxUtils.RBHandyJSON {
  public static func deserializeFrom(dict: Foundation.NSDictionary?, designatedPath: Swift.String? = nil) -> T?
  public static func deserializeFrom(dict: [Swift.String : Any]?, designatedPath: Swift.String? = nil) -> T?
  public static func deserializeFrom(json: Swift.String?, designatedPath: Swift.String? = nil) -> T?
  public static func update(object: inout T, from dict: [Swift.String : Any]?, designatedPath: Swift.String? = nil)
  public static func update(object: inout T, from json: Swift.String?, designatedPath: Swift.String? = nil)
  public static func deserializeModelArrayFrom(json: Swift.String?, designatedPath: Swift.String? = nil) -> [T?]?
  public static func deserializeModelArrayFrom(array: Foundation.NSArray?) -> [T?]?
  public static func deserializeModelArrayFrom(array: [Any]?) -> [T?]?
  @objc deinit
}
@available(*, renamed: "RBDigest")
public typealias Hash = RoomBoxUtils.RBDigest
public struct RBDigest {
  public static func md5(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha1(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha224(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha256(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha384(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha512(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha2(_ bytes: Swift.Array<Swift.UInt8>, variant: RoomBoxUtils.RBSHA2.Variant) -> Swift.Array<Swift.UInt8>
  public static func sha3(_ bytes: Swift.Array<Swift.UInt8>, variant: RoomBoxUtils.RBSHA3.Variant) -> Swift.Array<Swift.UInt8>
}
public enum RBDownloadError {
  public enum RBDownloadErrorReason {
    case Cancelled
    case NoFound
    case MD5Failed
    case UnZipFailed
    case NoSpaceFailed
    case NetWorkFailed(failedCode: Swift.Int)
  }
}
public struct RBECB : RoomBoxUtils.RBBlockMode {
  public let options: RoomBoxUtils.RBBlockModeOption
  public let customBlockSize: Swift.Int?
  public init()
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping RoomBoxUtils.RBCipherOperationOnBlock, encryptionOperation: @escaping RoomBoxUtils.RBCipherOperationOnBlock) throws -> RoomBoxUtils.RBCipherModeWorker
}
public class RBEncryptedMessage : RoomBoxUtils.RBMessage {
  final public let data: Foundation.Data
  required public init(data: Foundation.Data)
  public func decrypted(with key: RoomBoxUtils.RBPrivateKey, padding: RoomBoxUtils.Padding) throws -> RoomBoxUtils.RBClearMessage
  @objc deinit
}
open class RBEnumTransform<T> : RoomBoxUtils.RBTransformType where T : Swift.RawRepresentable {
  public typealias Object = T
  public typealias JSON = T.RawValue
  public init()
  open func transformFromJSON(_ value: Any?) -> T?
  open func transformToJSON(_ value: T?) -> T.RawValue?
  @objc deinit
}
public protocol _RBRawEnumProtocol : RoomBoxUtils._RBTransformable {
  static func _transform(from object: Any) -> Self?
  func _plainValue() -> Any?
}
extension RawRepresentable where Self : RoomBoxUtils._RBRawEnumProtocol {
  public static func _transform(from object: Any) -> Self?
  public func _plainValue() -> Any?
}
public protocol HandyJSONCustomTransformable : RoomBoxUtils._RBExtendCustomBasicType {
}
public protocol RBHandyJSON : RoomBoxUtils._RBExtendCustomModelType {
}
public protocol RBHandyJSONEnum : RoomBoxUtils._RBRawEnumProtocol {
}
public protocol _RBExtendCustomBasicType : RoomBoxUtils._RBTransformable {
  static func _transform(from object: Any) -> Self?
  func _plainValue() -> Any?
}
public protocol _RBExtendCustomModelType : RoomBoxUtils._RBTransformable {
  init()
  mutating func willStartMapping()
  mutating func mapping(mapper: RoomBoxUtils.HelpingMapper)
  mutating func didFinishMapping()
}
extension _RBExtendCustomModelType {
  public mutating func willStartMapping()
  public mutating func mapping(mapper: RoomBoxUtils.HelpingMapper)
  public mutating func didFinishMapping()
}
@_hasMissingDesignatedInitializers public class RBFileChecksumHelper {
  public class func validateFile(_ filePath: Swift.String, code: Swift.String, _ completion: @escaping (Swift.Bool, Swift.String) -> ())
  @objc deinit
}
public class RBFilepathImageProvider : RoomBoxUtils.RBAnimationImageProvider {
  public init(filepath: Swift.String)
  public init(filepath: Foundation.URL)
  public func imageForAsset(asset: RoomBoxUtils.RBImageAsset) -> CoreGraphics.CGImage?
  @objc deinit
}
final public class RBFloatValueProvider : RoomBoxUtils.RBAnyValueProvider {
  public typealias CGFloatValueBlock = (CoreGraphics.CGFloat) -> CoreGraphics.CGFloat
  final public var float: CoreGraphics.CGFloat {
    get
    set
  }
  public init(block: @escaping RoomBoxUtils.RBFloatValueProvider.CGFloatValueBlock)
  public init(_ float: CoreGraphics.CGFloat)
  final public var valueType: Any.Type {
    get
  }
  final public func hasUpdate(frame: CoreGraphics.CGFloat) -> Swift.Bool
  final public func value(frame: CoreGraphics.CGFloat) -> Any
  @objc deinit
}
final public class RBGCM : RoomBoxUtils.RBBlockMode {
  public enum Mode {
    case combined
    case detached
    public static func == (a: RoomBoxUtils.RBGCM.Mode, b: RoomBoxUtils.RBGCM.Mode) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  final public let options: RoomBoxUtils.RBBlockModeOption
  public enum Error : Swift.Error {
    case invalidInitializationVector
    case fail
    public static func == (a: RoomBoxUtils.RBGCM.Error, b: RoomBoxUtils.RBGCM.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  final public let customBlockSize: Swift.Int?
  final public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(iv: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, tagLength: Swift.Int = 16, mode: RoomBoxUtils.RBGCM.Mode = .detached)
  convenience public init(iv: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, mode: RoomBoxUtils.RBGCM.Mode = .detached)
  final public func worker(blockSize: Swift.Int, cipherOperation: @escaping RoomBoxUtils.RBCipherOperationOnBlock, encryptionOperation: @escaping RoomBoxUtils.RBCipherOperationOnBlock) throws -> RoomBoxUtils.RBCipherModeWorker
  @objc deinit
}
@_specialize(exported: false, kind: full, where T == Swift.Int)
@_specialize(exported: false, kind: full, where T == Swift.UInt)
@_specialize(exported: false, kind: full, where T == Swift.UInt8)
@_specialize(exported: false, kind: full, where T == Swift.UInt16)
@_specialize(exported: false, kind: full, where T == Swift.UInt32)
@_specialize(exported: false, kind: full, where T == Swift.UInt64)
@inlinable internal func arrayOfBytes<T>(value: T, length totalBytes: Swift.Int = MemoryLayout<T>.size) -> Swift.Array<Swift.UInt8> where T : Swift.FixedWidthInteger {
  let valuePointer = UnsafeMutablePointer<T>.allocate(capacity: 1)
  valuePointer.pointee = value

  let bytesPointer = UnsafeMutablePointer<UInt8>(OpaquePointer(valuePointer))
  var bytes = Array<UInt8>(repeating: 0, count: totalBytes)
  for j in 0..<min(MemoryLayout<T>.size, totalBytes) {
    bytes[totalBytes - 1 - j] = (bytesPointer + j).pointee
  }

  valuePointer.deinitialize(count: 1)
  valuePointer.deallocate()

  return bytes
}
final public class RBGradientValueProvider : RoomBoxUtils.RBAnyValueProvider {
  public typealias ColorsValueBlock = (CoreGraphics.CGFloat) -> [RoomBoxUtils.RBColor]
  public typealias ColorLocationsBlock = (CoreGraphics.CGFloat) -> [Swift.Double]
  final public var colors: [RoomBoxUtils.RBColor] {
    get
    set
  }
  final public var locations: [Swift.Double] {
    get
    set
  }
  public init(block: @escaping RoomBoxUtils.RBGradientValueProvider.ColorsValueBlock, locations: RoomBoxUtils.RBGradientValueProvider.ColorLocationsBlock? = nil)
  public init(_ colors: [RoomBoxUtils.RBColor], locations: [Swift.Double] = [])
  final public var valueType: Any.Type {
    get
  }
  final public func hasUpdate(frame: CoreGraphics.CGFloat) -> Swift.Bool
  final public func value(frame: CoreGraphics.CGFloat) -> Any
  @objc deinit
}
public typealias RBCustomMappingKeyValueTuple = (Swift.Int, RoomBoxUtils.MappingPropertyHandler)
public class MappingPropertyHandler {
  public init(rawPaths: [Swift.String]?, assignmentClosure: ((Any?) -> (Any?))?, takeValueClosure: ((Any?) -> (Any?))?)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class HelpingMapper {
  public func specify<T>(property: inout T, name: Swift.String)
  public func specify<T>(property: inout T, converter: @escaping (Swift.String) -> T)
  public func specify<T>(property: inout T, name: Swift.String?, converter: ((Swift.String) -> T)?)
  public func exclude<T>(property: inout T)
  @objc deinit
}
infix operator <-- : LogicalConjunctionPrecedence
public func <-- <T>(property: inout T, name: Swift.String) -> RoomBoxUtils.RBCustomMappingKeyValueTuple
public func <-- <T>(property: inout T, names: [Swift.String]) -> RoomBoxUtils.RBCustomMappingKeyValueTuple
public func <-- <Transform>(property: inout Transform.Object, transformer: Transform) -> RoomBoxUtils.RBCustomMappingKeyValueTuple where Transform : RoomBoxUtils.RBTransformType
public func <-- <Transform>(property: inout Transform.Object, transformer: (Swift.String?, Transform?)) -> RoomBoxUtils.RBCustomMappingKeyValueTuple where Transform : RoomBoxUtils.RBTransformType
public func <-- <Transform>(property: inout Transform.Object, transformer: ([Swift.String], Transform?)) -> RoomBoxUtils.RBCustomMappingKeyValueTuple where Transform : RoomBoxUtils.RBTransformType
public func <-- <Transform>(property: inout Transform.Object?, transformer: Transform) -> RoomBoxUtils.RBCustomMappingKeyValueTuple where Transform : RoomBoxUtils.RBTransformType
public func <-- <Transform>(property: inout Transform.Object?, transformer: (Swift.String?, Transform?)) -> RoomBoxUtils.RBCustomMappingKeyValueTuple where Transform : RoomBoxUtils.RBTransformType
public func <-- <Transform>(property: inout Transform.Object?, transformer: ([Swift.String], Transform?)) -> RoomBoxUtils.RBCustomMappingKeyValueTuple where Transform : RoomBoxUtils.RBTransformType
infix operator <<< : AssignmentPrecedence
public func <<< (mapper: RoomBoxUtils.HelpingMapper, mapping: RoomBoxUtils.RBCustomMappingKeyValueTuple)
public func <<< (mapper: RoomBoxUtils.HelpingMapper, mappings: [RoomBoxUtils.RBCustomMappingKeyValueTuple])
infix operator >>> : AssignmentPrecedence
public func >>> <T>(mapper: RoomBoxUtils.HelpingMapper, property: inout T)
open class RBHexColorTransform : RoomBoxUtils.RBTransformType {
  public typealias Object = UIKit.UIColor
  public typealias JSON = Swift.String
  public init(prefixToJSON: Swift.Bool = false, alphaToJSON: Swift.Bool = false)
  open func transformFromJSON(_ value: Any?) -> RoomBoxUtils.RBHexColorTransform.Object?
  open func transformToJSON(_ value: RoomBoxUtils.RBHexColorTransform.Object?) -> RoomBoxUtils.RBHexColorTransform.JSON?
  @objc deinit
}
public struct RBHKDF {
  public enum Error : Swift.Error {
    case invalidInput
    case derivedKeyTooLong
    public static func == (a: RoomBoxUtils.RBHKDF.Error, b: RoomBoxUtils.RBHKDF.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>? = nil, info: Swift.Array<Swift.UInt8>? = nil, keyLength: Swift.Int? = nil, variant: RoomBoxUtils.RBHMAC.Variant = .sha256) throws
  public func calculate() throws -> Swift.Array<Swift.UInt8>
}
extension RBHMAC {
  convenience public init(key: Swift.String, variant: RoomBoxUtils.RBHMAC.Variant = .md5) throws
}
final public class RBHMAC : RoomBoxUtils.RBAuthenticator {
  public enum Error : Swift.Error {
    case authenticateError
    case invalidInput
    public static func == (a: RoomBoxUtils.RBHMAC.Error, b: RoomBoxUtils.RBHMAC.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public enum Variant {
    case sha1, sha256, sha384, sha512, md5
    public static func == (a: RoomBoxUtils.RBHMAC.Variant, b: RoomBoxUtils.RBHMAC.Variant) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public init(key: Swift.Array<Swift.UInt8>, variant: RoomBoxUtils.RBHMAC.Variant = .md5)
  final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
open class RBHttpBaseTarget : RoomBoxUtils.RBTarget, RoomBoxUtils.RBPlugin {
  public init()
  open var baseURLString: Swift.String {
    get
  }
  open var configuration: Foundation.URLSessionConfiguration {
    get
  }
  open var status: (codeKey: Swift.String, successCode: [Swift.Int], messageKey: Swift.String?, dataKeyPath: Swift.String?)? {
    get
  }
  open var plugins: [RoomBoxUtils.RBPlugin]? {
    get
  }
  open func willSend(request: RoomBoxUtils.RBRequest)
  open func didReceive(response: RoomBoxUtils.RBResponse)
  open func logoutToLoginVC()
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class RBImageAsset : RoomBoxUtils.RBAsset {
  final public let name: Swift.String
  final public let directory: Swift.String
  final public let width: Swift.Double
  final public let height: Swift.Double
  override final public func encode(to encoder: Swift.Encoder) throws
  @objc deinit
}
open class RBISO8601DateTransform : RoomBoxUtils.RBDateFormatterTransform {
  public init()
  @objc deinit
  override public init(dateFormatter: Foundation.DateFormatter)
}
public protocol RBKey : AnyObject {
  var reference: Security.SecKey { get }
  var originalData: Foundation.Data? { get }
  init(data: Foundation.Data) throws
  init(reference: Security.SecKey) throws
  init(base64Encoded base64String: Swift.String) throws
  init(pemEncoded pemString: Swift.String) throws
  init(pemNamed pemName: Swift.String, in bundle: Foundation.Bundle) throws
  init(derNamed derName: Swift.String, in bundle: Foundation.Bundle) throws
  func pemString() throws -> Swift.String
  func data() throws -> Foundation.Data
  func base64String() throws -> Swift.String
}
extension RBKey {
  public func base64String() throws -> Swift.String
  public func data() throws -> Foundation.Data
  public init(base64Encoded base64String: Swift.String) throws
  public init(pemEncoded pemString: Swift.String) throws
  public init(pemNamed pemName: Swift.String, in bundle: Foundation.Bundle = Bundle.main) throws
  public init(derNamed derName: Swift.String, in bundle: Foundation.Bundle = Bundle.main) throws
}
extension CALayer {
  public func logLayerTree(withIndent: Swift.Int = 0)
}
public enum LayerType : Swift.Int, Swift.Codable {
  case precomp
  case solid
  case image
  case null
  case shape
  case text
  public init(from decoder: Swift.Decoder) throws
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public enum MatteType : Swift.Int, Swift.Codable {
  case none
  case add
  case invert
  case unknown
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public enum BlendMode : Swift.Int, Swift.Codable {
  case normal
  case multiply
  case screen
  case overlay
  case darken
  case lighten
  case colorDodge
  case colorBurn
  case hardLight
  case softLight
  case difference
  case exclusion
  case hue
  case saturation
  case color
  case luminosity
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
@objc @_inheritsConvenienceInitializers public class RBLayoutConstraint : UIKit.NSLayoutConstraint {
  public var label: Swift.String? {
    get
    set
  }
  @objc override dynamic public init()
  @objc deinit
}
public protocol RBLayoutConstraintItem : AnyObject {
}
@available(iOS 9.0, OSX 10.11, *)
extension UILayoutGuide : RoomBoxUtils.RBLayoutConstraintItem {
}
extension UIView : RoomBoxUtils.RBLayoutConstraintItem {
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers open class RBLocalPhoto : ObjectiveC.NSObject, RoomBoxUtils.RBPhotoProtocol {
  @objc public var placeholderImage: UIKit.UIImage?
  @objc open var underlyingImage: UIKit.UIImage!
  open var photoURL: Swift.String!
  @objc open var contentMode: UIKit.UIView.ContentMode
  open var shouldCachePhotoURLImage: Swift.Bool
  @objc open var caption: Swift.String?
  @objc open var index: Swift.Int
  @objc open func checkCache()
  @objc open func loadUnderlyingImageAndNotify()
  open func loadUnderlyingImageComplete()
  open class func photoWithImageURL(_ url: Swift.String) -> RoomBoxUtils.RBLocalPhoto
  open class func photoWithImageURL(_ url: Swift.String, holder: UIKit.UIImage?) -> RoomBoxUtils.RBLocalPhoto
  @objc deinit
}
@objc @_inheritsConvenienceInitializers open class RBLottieView : UIKit.UIView {
  @objc override dynamic open func didMoveToWindow()
  @objc override dynamic open var contentMode: UIKit.UIView.ContentMode {
    @objc get
    @objc set
  }
  @objc override dynamic open func layoutSubviews()
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public class RBLRUAnimationCache : RoomBoxUtils.RBAnimationCacheProvider {
  public init()
  public func clearCache()
  public static let sharedCache: RoomBoxUtils.RBLRUAnimationCache
  public var cacheSize: Swift.Int
  public func animation(forKey: Swift.String) -> RoomBoxUtils.RBAnimation?
  public func setAnimation(_ animation: RoomBoxUtils.RBAnimation, forKey: Swift.String)
  @objc deinit
}
infix operator +| : DefaultPrecedence
infix operator +- : DefaultPrecedence
final public class RBMD5 {
  public init()
  final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension RBMD5 : RoomBoxUtils.RBUpdatable {
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
}
public protocol _RBMeasurable {
}
public protocol RBMessage {
  var data: Foundation.Data { get }
  var base64String: Swift.String { get }
  init(data: Foundation.Data)
  init(base64Encoded base64String: Swift.String) throws
}
extension RBMessage {
  public var base64String: Swift.String {
    get
  }
  public init(base64Encoded base64String: Swift.String) throws
}
public struct RBNamespace<Base> {
  public let base: Base
  public init(_ base: Base)
}
public protocol RBNamespaceProtocol {
  associatedtype RBCompatibleType
  static var RB: RoomBoxUtils.RBNamespace<Self.RBCompatibleType>.Type { get set }
  var RB: RoomBoxUtils.RBNamespace<Self.RBCompatibleType> { get set }
}
extension RBNamespaceProtocol {
  public static var RB: RoomBoxUtils.RBNamespace<Self>.Type {
    get
    set
  }
  public var RB: RoomBoxUtils.RBNamespace<Self> {
    get
    set
  }
}
extension NSObject : RoomBoxUtils.RBNamespaceProtocol {
  public typealias RBCompatibleType = ObjectiveC.NSObject
}
public typealias Session = RoomBoxUtils.RB_Session
public typealias URLRequestConvertible = RoomBoxUtils.RB_URLRequestConvertible
public typealias HTTPHeader = RoomBoxUtils.RB_HTTPHeader
public typealias HTTPHeaders = RoomBoxUtils.RB_HTTPHeaders
public typealias Request = RoomBoxUtils.RB_Request
public typealias DownloadRequest = RoomBoxUtils.RB_DownloadRequest
public typealias UploadRequest = RoomBoxUtils.RB_UploadRequest
public typealias DataRequest = RoomBoxUtils.RB_DataRequest
public typealias DataResponse = RoomBoxUtils.RB_DataResponse
public typealias SessionDelegate = RoomBoxUtils.RB_SessionDelegate
public typealias Destination = RoomBoxUtils.DownloadRequest.Destination
public typealias AFError = RoomBoxUtils.RB_AFError
public typealias RequestInterceptor = RoomBoxUtils.RB_RequestInterceptor
public typealias HTTPMethod = RoomBoxUtils.RB_HTTPMethod
public typealias Parameters = RoomBoxUtils.RB_Parameters
public typealias ParameterEncoding = RoomBoxUtils.RB_ParameterEncoding
public typealias JSONEncoding = RoomBoxUtils.RB_JSONEncoding
public typealias URLEncoding = RoomBoxUtils.RB_URLEncoding
public typealias Options = RoomBoxUtils.RB_DownloadRequest.Options
public typealias MultipartFormData = RoomBoxUtils.RB_MultipartFormData
public typealias ServerTrustManager = RoomBoxUtils.RB_ServerTrustManager
public typealias ServerTrustEvaluating = RoomBoxUtils.RB_ServerTrustEvaluating
public typealias DefaultTrustEvaluator = RoomBoxUtils.RB_DefaultTrustEvaluator
public typealias RevocationTrustEvaluator = RoomBoxUtils.RB_RevocationTrustEvaluator
public typealias PinnedCertificatesTrustEvaluator = RoomBoxUtils.RB_PinnedCertificatesTrustEvaluator
public typealias PublicKeysTrustEvaluator = RoomBoxUtils.RB_PublicKeysTrustEvaluator
public typealias CompositeTrustEvaluator = RoomBoxUtils.RB_CompositeTrustEvaluator
public typealias DisabledEvaluator = RoomBoxUtils.RB_DisabledEvaluator
public typealias NetworkReachabilityManager = RoomBoxUtils.RB_NetworkReachabilityManager
public typealias ReachabilityListener = RoomBoxUtils.RB_NetworkReachabilityManager.Listener
public let RBHostKey: Swift.String
public class RBNetwork {
  public typealias ProgressClosure = (RoomBoxUtils.RBProgress) -> Swift.Void
  public typealias CompletionClosure = (RoomBoxUtils.RBResponse) -> Swift.Void
  public typealias DownLoadCompletionClosure = (RoomBoxUtils.RBDownloadResponse) -> Swift.Void
  final public let session: RoomBoxUtils.Session
  public var target: RoomBoxUtils.RBTarget
  public var reachabilityManager: RoomBoxUtils.NetworkReachabilityManager? {
    get
    set
  }
  public init(_ target: RoomBoxUtils.RBTarget)
  @objc deinit
}
extension RBNetwork {
  public func request(_ request: RoomBoxUtils.RBRequest, completionClosure: @escaping RoomBoxUtils.RBNetwork.CompletionClosure)
}
extension RBNetwork {
  public func download(_ request: RoomBoxUtils.RBDownloadRequest, progressClosure: RoomBoxUtils.RBNetwork.ProgressClosure? = nil, completionClosure: @escaping RoomBoxUtils.RBNetwork.DownLoadCompletionClosure)
}
extension RBNetwork {
  public func upload(_ request: RoomBoxUtils.RBUploadRequest, progressClosure: RoomBoxUtils.RBNetwork.ProgressClosure? = nil, completionClosure: @escaping RoomBoxUtils.RBNetwork.CompletionClosure)
}
public struct RBNetworkWrapper<Base> {
}
public protocol RBDownloadCompatible {
}
extension RBDownloadCompatible {
  public var tr: RoomBoxUtils.RBNetworkWrapper<Self> {
    get
  }
}
open class RBNSDecimalNumberTransform : RoomBoxUtils.RBTransformType {
  public typealias Object = Foundation.NSDecimalNumber
  public typealias JSON = Swift.String
  public init()
  open func transformFromJSON(_ value: Any?) -> Foundation.NSDecimalNumber?
  open func transformToJSON(_ value: Foundation.NSDecimalNumber?) -> Swift.String?
  @objc deinit
}
final public class RBObjectAssociation<T> {
  public init(policy: ObjectiveC.objc_AssociationPolicy = .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
  final public subscript(index: Any) -> T? {
    get
    set
  }
  @objc deinit
}
final public class RBOCB : RoomBoxUtils.RBBlockMode {
  public enum Mode {
    case combined
    case detached
    public static func == (a: RoomBoxUtils.RBOCB.Mode, b: RoomBoxUtils.RBOCB.Mode) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  final public let options: RoomBoxUtils.RBBlockModeOption
  public enum Error : Swift.Error {
    case invalidNonce
    case fail
    public static func == (a: RoomBoxUtils.RBOCB.Error, b: RoomBoxUtils.RBOCB.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  final public let customBlockSize: Swift.Int?
  final public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(nonce N: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, tagLength: Swift.Int = 16, mode: RoomBoxUtils.RBOCB.Mode = .detached)
  @inlinable convenience public init(nonce N: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, mode: RoomBoxUtils.RBOCB.Mode = .detached) {
    self.init(nonce: N, additionalAuthenticatedData: additionalAuthenticatedData, tagLength: authenticationTag.count, mode: mode)
    self.authenticationTag = authenticationTag
  }
  final public func worker(blockSize: Swift.Int, cipherOperation: @escaping RoomBoxUtils.RBCipherOperationOnBlock, encryptionOperation: @escaping RoomBoxUtils.RBCipherOperationOnBlock) throws -> RoomBoxUtils.RBCipherModeWorker
  @objc deinit
}
public struct RBOFB : RoomBoxUtils.RBBlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: RoomBoxUtils.RBOFB.Error, b: RoomBoxUtils.RBOFB.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public let options: RoomBoxUtils.RBBlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping RoomBoxUtils.RBCipherOperationOnBlock, encryptionOperation: @escaping RoomBoxUtils.RBCipherOperationOnBlock) throws -> RoomBoxUtils.RBCipherModeWorker
}
public protocol RBPaddingProtocol {
  func add(to: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
  func remove(from: Swift.Array<Swift.UInt8>, blockSize: Swift.Int?) -> Swift.Array<Swift.UInt8>
}
public enum RBPadding : RoomBoxUtils.RBPaddingProtocol {
  case noPadding, zeroPadding, pkcs7, pkcs5, iso78164, iso10126
  public func add(to: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
  public func remove(from: Swift.Array<Swift.UInt8>, blockSize: Swift.Int?) -> Swift.Array<Swift.UInt8>
  public static func == (a: RoomBoxUtils.RBPadding, b: RoomBoxUtils.RBPadding) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public struct RBParameterValueJSONEncoding : RoomBoxUtils.ParameterEncoding {
  public static var `default`: RoomBoxUtils.RBParameterValueJSONEncoding {
    get
  }
  public static var prettyPrinted: RoomBoxUtils.RBParameterValueJSONEncoding {
    get
  }
  public let options: Foundation.JSONSerialization.WritingOptions
  public init(options: Foundation.JSONSerialization.WritingOptions = [])
  public func encode(_ urlRequest: RoomBoxUtils.URLRequestConvertible, with parameters: RoomBoxUtils.Parameters?) throws -> Foundation.URLRequest
}
public struct RBParameterValuePropertyListEncoding : RoomBoxUtils.ParameterEncoding {
  public static var `default`: RoomBoxUtils.RBParameterValuePropertyListEncoding {
    get
  }
  public static var xml: RoomBoxUtils.RBParameterValuePropertyListEncoding {
    get
  }
  public static var binary: RoomBoxUtils.RBParameterValuePropertyListEncoding {
    get
  }
  public let format: Foundation.PropertyListSerialization.PropertyListFormat
  public let options: Foundation.PropertyListSerialization.WriteOptions
  public init(format: Foundation.PropertyListSerialization.PropertyListFormat = .xml, options: Foundation.PropertyListSerialization.WriteOptions = 0)
  public func encode(_ urlRequest: RoomBoxUtils.URLRequestConvertible, with parameters: RoomBoxUtils.Parameters?) throws -> Foundation.URLRequest
}
public class RBPath {
  public class func isDir(path: Swift.String) -> Swift.Bool
  final public let path_string: Swift.String
  public init(_ p: Swift.String)
  public var asString: Swift.String {
    get
  }
  public func toString() -> Swift.String
  public var exists: Swift.Bool {
    get
  }
  public var isDir: Swift.Bool {
    get
  }
  public var basename: Swift.String {
    get
  }
  public var parent: RoomBoxUtils.RBPath {
    get
  }
  public var attributes: Foundation.NSDictionary? {
    get
  }
  public var ext: Foundation.NSString {
    get
  }
  public func remove()
  public func copyTo(toPath: RoomBoxUtils.RBPath)
  public func moveTo(toPath: RoomBoxUtils.RBPath)
  @objc deinit
}
extension RBPath : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension RBPath {
  public class var homeDir: RoomBoxUtils.RBPath {
    get
  }
  public class var libraryDir: RoomBoxUtils.RBPath {
    get
  }
  public class var temporaryDir: RoomBoxUtils.RBPath {
    get
  }
  public class var documentsDir: RoomBoxUtils.RBPath {
    get
  }
  public class var cacheDir: RoomBoxUtils.RBPath {
    get
  }
  public func mkdir()
}
extension RBPath : Swift.Sequence {
  public func content(path_string: Swift.String) -> RoomBoxUtils.RBPath
  public subscript(filename: Swift.String) -> RoomBoxUtils.RBPath {
    get
  }
  public var children: Swift.Array<RoomBoxUtils.RBPath>? {
    get
  }
  public var childrenPaths: Swift.Array<Swift.String>? {
    get
  }
  public var contents: Swift.Array<RoomBoxUtils.RBPath>? {
    get
  }
  public func makeIterator() -> Swift.AnyIterator<RoomBoxUtils.RBPath>
  public typealias Element = RoomBoxUtils.RBPath
  public typealias Iterator = Swift.AnyIterator<RoomBoxUtils.RBPath>
}
extension RBPKCS5 {
  public struct PBKDF1 {
    public enum Error : Swift.Error {
      case invalidInput
      case derivedKeyTooLong
      public static func == (a: RoomBoxUtils.RBPKCS5.PBKDF1.Error, b: RoomBoxUtils.RBPKCS5.PBKDF1.Error) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
    }
    public enum Variant {
      case md5, sha1
      @usableFromInline
      internal var size: Swift.Int {
        get
      }
      @usableFromInline
      internal func calculateHash(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
      public static func == (a: RoomBoxUtils.RBPKCS5.PBKDF1.Variant, b: RoomBoxUtils.RBPKCS5.PBKDF1.Variant) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
    }
    @usableFromInline
    internal let iterations: Swift.Int
    @usableFromInline
    internal let variant: RoomBoxUtils.RBPKCS5.PBKDF1.Variant
    @usableFromInline
    internal let keyLength: Swift.Int
    @usableFromInline
    internal let t1: Swift.Array<Swift.UInt8>
    public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, variant: RoomBoxUtils.RBPKCS5.PBKDF1.Variant = .sha1, iterations: Swift.Int = 4096, keyLength: Swift.Int? = nil) throws
    @inlinable public func calculate() -> Swift.Array<Swift.UInt8> {
      var t = self.t1
      for _ in 2...self.iterations {
        t = self.variant.calculateHash(t)
      }
      return Array(t[0..<self.keyLength])
    }
  }
}
extension RBPKCS5 {
  public struct PBKDF2 {
    public enum Error : Swift.Error {
      case invalidInput
      case derivedKeyTooLong
      public static func == (a: RoomBoxUtils.RBPKCS5.PBKDF2.Error, b: RoomBoxUtils.RBPKCS5.PBKDF2.Error) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
    }
    public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, iterations: Swift.Int = 4096, keyLength: Swift.Int? = nil, variant: RoomBoxUtils.RBHMAC.Variant = .sha256) throws
    public func calculate() throws -> Swift.Array<Swift.UInt8>
  }
}
public struct RBPCBC : RoomBoxUtils.RBBlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: RoomBoxUtils.RBPCBC.Error, b: RoomBoxUtils.RBPCBC.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public let options: RoomBoxUtils.RBBlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping RoomBoxUtils.RBCipherOperationOnBlock, encryptionOperation: @escaping RoomBoxUtils.RBCipherOperationOnBlock) throws -> RoomBoxUtils.RBCipherModeWorker
}
@objc public protocol RBPhotoProtocol : ObjectiveC.NSObjectProtocol {
  @objc var index: Swift.Int { get set }
  @objc var underlyingImage: UIKit.UIImage! { get }
  @objc var placeholderImage: UIKit.UIImage? { get }
  @objc var caption: Swift.String? { get }
  @objc var contentMode: UIKit.UIView.ContentMode { get set }
  @objc func loadUnderlyingImageAndNotify()
  @objc func checkCache()
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers open class RBPhoto : ObjectiveC.NSObject, RoomBoxUtils.RBPhotoProtocol {
  @objc open var index: Swift.Int
  @objc open var underlyingImage: UIKit.UIImage!
  @objc open var placeholderImage: UIKit.UIImage?
  @objc open var caption: Swift.String?
  @objc open var contentMode: UIKit.UIView.ContentMode
  open var shouldCachePhotoURLImage: Swift.Bool
  open var photoURL: Swift.String!
  @objc open func checkCache()
  @objc open func loadUnderlyingImageAndNotify()
  open func loadUnderlyingImageComplete()
  @objc deinit
}
extension RBPhoto {
  public static func photoWithImage(_ image: UIKit.UIImage) -> RoomBoxUtils.RBPhoto
  public static func photoWithImageURL(_ url: Swift.String) -> RoomBoxUtils.RBPhoto
  public static func photoWithImageURL(_ url: Swift.String, holder: UIKit.UIImage?) -> RoomBoxUtils.RBPhoto
}
public let RBPHOTO_LOADING_DID_END_NOTIFICATION: Swift.String
@objc @_inheritsConvenienceInitializers open class RBPhotoBrowser : UIKit.UIViewController {
  open var currentPageIndex: Swift.Int
  open var initPageIndex: Swift.Int
  open var activityItemProvider: UIKit.UIActivityItemProvider?
  open var photos: [RoomBoxUtils.RBPhotoProtocol]
  weak open var delegate: RoomBoxUtils.RBPhotoBrowserDelegate?
  open var cancelTitle: Swift.String
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String!, bundle nibBundleOrNil: Foundation.Bundle!)
  convenience public init(photos: [RoomBoxUtils.RBPhotoProtocol])
  @available(*, deprecated)
  convenience public init(originImage: UIKit.UIImage, photos: [RoomBoxUtils.RBPhotoProtocol], animatedFromView: UIKit.UIView)
  convenience public init(photos: [RoomBoxUtils.RBPhotoProtocol], initialPageIndex: Swift.Int)
  @objc deinit
  @objc override dynamic open func viewDidLoad()
  @objc override dynamic open func viewWillAppear(_ animated: Swift.Bool)
  @objc override dynamic open func viewWillLayoutSubviews()
  @objc override dynamic open func viewDidAppear(_ animated: Swift.Bool)
  @objc override dynamic open var prefersStatusBarHidden: Swift.Bool {
    @objc get
  }
  @objc open func handleRBPhotoLoadingDidEndNotification(_ notification: Foundation.Notification)
  open func loadAdjacentPhotosIfNecessary(_ photo: RoomBoxUtils.RBPhotoProtocol)
  open func reloadData()
  open func performLayout()
  open func prepareForClosePhotoBrowser()
  open func dismissPhotoBrowser(animated: Swift.Bool, completion: (() -> Swift.Void)? = nil)
  open func determineAndClose()
  open func popupShare(includeCaption: Swift.Bool = true)
}
extension RBPhotoBrowser {
  public func updateCloseButton(_ image: UIKit.UIImage, size: CoreGraphics.CGSize? = nil)
  public func updateDeleteButton(_ image: UIKit.UIImage, size: CoreGraphics.CGSize? = nil)
}
extension RBPhotoBrowser {
  public func initializePageIndex(_ index: Swift.Int)
  public func jumpToPageAtIndex(_ index: Swift.Int)
  public func photoAtIndex(_ index: Swift.Int) -> RoomBoxUtils.RBPhotoProtocol
  @objc dynamic public func gotoPreviousPage()
  @objc dynamic public func gotoNextPage()
  public func cancelControlHiding()
  public func hideControlsAfterDelay()
  public func hideControls()
  @objc dynamic public func hideControls(_ timer: Foundation.Timer)
  public func toggleControls()
  public func areControlsHidden() -> Swift.Bool
  public func getCurrentPageIndex() -> Swift.Int
  public func addPhotos(photos: [RoomBoxUtils.RBPhotoProtocol])
  public func insertPhotos(photos: [RoomBoxUtils.RBPhotoProtocol], at index: Swift.Int)
}
extension RBPhotoBrowser : UIKit.UIScrollViewDelegate {
  @objc dynamic public func scrollViewDidScroll(_ scrollView: UIKit.UIScrollView)
  @objc dynamic public func scrollViewDidEndDecelerating(_ scrollView: UIKit.UIScrollView)
  @objc dynamic public func scrollViewDidEndScrollingAnimation(_ scrollView: UIKit.UIScrollView)
}
@objc public protocol RBPhotoBrowserDelegate {
  @objc optional func didShowPhotoAtIndex(_ browser: RoomBoxUtils.RBPhotoBrowser, index: Swift.Int)
  @objc optional func willDismissAtPageIndex(_ index: Swift.Int)
  @objc optional func willShowActionSheet(_ photoIndex: Swift.Int)
  @objc optional func didDismissAtPageIndex(_ index: Swift.Int)
  @objc optional func didDismissActionSheetWithButtonIndex(_ buttonIndex: Swift.Int, photoIndex: Swift.Int)
  @objc optional func didScrollToIndex(_ browser: RoomBoxUtils.RBPhotoBrowser, index: Swift.Int)
  @objc optional func removePhoto(_ browser: RoomBoxUtils.RBPhotoBrowser, index: Swift.Int, reload: @escaping (() -> Swift.Void))
  @objc optional func viewForPhoto(_ browser: RoomBoxUtils.RBPhotoBrowser, index: Swift.Int) -> UIKit.UIView?
  @objc optional func controlsVisibilityToggled(_ browser: RoomBoxUtils.RBPhotoBrowser, hidden: Swift.Bool)
  @objc optional func captionViewForPhotoAtIndex(index: Swift.Int) -> RoomBoxUtils.RBCaptionView?
}
public struct RBPhotoBrowserOptions {
  public static var displayStatusbar: Swift.Bool
  public static var displayCloseButton: Swift.Bool
  public static var displayDeleteButton: Swift.Bool
  public static var displayAction: Swift.Bool
  public static var shareExtraCaption: Swift.String?
  public static var actionButtonTitles: [Swift.String]?
  public static var displayCounterLabel: Swift.Bool
  public static var displayBackAndForwardButton: Swift.Bool
  public static var displayHorizontalScrollIndicator: Swift.Bool
  public static var displayVerticalScrollIndicator: Swift.Bool
  public static var displayPagingHorizontalScrollIndicator: Swift.Bool
  public static var bounceAnimation: Swift.Bool
  public static var enableZoomBlackArea: Swift.Bool
  public static var enableSingleTapDismiss: Swift.Bool
  public static var backgroundColor: UIKit.UIColor
  public static var indicatorColor: UIKit.UIColor
  public static var indicatorStyle: UIKit.UIActivityIndicatorView.Style
  public static var swapCloseAndDeleteButtons: Swift.Bool
  public static var disableVerticalSwipe: Swift.Bool
  public static var longPhotoWidthMatchScreen: Swift.Bool
  public static var sessionConfiguration: Foundation.URLSessionConfiguration
}
public struct RBButtonOptions {
  public static var closeButtonPadding: CoreGraphics.CGPoint
  public static var deleteButtonPadding: CoreGraphics.CGPoint
}
public struct RBCaptionOptions {
  public enum CaptionLocation {
    case basic
    case bottom
    public static func == (a: RoomBoxUtils.RBCaptionOptions.CaptionLocation, b: RoomBoxUtils.RBCaptionOptions.CaptionLocation) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public static var textColor: UIKit.UIColor
  public static var textAlignment: UIKit.NSTextAlignment
  public static var numberOfLine: Swift.Int
  public static var lineBreakMode: UIKit.NSLineBreakMode
  public static var font: UIKit.UIFont
  public static var backgroundColor: UIKit.UIColor
  public static var captionLocation: RoomBoxUtils.RBCaptionOptions.CaptionLocation
}
public struct RBToolbarOptions {
  public static var textColor: UIKit.UIColor
  public static var font: UIKit.UIFont
  public static var textShadowColor: UIKit.UIColor
}
public enum RBPKCS5 {
}
public enum PKCS7 {
}
public protocol RBPlugin {
  func willSend(request: RoomBoxUtils.RBRequest)
  func didReceive(response: RoomBoxUtils.RBResponse)
}
extension RBPlugin {
  public func willSend(request: RoomBoxUtils.RBRequest)
  public func didReceive(response: RoomBoxUtils.RBResponse)
}
final public class RBPointValueProvider : RoomBoxUtils.RBAnyValueProvider {
  public typealias PointValueBlock = (CoreGraphics.CGFloat) -> CoreGraphics.CGPoint
  final public var point: CoreGraphics.CGPoint {
    get
    set
  }
  public init(block: @escaping RoomBoxUtils.RBPointValueProvider.PointValueBlock)
  public init(_ point: CoreGraphics.CGPoint)
  final public var valueType: Any.Type {
    get
  }
  final public func hasUpdate(frame: CoreGraphics.CGFloat) -> Swift.Bool
  final public func value(frame: CoreGraphics.CGFloat) -> Any
  @objc deinit
}
final public class RBPoly1305 : RoomBoxUtils.RBAuthenticator {
  public enum Error : Swift.Error {
    case authenticateError
    public static func == (a: RoomBoxUtils.RBPoly1305.Error, b: RoomBoxUtils.RBPoly1305.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public static let blockSize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>)
  final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
public class RBPrivateKey : RoomBoxUtils.RBKey {
  final public let reference: Security.SecKey
  final public let originalData: Foundation.Data?
  public func pemString() throws -> Swift.String
  required public init(reference: Security.SecKey) throws
  required public init(data: Foundation.Data) throws
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class RBProcessPoolFactory : ObjectiveC.NSObject {
  public var sharedPool: WebKit.WKProcessPool
  public static let sharedFactory: RoomBoxUtils.RBProcessPoolFactory
  @objc deinit
}
@_hasMissingDesignatedInitializers public class RBProgress {
  weak public var request: RoomBoxUtils.RBRequest?
  public var originalProgress: Foundation.Progress?
  public var currentProgress: Swift.Double {
    get
  }
  public var currentProgressString: Swift.String {
    get
  }
  @objc deinit
}
extension RBProgress : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public class RBPublicKey : RoomBoxUtils.RBKey {
  final public let reference: Security.SecKey
  final public let originalData: Foundation.Data?
  public func pemString() throws -> Swift.String
  required public init(reference: Security.SecKey) throws
  required public init(data: Foundation.Data) throws
  public static func publicKeys(pemEncoded pemString: Swift.String) -> [RoomBoxUtils.RBPublicKey]
  @objc deinit
}
extension RBRabbit {
  convenience public init(key: Swift.String) throws
  convenience public init(key: Swift.String, iv: Swift.String) throws
}
final public class RBRabbit {
  public enum Error : Swift.Error {
    case invalidKeyOrInitializationVector
    public static func == (a: RoomBoxUtils.RBRabbit.Error, b: RoomBoxUtils.RBRabbit.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public static let ivSize: Swift.Int
  public static let keySize: Swift.Int
  public static let blockSize: Swift.Int
  final public var keySize: Swift.Int {
    get
  }
  convenience public init(key: Swift.Array<Swift.UInt8>) throws
  public init(key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>?) throws
  @objc deinit
}
extension RBRabbit : RoomBoxUtils.RBCipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
public enum RBReachabilityError : Swift.Error {
  case FailedToCreateWithAddress(Darwin.sockaddr_in)
  case FailedToCreateWithHostname(Swift.String)
  case UnableToSetCallback
  case UnableToSetDispatchQueue
  case UnableToGetInitialFlags
}
@available(*, unavailable, renamed: "Notification.Name.reachabilityChanged")
public let ReachabilityChangedNotification: Foundation.NSNotification.Name
extension NSNotification.Name {
  public static let reachabilityChanged: Foundation.Notification.Name
}
public class RBReachability {
  public typealias NetworkReachable = (RoomBoxUtils.RBReachability) -> ()
  public typealias NetworkUnreachable = (RoomBoxUtils.RBReachability) -> ()
  @available(*, unavailable, renamed: "Connection")
  public enum NetworkStatus : Swift.CustomStringConvertible {
    case notReachable, reachableViaWiFi, reachableViaWWAN
    public var description: Swift.String {
      get
    }
    public static func == (a: RoomBoxUtils.RBReachability.NetworkStatus, b: RoomBoxUtils.RBReachability.NetworkStatus) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public enum Connection : Swift.CustomStringConvertible {
    case none, wifi, cellular
    public var description: Swift.String {
      get
    }
    public static func == (a: RoomBoxUtils.RBReachability.Connection, b: RoomBoxUtils.RBReachability.Connection) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public var whenReachable: RoomBoxUtils.RBReachability.NetworkReachable?
  public var whenUnreachable: RoomBoxUtils.RBReachability.NetworkUnreachable?
  @available(*, deprecated, renamed: "allowsCellularConnection")
  final public let reachableOnWWAN: Swift.Bool
  public var allowsCellularConnection: Swift.Bool
  public var notificationCenter: Foundation.NotificationCenter
  @available(*, deprecated, renamed: "connection.description")
  public var currentReachabilityString: Swift.String {
    get
  }
  @available(*, unavailable, renamed: "connection")
  public var currentReachabilityStatus: RoomBoxUtils.RBReachability.Connection {
    get
  }
  public var connection: RoomBoxUtils.RBReachability.Connection {
    get
  }
  required public init(reachabilityRef: SystemConfiguration.SCNetworkReachability, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil)
  convenience public init?(hostname: Swift.String, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil)
  convenience public init?(queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil)
  @objc deinit
}
extension RBReachability {
  public func startNotifier() throws
  public func stopNotifier()
  @available(*, deprecated, message: "Please use `connection != .none`")
  public var isReachable: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Please use `connection == .cellular`")
  public var isReachableViaWWAN: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Please use `connection == .wifi`")
  public var isReachableViaWiFi: Swift.Bool {
    get
  }
  public var description: Swift.String {
    get
  }
}
public let RBReachabilityManager: RoomBoxUtils.ReachabilityManager
public func connectedToInternet() -> RxSwift.Observable<Swift.Bool>
public func internetReachable() -> Swift.Bool
public func changedFromInternet() -> RxSwift.Observable<RoomBoxUtils.RBReachability.Connection>
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class ReachabilityManager : ObjectiveC.NSObject {
  public static let shared: RoomBoxUtils.ReachabilityManager
  public var reach: RxSwift.Observable<Swift.Bool> {
    get
  }
  public func getNetworkString() -> Swift.String
  public var networkStatus: RoomBoxUtils.RBReachability.Connection {
    get
  }
  public var reachable: Swift.Bool {
    get
  }
  @objc deinit
}
public protocol RBReflection {
  var jsonObject: Any? { get }
  var blackList: [Swift.String] { get }
}
extension RBReflection {
  public var blackList: [Swift.String] {
    get
  }
}
extension RBReflection {
  public var jsonObject: Any? {
    get
  }
}
extension Optional : RoomBoxUtils.RBReflection {
  public var jsonObject: Any? {
    get
  }
}
extension Array : RoomBoxUtils.RBReflection {
  public var jsonObject: Any? {
    get
  }
}
extension Dictionary : RoomBoxUtils.RBReflection {
  public var jsonObject: Any? {
    get
  }
}
extension Bool : RoomBoxUtils.RBReflection {
}
extension Int : RoomBoxUtils.RBReflection {
}
extension Int8 : RoomBoxUtils.RBReflection {
}
extension Int16 : RoomBoxUtils.RBReflection {
}
extension Int32 : RoomBoxUtils.RBReflection {
}
extension Int64 : RoomBoxUtils.RBReflection {
}
extension Float : RoomBoxUtils.RBReflection {
}
extension Double : RoomBoxUtils.RBReflection {
}
extension Decimal : RoomBoxUtils.RBReflection {
}
extension String : RoomBoxUtils.RBReflection {
}
open class RBRequest : RoomBoxUtils.RBReflection {
  public init(method: RoomBoxUtils.HTTPMethod = .get, URLString: Swift.String? = nil, path: Swift.String = "", parameters: RoomBoxUtils.Parameters? = nil, parameterEncoding: RoomBoxUtils.ParameterEncoding = URLEncoding.default, headers: RoomBoxUtils.HTTPHeaders? = nil)
  open func loadRequest()
  public var originalRequest: RoomBoxUtils.Request?
  public var requestID: Swift.String {
    get
  }
  public var method: RoomBoxUtils.HTTPMethod {
    get
    set
  }
  public var path: Swift.String
  public var URLString: Swift.String {
    get
    set
  }
  public var parameters: RoomBoxUtils.Parameters? {
    get
    set
  }
  public var parameterEncoding: RoomBoxUtils.ParameterEncoding {
    get
    set
  }
  public var target: RoomBoxUtils.RBTarget? {
    get
    set
  }
  public var headers: RoomBoxUtils.HTTPHeaders?
  public var credential: Foundation.URLCredential?
  public var urlRequest: RoomBoxUtils.URLRequestConvertible?
  public var dataKeyPath: Swift.String?
  public var enableLog: Swift.Bool {
    get
    set
  }
  public var userInfo: RoomBoxUtils.Parameters?
  public func pause()
  public func cancel()
  public func resume()
  @objc deinit
}
extension RBRequest {
  @objc dynamic open var blackList: [Swift.String] {
    @objc get
  }
}
extension RBRequest : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@_inheritsConvenienceInitializers open class RBDownloadRequest : RoomBoxUtils.RBRequest {
  public var isResume: Swift.Bool
  public var validateCode: Swift.String
  public var destinationURL: Foundation.URL?
  public var options: RoomBoxUtils.Options
  @objc override dynamic open var blackList: [Swift.String] {
    @objc get
  }
  override public func cancel()
  @objc deinit
  override public init(method: RoomBoxUtils.HTTPMethod = super, URLString: Swift.String? = super, path: Swift.String = super, parameters: RoomBoxUtils.Parameters? = super, parameterEncoding: RoomBoxUtils.ParameterEncoding = super, headers: RoomBoxUtils.HTTPHeaders? = super)
}
@_inheritsConvenienceInitializers open class RBUploadRequest : RoomBoxUtils.RBRequest {
  public typealias MultipartFormDataClosure = (RoomBoxUtils.MultipartFormData) -> Swift.Void
  override open func loadRequest()
  public var data: Foundation.Data?
  public var filePath: Swift.String?
  public var inputStream: (intputStream: Foundation.InputStream, length: Swift.Int)?
  public var multipartFormData: RoomBoxUtils.RBUploadRequest.MultipartFormDataClosure?
  public func multipartFormDataClosure(_ formDataClosure: @escaping RoomBoxUtils.RBUploadRequest.MultipartFormDataClosure)
  public var encodingMemoryThreshold: Swift.UInt64
  @objc deinit
  override public init(method: RoomBoxUtils.HTTPMethod = super, URLString: Swift.String? = super, path: Swift.String = super, parameters: RoomBoxUtils.Parameters? = super, parameterEncoding: RoomBoxUtils.ParameterEncoding = super, headers: RoomBoxUtils.HTTPHeaders? = super)
}
extension RBResponse {
  public func decode<T>(to Model: T.Type) -> T? where T : RoomBoxUtils.RBHandyJSON
}
@_hasMissingDesignatedInitializers public class RBResponse {
  weak public var request: RoomBoxUtils.RBRequest?
  final public let urlRequest: Foundation.URLRequest?
  final public let httpURLResponse: Foundation.HTTPURLResponse?
  public var originData: Foundation.Data?
  public var data: Any?
  public var error: Foundation.NSError?
  public var code: Swift.Int
  public var message: Swift.String?
  public var fileURL: Foundation.URL?
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class RBDownloadResponse : RoomBoxUtils.RBResponse {
  public var md5String: Swift.String?
  public var isVerificated: Swift.Bool
  public var verificationResult: Swift.Bool
  public var downloadError: RoomBoxUtils.RBDownloadError?
  @objc deinit
}
extension RBResponse {
  public var statusCode: Swift.Int {
    get
  }
  public var header: [Swift.AnyHashable : Any] {
    get
  }
}
extension RBResponse {
  public var dataDictionary: [Swift.String : Any]? {
    get
  }
  public var dataArray: [[Swift.String : Any]]? {
    get
  }
  public var dataString: Swift.String? {
    get
  }
  public func decode<T>(to Model: T.Type) -> T? where T : Swift.Decodable
}
extension RBResponse : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
final public class RBScrypt {
  public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, dkLen: Swift.Int, N: Swift.Int, r: Swift.Int, p: Swift.Int) throws
  final public func calculate() throws -> [Swift.UInt8]
  @objc deinit
}
extension RBHandyJSON {
  public func toJSON() -> [Swift.String : Any]?
  public func toJSONString(prettyPrint: Swift.Bool = false) -> Swift.String?
}
extension Collection where Self.Element : RoomBoxUtils.RBHandyJSON {
  public func toJSON() -> [[Swift.String : Any]?]
  public func toJSONString(prettyPrint: Swift.Bool = false) -> Swift.String?
}
final public class RBSHA1 {
  @usableFromInline
  internal static let digestLength: Swift.Int
  @usableFromInline
  internal static let blockSize: Swift.Int
  @usableFromInline
  internal static let hashInitialValue: Swift.ContiguousArray<Swift.UInt32>
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var processedBytesTotalCount: Swift.Int
  @usableFromInline
  final internal var accumulatedHash: Swift.ContiguousArray<Swift.UInt32>
  public init()
  @inlinable final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8> {
    do {
      return try update(withBytes: bytes.slice, isLast: true)
    } catch {
      return []
    }
  }
  @usableFromInline
  final internal func process(block chunk: Swift.ArraySlice<Swift.UInt8>, currentHash hh: inout Swift.ContiguousArray<Swift.UInt32>)
  @objc deinit
}
extension RBSHA1 : RoomBoxUtils.RBUpdatable {
  @discardableResult
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    if isLast {
      let lengthInBits = (processedBytesTotalCount + self.accumulated.count) * 8
      let lengthBytes = lengthInBits.bytes(totalBytes: 64 / 8) // A 64-bit representation of b

      // Step 1. Append padding
      bitPadding(to: &self.accumulated, blockSize: RBSHA1.blockSize, allowance: 64 / 8)

      // Step 2. Append Length a 64-bit representation of lengthInBits
      self.accumulated += lengthBytes
    }

    var processedBytes = 0
    for chunk in self.accumulated.batched(by: RBSHA1.blockSize) {
      if isLast || (self.accumulated.count - processedBytes) >= RBSHA1.blockSize {
        self.process(block: chunk, currentHash: &self.accumulatedHash)
        processedBytes += chunk.count
      }
    }
    self.accumulated.removeFirst(processedBytes)
    self.processedBytesTotalCount += processedBytes

    // output current hash
    var result = Array<UInt8>(repeating: 0, count: RBSHA1.digestLength)
    var pos = 0
    for idx in 0..<self.accumulatedHash.count {
      let h = self.accumulatedHash[idx]
      result[pos + 0] = UInt8((h >> 24) & 0xff)
      result[pos + 1] = UInt8((h >> 16) & 0xff)
      result[pos + 2] = UInt8((h >> 8) & 0xff)
      result[pos + 3] = UInt8(h & 0xff)
      pos += 4
    }

    // reset hash value for instance
    if isLast {
      self.accumulatedHash = RBSHA1.hashInitialValue
    }

    return result
  }
}
final public class RBSHA2 {
  @usableFromInline
  final internal let variant: RoomBoxUtils.RBSHA2.Variant
  @usableFromInline
  final internal let size: Swift.Int
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal let digestLength: Swift.Int
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var processedBytesTotalCount: Swift.Int
  @usableFromInline
  final internal var accumulatedHash32: [Swift.UInt32]
  @usableFromInline
  final internal var accumulatedHash64: [Swift.UInt64]
  @frozen public enum Variant : Swift.RawRepresentable {
    case sha224, sha256, sha384, sha512
    public var digestLength: Swift.Int {
      get
    }
    public var blockSize: Swift.Int {
      get
    }
    public typealias RawValue = Swift.Int
    public var rawValue: RoomBoxUtils.RBSHA2.Variant.RawValue {
      get
    }
    public init?(rawValue: RoomBoxUtils.RBSHA2.Variant.RawValue)
    @usableFromInline
    internal var h: Swift.Array<Swift.UInt64> {
      get
    }
    @usableFromInline
    internal var finalLength: Swift.Int {
      get
    }
  }
  public init(variant: RoomBoxUtils.RBSHA2.Variant)
  @inlinable final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8> {
    do {
      return try update(withBytes: bytes.slice, isLast: true)
    } catch {
      return []
    }
  }
  @usableFromInline
  final internal func process64(block chunk: Swift.ArraySlice<Swift.UInt8>, currentHash hh: inout Swift.Array<Swift.UInt64>)
  @usableFromInline
  final internal func process32(block chunk: Swift.ArraySlice<Swift.UInt8>, currentHash hh: inout Swift.Array<Swift.UInt32>)
  @objc deinit
}
extension RBSHA2 : RoomBoxUtils.RBUpdatable {
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    if isLast {
      let lengthInBits = (processedBytesTotalCount + self.accumulated.count) * 8
      let lengthBytes = lengthInBits.bytes(totalBytes: self.blockSize / 8) // A 64-bit/128-bit representation of b. blockSize fit by accident.

      // Step 1. Append padding
      bitPadding(to: &self.accumulated, blockSize: self.blockSize, allowance: self.blockSize / 8)

      // Step 2. Append Length a 64-bit representation of lengthInBits
      self.accumulated += lengthBytes
    }

    var processedBytes = 0
    for chunk in self.accumulated.batched(by: self.blockSize) {
      if isLast || (self.accumulated.count - processedBytes) >= self.blockSize {
        switch self.variant {
          case .sha224, .sha256:
            self.process32(block: chunk, currentHash: &self.accumulatedHash32)
          case .sha384, .sha512:
            self.process64(block: chunk, currentHash: &self.accumulatedHash64)
          }
        processedBytes += chunk.count
      }
    }
    self.accumulated.removeFirst(processedBytes)
    self.processedBytesTotalCount += processedBytes

    // output current hash
    var result = Array<UInt8>(repeating: 0, count: variant.digestLength)
    switch self.variant {
      case .sha224, .sha256:
        var pos = 0
        for idx in 0..<self.accumulatedHash32.count where idx < self.variant.finalLength {
          let h = accumulatedHash32[idx]
          result[pos + 0] = UInt8((h >> 24) & 0xff)
          result[pos + 1] = UInt8((h >> 16) & 0xff)
          result[pos + 2] = UInt8((h >> 8) & 0xff)
          result[pos + 3] = UInt8(h & 0xff)
          pos += 4
        }
      case .sha384, .sha512:
        var pos = 0
        for idx in 0..<self.accumulatedHash64.count where idx < self.variant.finalLength {
          let h = accumulatedHash64[idx]
          result[pos + 0] = UInt8((h >> 56) & 0xff)
          result[pos + 1] = UInt8((h >> 48) & 0xff)
          result[pos + 2] = UInt8((h >> 40) & 0xff)
          result[pos + 3] = UInt8((h >> 32) & 0xff)
          result[pos + 4] = UInt8((h >> 24) & 0xff)
          result[pos + 5] = UInt8((h >> 16) & 0xff)
          result[pos + 6] = UInt8((h >> 8) & 0xff)
          result[pos + 7] = UInt8(h & 0xff)
          pos += 8
        }
    }

    // reset hash value for instance
    if isLast {
      switch self.variant {
        case .sha224, .sha256:
          self.accumulatedHash32 = self.variant.h.lazy.map { UInt32($0) } // FIXME: UInt64 for process64
        case .sha384, .sha512:
          self.accumulatedHash64 = self.variant.h
      }
    }

    return result
  }
}
final public class RBSHA3 {
  final public let blockSize: Swift.Int
  final public let digestLength: Swift.Int
  final public let markByte: Swift.UInt8
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var accumulatedHash: Swift.Array<Swift.UInt64>
  public enum Variant {
    case sha224, sha256, sha384, sha512, keccak224, keccak256, keccak384, keccak512
    public var outputLength: Swift.Int {
      get
    }
    public static func == (a: RoomBoxUtils.RBSHA3.Variant, b: RoomBoxUtils.RBSHA3.Variant) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public init(variant: RoomBoxUtils.RBSHA3.Variant)
  @inlinable final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8> {
    do {
      return try update(withBytes: bytes.slice, isLast: true)
    } catch {
      return []
    }
  }
  @usableFromInline
  final internal func process(block chunk: Swift.ArraySlice<Swift.UInt64>, currentHash hh: inout Swift.Array<Swift.UInt64>)
  @objc deinit
}
extension RBSHA3 : RoomBoxUtils.RBUpdatable {
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    if isLast {
      // Add padding
      let markByteIndex = self.accumulated.count

      // We need to always pad the input. Even if the input is a multiple of blockSize.
      let r = self.blockSize * 8
      let q = (r / 8) - (accumulated.count % (r / 8))
      self.accumulated += Array<UInt8>(repeating: 0, count: q)

      self.accumulated[markByteIndex] |= self.markByte
      self.accumulated[self.accumulated.count - 1] |= 0x80
    }

    var processedBytes = 0
    for chunk in self.accumulated.batched(by: self.blockSize) {
      if isLast || (self.accumulated.count - processedBytes) >= self.blockSize {
        self.process(block: chunk.toUInt64Array().slice, currentHash: &self.accumulatedHash)
        processedBytes += chunk.count
      }
    }
    self.accumulated.removeFirst(processedBytes)

    // TODO: verify performance, reduce vs for..in
    let result = self.accumulatedHash.reduce(into: Array<UInt8>()) { (result, value) in
      result += value.bigEndian.bytes()
    }

    // reset hash value for instance
    if isLast {
      self.accumulatedHash = Array<UInt64>(repeating: 0, count: self.digestLength)
    }

    return Array(result[0..<self.digestLength])
  }
}
public class RBSignature {
  public enum DigestType {
    case sha1
    case sha224
    case sha256
    case sha384
    case sha512
    public static func == (a: RoomBoxUtils.RBSignature.DigestType, b: RoomBoxUtils.RBSignature.DigestType) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  final public let data: Foundation.Data
  public init(data: Foundation.Data)
  convenience public init(base64Encoded base64String: Swift.String) throws
  public var base64String: Swift.String {
    get
  }
  @objc deinit
}
public struct RBSizeClasser {
  public static let maxScreenLength: CoreGraphics.CGFloat
  public static let minScreenLength: CoreGraphics.CGFloat
  public static let ipadProMaxScreenLength: CoreGraphics.CGFloat
  public static let isiPadPro: Swift.Bool
  public static func adapterSize(size fro: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat
  public static func isIphoneX() -> Swift.Bool
  public static func orientationPortrait() -> Swift.Bool
  public static func isPhone() -> Swift.Bool
  public static func isIpad() -> Swift.Bool
}
final public class RBSizeValueProvider : RoomBoxUtils.RBAnyValueProvider {
  public typealias SizeValueBlock = (CoreGraphics.CGFloat) -> CoreGraphics.CGSize
  final public var size: CoreGraphics.CGSize {
    get
    set
  }
  public init(block: @escaping RoomBoxUtils.RBSizeValueProvider.SizeValueBlock)
  public init(_ size: CoreGraphics.CGSize)
  final public var valueType: Any.Type {
    get
  }
  final public func hasUpdate(frame: CoreGraphics.CGFloat) -> Swift.Bool
  final public func value(frame: CoreGraphics.CGFloat) -> Any
  @objc deinit
}
@usableFromInline
final internal class RBStreamDecryptor : RoomBoxUtils.RBCryptor, RoomBoxUtils.RBUpdatable {
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal var worker: RoomBoxUtils.RBCipherModeWorker
  @usableFromInline
  final internal let padding: RoomBoxUtils.RBPadding
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var lastBlockRemainder: Swift.Int
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: RoomBoxUtils.RBPadding, _ worker: RoomBoxUtils.RBCipherModeWorker) throws
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    let toProcess = self.accumulated.prefix(max(self.accumulated.count - self.worker.additionalBufferSize, 0))

    if var finalizingWorker = worker as? FinalizingDecryptModeWorker, isLast == true {
      // will truncate suffix if needed
      try finalizingWorker.willDecryptLast(bytes: self.accumulated.slice)
    }

    var processedBytesCount = 0
    var plaintext = Array<UInt8>(reserveCapacity: bytes.count + self.worker.additionalBufferSize)
    for chunk in toProcess.batched(by: self.blockSize) {
      plaintext += self.worker.decrypt(block: chunk)
      processedBytesCount += chunk.count
    }

    if var finalizingWorker = worker as? FinalizingDecryptModeWorker, isLast == true {
      plaintext = Array(try finalizingWorker.didDecryptLast(bytes: plaintext.slice))
    }

    // omit unecessary calculation if not needed
    if self.padding != .noPadding {
      self.lastBlockRemainder = plaintext.count.quotientAndRemainder(dividingBy: self.blockSize).remainder
    }

    if isLast {
      // CTR doesn't need padding. Really. Add padding to the last block if really want. but... don't.
      plaintext = self.padding.remove(from: plaintext, blockSize: self.blockSize - self.lastBlockRemainder)
    }

    self.accumulated.removeFirst(processedBytesCount) // super-slow

    if var finalizingWorker = worker as? FinalizingDecryptModeWorker, isLast == true {
      plaintext = Array(try finalizingWorker.finalize(decrypt: plaintext.slice))
    }

    return plaintext
  }
  @inlinable final public func seek(to position: Swift.Int) throws {
    guard var worker = self.worker as? SeekableModeWorker else {
      fatalError("Not supported")
    }

    try worker.seek(to: position)
    self.worker = worker
  }
  @objc @usableFromInline
  deinit
}
@usableFromInline
final internal class RBStreamEncryptor : RoomBoxUtils.RBCryptor, RoomBoxUtils.RBUpdatable {
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal var worker: RoomBoxUtils.RBCipherModeWorker
  @usableFromInline
  final internal let padding: RoomBoxUtils.RBPadding
  @usableFromInline
  final internal var lastBlockRemainder: Swift.Int
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: RoomBoxUtils.RBPadding, _ worker: RoomBoxUtils.RBCipherModeWorker) throws
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8> {
    var accumulated = Array(bytes)
    if isLast {
      // CTR doesn't need padding. Really. Add padding to the last block if really want. but... don't.
      accumulated = self.padding.add(to: accumulated, blockSize: self.blockSize - self.lastBlockRemainder)
    }

    var encrypted = Array<UInt8>(reserveCapacity: bytes.count)
    for chunk in accumulated.batched(by: self.blockSize) {
      encrypted += self.worker.encrypt(block: chunk)
    }

    // omit unecessary calculation if not needed
    if self.padding != .noPadding {
      self.lastBlockRemainder = encrypted.count.quotientAndRemainder(dividingBy: self.blockSize).remainder
    }

    if var finalizingWorker = worker as? FinalizingEncryptModeWorker, isLast == true {
      encrypted = Array(try finalizingWorker.finalize(encrypt: encrypted.slice))
    }

    return encrypted
  }
  @usableFromInline
  final internal func seek(to: Swift.Int) throws
  @objc @usableFromInline
  deinit
}
public enum RBSwiftyJSONError : Swift.Int, Swift.Error {
  case unsupportedType
  case indexOutOfBounds
  case elementTooDeep
  case wrongType
  case notExist
  case invalidJSON
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
extension RBSwiftyJSONError : Foundation.CustomNSError {
  public static var errorDomain: Swift.String {
    get
  }
  public var errorCode: Swift.Int {
    get
  }
  public var errorUserInfo: [Swift.String : Any] {
    get
  }
}
public enum Type : Swift.Int {
  case number
  case string
  case bool
  case array
  case dictionary
  case null
  case unknown
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public struct RBJSON {
  public init(data: Foundation.Data, options opt: Foundation.JSONSerialization.ReadingOptions = []) throws
  public init(_ object: Any)
  public init(parseJSON jsonString: Swift.String)
  public mutating func merge(with other: RoomBoxUtils.RBJSON) throws
  public func merged(with other: RoomBoxUtils.RBJSON) throws -> RoomBoxUtils.RBJSON
  public var type: RoomBoxUtils.`Type` {
    get
  }
  public var error: RoomBoxUtils.RBSwiftyJSONError? {
    get
  }
  public var object: Any {
    get
    set
  }
  @available(*, unavailable, renamed: "null")
  public static var nullJSON: RoomBoxUtils.RBJSON {
    get
  }
  public static var null: RoomBoxUtils.RBJSON {
    get
  }
}
public enum Index<T> : Swift.Comparable {
  case array(Swift.Int)
  case dictionary(Swift.DictionaryIndex<Swift.String, T>)
  case null
  public static func == (lhs: RoomBoxUtils.Index<T>, rhs: RoomBoxUtils.Index<T>) -> Swift.Bool
  public static func < (lhs: RoomBoxUtils.Index<T>, rhs: RoomBoxUtils.Index<T>) -> Swift.Bool
}
public typealias JSONIndex = RoomBoxUtils.Index<RoomBoxUtils.RBJSON>
public typealias JSONRawIndex = RoomBoxUtils.Index<Any>
extension RBJSON : Swift.Collection {
  public typealias Index = RoomBoxUtils.JSONRawIndex
  public var startIndex: RoomBoxUtils.RBJSON.Index {
    get
  }
  public var endIndex: RoomBoxUtils.RBJSON.Index {
    get
  }
  public func index(after i: RoomBoxUtils.RBJSON.Index) -> RoomBoxUtils.RBJSON.Index
  public subscript(position: RoomBoxUtils.RBJSON.Index) -> (Swift.String, RoomBoxUtils.RBJSON) {
    get
  }
  public typealias Element = (Swift.String, RoomBoxUtils.RBJSON)
  public typealias Iterator = Swift.IndexingIterator<RoomBoxUtils.RBJSON>
  public typealias SubSequence = Swift.Slice<RoomBoxUtils.RBJSON>
  public typealias Indices = Swift.DefaultIndices<RoomBoxUtils.RBJSON>
}
public enum RBJSONKey {
  case index(Swift.Int)
  case key(Swift.String)
}
public protocol JSONSubscriptType {
  var jsonKey: RoomBoxUtils.RBJSONKey { get }
}
extension Int : RoomBoxUtils.JSONSubscriptType {
  public var jsonKey: RoomBoxUtils.RBJSONKey {
    get
  }
}
extension String : RoomBoxUtils.JSONSubscriptType {
  public var jsonKey: RoomBoxUtils.RBJSONKey {
    get
  }
}
extension RBJSON {
  public subscript(path: [RoomBoxUtils.JSONSubscriptType]) -> RoomBoxUtils.RBJSON {
    get
    set
  }
  public subscript(path: RoomBoxUtils.JSONSubscriptType...) -> RoomBoxUtils.RBJSON {
    get
    set
  }
}
extension RBJSON : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.StringLiteralType)
  public init(extendedGraphemeClusterLiteral value: Swift.StringLiteralType)
  public init(unicodeScalarLiteral value: Swift.StringLiteralType)
  public typealias StringLiteralType = Swift.StringLiteralType
  public typealias ExtendedGraphemeClusterLiteralType = Swift.StringLiteralType
  public typealias UnicodeScalarLiteralType = Swift.StringLiteralType
}
extension RBJSON : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Swift.IntegerLiteralType)
  public typealias IntegerLiteralType = Swift.IntegerLiteralType
}
extension RBJSON : Swift.ExpressibleByBooleanLiteral {
  public init(booleanLiteral value: Swift.BooleanLiteralType)
  public typealias BooleanLiteralType = Swift.BooleanLiteralType
}
extension RBJSON : Swift.ExpressibleByFloatLiteral {
  public init(floatLiteral value: Swift.FloatLiteralType)
  public typealias FloatLiteralType = Swift.FloatLiteralType
}
extension RBJSON : Swift.ExpressibleByDictionaryLiteral {
  public init(dictionaryLiteral elements: (Swift.String, Any)...)
  public typealias Key = Swift.String
  public typealias Value = Any
}
extension RBJSON : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: Any...)
  public typealias ArrayLiteralElement = Any
}
extension RBJSON : Swift.RawRepresentable {
  public init?(rawValue: Any)
  public var rawValue: Any {
    get
  }
  public func rawData(options opt: Foundation.JSONSerialization.WritingOptions = JSONSerialization.WritingOptions(rawValue: 0)) throws -> Foundation.Data
  public func rawString(_ encoding: Swift.String.Encoding = .utf8, options opt: Foundation.JSONSerialization.WritingOptions = .prettyPrinted) -> Swift.String?
  public func rawString(_ options: [RoomBoxUtils.writingOptionsKeys : Any]) -> Swift.String?
  public typealias RawValue = Any
}
extension RBJSON : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension RBJSON {
  public var array: [RoomBoxUtils.RBJSON]? {
    get
  }
  public var arrayValue: [RoomBoxUtils.RBJSON] {
    get
  }
  public var arrayObject: [Any]? {
    get
    set
  }
}
extension RBJSON {
  public var dictionary: [Swift.String : RoomBoxUtils.RBJSON]? {
    get
  }
  public var dictionaryValue: [Swift.String : RoomBoxUtils.RBJSON] {
    get
  }
  public var dictionaryObject: [Swift.String : Any]? {
    get
    set
  }
}
extension RBJSON {
  public var bool: Swift.Bool? {
    get
    set
  }
  public var boolValue: Swift.Bool {
    get
    set
  }
}
extension RBJSON {
  public var string: Swift.String? {
    get
    set
  }
  public var stringValue: Swift.String {
    get
    set
  }
}
extension RBJSON {
  public var number: Foundation.NSNumber? {
    get
    set
  }
  public var numberValue: Foundation.NSNumber {
    get
    set
  }
}
extension RBJSON {
  public var null: Foundation.NSNull? {
    get
    set
  }
  public func exists() -> Swift.Bool
}
extension RBJSON {
  public var url: Foundation.URL? {
    get
    set
  }
}
extension RBJSON {
  public var double: Swift.Double? {
    get
    set
  }
  public var doubleValue: Swift.Double {
    get
    set
  }
  public var float: Swift.Float? {
    get
    set
  }
  public var floatValue: Swift.Float {
    get
    set
  }
  public var int: Swift.Int? {
    get
    set
  }
  public var intValue: Swift.Int {
    get
    set
  }
  public var uInt: Swift.UInt? {
    get
    set
  }
  public var uIntValue: Swift.UInt {
    get
    set
  }
  public var int8: Swift.Int8? {
    get
    set
  }
  public var int8Value: Swift.Int8 {
    get
    set
  }
  public var uInt8: Swift.UInt8? {
    get
    set
  }
  public var uInt8Value: Swift.UInt8 {
    get
    set
  }
  public var int16: Swift.Int16? {
    get
    set
  }
  public var int16Value: Swift.Int16 {
    get
    set
  }
  public var uInt16: Swift.UInt16? {
    get
    set
  }
  public var uInt16Value: Swift.UInt16 {
    get
    set
  }
  public var int32: Swift.Int32? {
    get
    set
  }
  public var int32Value: Swift.Int32 {
    get
    set
  }
  public var uInt32: Swift.UInt32? {
    get
    set
  }
  public var uInt32Value: Swift.UInt32 {
    get
    set
  }
  public var int64: Swift.Int64? {
    get
    set
  }
  public var int64Value: Swift.Int64 {
    get
    set
  }
  public var uInt64: Swift.UInt64? {
    get
    set
  }
  public var uInt64Value: Swift.UInt64 {
    get
    set
  }
}
extension RBJSON : Swift.Comparable {
}
public func == (lhs: RoomBoxUtils.RBJSON, rhs: RoomBoxUtils.RBJSON) -> Swift.Bool
public func <= (lhs: RoomBoxUtils.RBJSON, rhs: RoomBoxUtils.RBJSON) -> Swift.Bool
public func >= (lhs: RoomBoxUtils.RBJSON, rhs: RoomBoxUtils.RBJSON) -> Swift.Bool
public func > (lhs: RoomBoxUtils.RBJSON, rhs: RoomBoxUtils.RBJSON) -> Swift.Bool
public func < (lhs: RoomBoxUtils.RBJSON, rhs: RoomBoxUtils.RBJSON) -> Swift.Bool
public enum writingOptionsKeys {
  case jsonSerialization
  case castNilToNSNull
  case maxObjextDepth
  case encoding
  public static func == (a: RoomBoxUtils.writingOptionsKeys, b: RoomBoxUtils.writingOptionsKeys) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
extension RBJSON : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@objc(RBPublicKey) public class _objc_PublicKey : ObjectiveC.NSObject, RoomBoxUtils.RBKey {
  @objc public var reference: Security.SecKey {
    @objc get
  }
  @objc public var originalData: Foundation.Data? {
    @objc get
  }
  @objc public func pemString() throws -> Swift.String
  @objc public func data() throws -> Foundation.Data
  @objc public func base64String() throws -> Swift.String
  required public init(swiftValue: RoomBoxUtils.RBPublicKey)
  @objc required public init(data: Foundation.Data) throws
  @objc required public init(reference: Security.SecKey) throws
  @objc required public init(base64Encoded base64String: Swift.String) throws
  @objc required public init(pemEncoded pemString: Swift.String) throws
  @objc required public init(pemNamed pemName: Swift.String, in bundle: Foundation.Bundle) throws
  @objc required public init(derNamed derName: Swift.String, in bundle: Foundation.Bundle) throws
  @objc public static func publicKeys(pemEncoded pemString: Swift.String) -> [RoomBoxUtils._objc_PublicKey]
  @objc deinit
  @objc override dynamic public init()
}
@objc(RBPrivateKey) public class _objc_PrivateKey : ObjectiveC.NSObject, RoomBoxUtils.RBKey {
  @objc public var reference: Security.SecKey {
    @objc get
  }
  @objc public var originalData: Foundation.Data? {
    @objc get
  }
  @objc public func pemString() throws -> Swift.String
  @objc public func data() throws -> Foundation.Data
  @objc public func base64String() throws -> Swift.String
  required public init(swiftValue: RoomBoxUtils.RBPrivateKey)
  @objc required public init(data: Foundation.Data) throws
  @objc required public init(reference: Security.SecKey) throws
  @objc required public init(base64Encoded base64String: Swift.String) throws
  @objc required public init(pemEncoded pemString: Swift.String) throws
  @objc required public init(pemNamed pemName: Swift.String, in bundle: Foundation.Bundle) throws
  @objc required public init(derNamed derName: Swift.String, in bundle: Foundation.Bundle) throws
  @objc deinit
  @objc override dynamic public init()
}
@_hasMissingDesignatedInitializers @objc(VerificationResult) public class _objc_VerificationResult : ObjectiveC.NSObject {
  @objc final public let isSuccessful: Swift.Bool
  @objc deinit
  @objc override dynamic public init()
}
@objc(ClearMessage) public class _objc_ClearMessage : ObjectiveC.NSObject, RoomBoxUtils.RBMessage {
  @objc public var base64String: Swift.String {
    @objc get
  }
  @objc public var data: Foundation.Data {
    @objc get
  }
  required public init(swiftValue: RoomBoxUtils.RBClearMessage)
  @objc required public init(data: Foundation.Data)
  @objc required public init(string: Swift.String, using rawEncoding: Swift.UInt) throws
  @objc required public init(base64Encoded base64String: Swift.String) throws
  @objc public func string(encoding rawEncoding: Swift.UInt) throws -> Swift.String
  @objc public func encrypted(with key: RoomBoxUtils._objc_PublicKey, padding: RoomBoxUtils.Padding) throws -> RoomBoxUtils._objc_EncryptedMessage
  @objc public func signed(with key: RoomBoxUtils._objc_PrivateKey, digestType: RoomBoxUtils._objc_Signature.DigestType) throws -> RoomBoxUtils._objc_Signature
  @objc public func verify(with key: RoomBoxUtils._objc_PublicKey, signature: RoomBoxUtils._objc_Signature, digestType: RoomBoxUtils._objc_Signature.DigestType) throws -> RoomBoxUtils._objc_VerificationResult
  @objc deinit
  @objc override dynamic public init()
}
@objc(RBEncryptedMessage) public class _objc_EncryptedMessage : ObjectiveC.NSObject, RoomBoxUtils.RBMessage {
  @objc public var base64String: Swift.String {
    @objc get
  }
  @objc public var data: Foundation.Data {
    @objc get
  }
  required public init(swiftValue: RoomBoxUtils.RBEncryptedMessage)
  @objc required public init(data: Foundation.Data)
  @objc required public init(base64Encoded base64String: Swift.String) throws
  @objc public func decrypted(with key: RoomBoxUtils._objc_PrivateKey, padding: RoomBoxUtils.Padding) throws -> RoomBoxUtils._objc_ClearMessage
  @objc deinit
  @objc override dynamic public init()
}
@objc(RBSignature) public class _objc_Signature : ObjectiveC.NSObject {
  @objc public enum DigestType : Swift.Int {
    case sha1
    case sha224
    case sha256
    case sha384
    case sha512
    public typealias RawValue = Swift.Int
    public init?(rawValue: Swift.Int)
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc public var base64String: Swift.String {
    @objc get
  }
  @objc public var data: Foundation.Data {
    @objc get
  }
  required public init(swiftValue: RoomBoxUtils.RBSignature)
  @objc public init(data: Foundation.Data)
  @objc required public init(base64Encoded base64String: Swift.String) throws
  @objc deinit
  @objc override dynamic public init()
}
public typealias Padding = Security.SecPadding
public enum RBSwiftyRSA {
  @available(iOS 10.0, watchOS 3.0, tvOS 10.0, *)
  public static func generateRSAKeyPair(sizeInBits size: Swift.Int) throws -> (privateKey: RoomBoxUtils.RBPrivateKey, publicKey: RoomBoxUtils.RBPublicKey)
}
public enum RBSwiftyRSAError : Swift.Error {
  case pemDoesNotContainKey
  case keyRepresentationFailed(error: CoreFoundation.CFError?)
  case keyGenerationFailed(error: CoreFoundation.CFError?)
  case keyCreateFailed(error: CoreFoundation.CFError?)
  case keyAddFailed(status: Darwin.OSStatus)
  case keyCopyFailed(status: Darwin.OSStatus)
  case tagEncodingFailed
  case asn1ParsingFailed
  case invalidAsn1RootNode
  case invalidAsn1Structure
  case invalidBase64String
  case chunkDecryptFailed(index: Swift.Int)
  case chunkEncryptFailed(index: Swift.Int)
  case stringToDataConversionFailed
  case dataToStringConversionFailed
  case invalidDigestSize(digestSize: Swift.Int, maxChunkSize: Swift.Int)
  case signatureCreateFailed(status: Darwin.OSStatus)
  case signatureVerifyFailed(status: Darwin.OSStatus)
  case pemFileNotFound(name: Swift.String)
  case derFileNotFound(name: Swift.String)
  case notAPublicKey
  case notAPrivateKey
}
public protocol RBTarget {
  var baseURLString: Swift.String { get }
  var IPURLString: Swift.String? { get set }
  var method: RoomBoxUtils.HTTPMethod { get }
  var headers: RoomBoxUtils.HTTPHeaders? { get }
  var parameterEncoding: RoomBoxUtils.ParameterEncoding { get }
  var configuration: Foundation.URLSessionConfiguration { get }
  var allHostsMustBeEvaluated: Swift.Bool { get }
  var serverEvaluators: [Swift.String : RoomBoxUtils.ServerTrustEvaluating]? { get }
  var clientTrustPolicy: (secPKCS12Path: Swift.String, password: Swift.String)? { get }
  var responseQueue: Dispatch.DispatchQueue? { get }
  var plugins: [RoomBoxUtils.RBPlugin]? { get }
  var reachabilityListener: RoomBoxUtils.ReachabilityListener? { get }
  var host: Swift.String { get }
  var status: (codeKey: Swift.String, successCode: [Swift.Int], messageKey: Swift.String?, dataKeyPath: Swift.String?)? { get }
  var decoder: Foundation.JSONDecoder { get }
  var enableLog: Swift.Bool { get }
}
extension RBTarget {
  public var baseURLString: Swift.String {
    get
  }
  public var IPURLString: Swift.String? {
    get
    set
  }
  public var method: RoomBoxUtils.HTTPMethod {
    get
  }
  public var headers: RoomBoxUtils.HTTPHeaders? {
    get
  }
  public var parameterEncoding: RoomBoxUtils.ParameterEncoding {
    get
  }
  public var configuration: Foundation.URLSessionConfiguration {
    get
  }
  public var allHostsMustBeEvaluated: Swift.Bool {
    get
  }
  public var serverEvaluators: [Swift.String : RoomBoxUtils.ServerTrustEvaluating]? {
    get
  }
  public var clientTrustPolicy: (secPKCS12Path: Swift.String, password: Swift.String)? {
    get
  }
  public var responseQueue: Dispatch.DispatchQueue? {
    get
  }
  public var plugins: [RoomBoxUtils.RBPlugin]? {
    get
  }
  public var reachabilityListener: RoomBoxUtils.ReachabilityListener? {
    get
  }
  public var host: Swift.String {
    get
  }
  public var status: (codeKey: Swift.String, successCode: Swift.Int, messageKey: Swift.String?, dataKeyPath: Swift.String?)? {
    get
  }
  public var decoder: Foundation.JSONDecoder {
    get
  }
  public var enableLog: Swift.Bool {
    get
  }
}
public protocol _RBTransformable : RoomBoxUtils._RBMeasurable {
}
open class RBTransformOf<RBObjectType, RBJSONType> : RoomBoxUtils.RBTransformType {
  public typealias Object = RBObjectType
  public typealias JSON = RBJSONType
  public init(fromJSON: @escaping (RBJSONType?) -> RBObjectType?, toJSON: @escaping (RBObjectType?) -> RBJSONType?)
  open func transformFromJSON(_ value: Any?) -> RBObjectType?
  open func transformToJSON(_ value: RBObjectType?) -> RBJSONType?
  @objc deinit
}
public protocol RBTransformType {
  associatedtype Object
  associatedtype JSON
  func transformFromJSON(_ value: Any?) -> Self.Object?
  func transformToJSON(_ value: Self.Object?) -> Self.JSON?
}
extension UIColor {
  public var lottieColorValue: RoomBoxUtils.RBColor {
    get
  }
}
public protocol RBUpdatable {
  mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8>
  mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool, output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws
}
extension RBUpdatable {
  @inlinable public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false, output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    let processed = try update(withBytes: bytes, isLast: isLast)
    if !processed.isEmpty {
      output(processed)
    }
  }
  @inlinable public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: bytes, isLast: isLast)
  }
  @inlinable public mutating func update(withBytes bytes: Swift.Array<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: bytes.slice, isLast: isLast)
  }
  @inlinable public mutating func update(withBytes bytes: Swift.Array<Swift.UInt8>, isLast: Swift.Bool = false, output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    try self.update(withBytes: bytes.slice, isLast: isLast, output: output)
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: bytes, isLast: true)
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    try self.finish(withBytes: bytes.slice)
  }
  @inlinable public mutating func finish() throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: [], isLast: true)
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    let processed = try update(withBytes: bytes, isLast: true)
    if !processed.isEmpty {
      output(processed)
    }
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.Array<Swift.UInt8>, output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    try self.finish(withBytes: bytes.slice, output: output)
  }
  @inlinable public mutating func finish(output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    try self.finish(withBytes: [], output: output)
  }
}
open class RBURLTransform : RoomBoxUtils.RBTransformType {
  public typealias Object = Foundation.URL
  public typealias JSON = Swift.String
  public init(shouldEncodeURLString: Swift.Bool = true)
  open func transformFromJSON(_ value: Any?) -> Foundation.URL?
  open func transformToJSON(_ value: Foundation.URL?) -> Swift.String?
  @objc deinit
}
@inlinable internal func rotateLeft(_ value: Swift.UInt8, by: Swift.UInt8) -> Swift.UInt8 {
  ((value << by) & 0xff) | (value >> (8 - by))
}
@inlinable internal func rotateLeft(_ value: Swift.UInt16, by: Swift.UInt16) -> Swift.UInt16 {
  ((value << by) & 0xffff) | (value >> (16 - by))
}
@inlinable internal func rotateLeft(_ value: Swift.UInt32, by: Swift.UInt32) -> Swift.UInt32 {
  ((value << by) & 0xffffffff) | (value >> (32 - by))
}
@inlinable internal func rotateLeft(_ value: Swift.UInt64, by: Swift.UInt64) -> Swift.UInt64 {
  (value << by) | (value >> (64 - by))
}
@inlinable internal func rotateRight(_ value: Swift.UInt16, by: Swift.UInt16) -> Swift.UInt16 {
  (value >> by) | (value << (16 - by))
}
@inlinable internal func rotateRight(_ value: Swift.UInt32, by: Swift.UInt32) -> Swift.UInt32 {
  (value >> by) | (value << (32 - by))
}
@inlinable internal func rotateRight(_ value: Swift.UInt64, by: Swift.UInt64) -> Swift.UInt64 {
  ((value >> by) | (value << (64 - by)))
}
@inlinable internal func reversed(_ uint8: Swift.UInt8) -> Swift.UInt8 {
  var v = uint8
  v = (v & 0xf0) >> 4 | (v & 0x0f) << 4
  v = (v & 0xcc) >> 2 | (v & 0x33) << 2
  v = (v & 0xaa) >> 1 | (v & 0x55) << 1
  return v
}
@inlinable internal func reversed(_ uint32: Swift.UInt32) -> Swift.UInt32 {
  var v = uint32
  v = ((v >> 1) & 0x55555555) | ((v & 0x55555555) << 1)
  v = ((v >> 2) & 0x33333333) | ((v & 0x33333333) << 2)
  v = ((v >> 4) & 0x0f0f0f0f) | ((v & 0x0f0f0f0f) << 4)
  v = ((v >> 8) & 0x00ff00ff) | ((v & 0x00ff00ff) << 8)
  v = ((v >> 16) & 0xffff) | ((v & 0xffff) << 16)
  return v
}
@inlinable internal func xor<T, V>(_ left: T, _ right: V) -> Swift.ArraySlice<Swift.UInt8> where T : Swift.RandomAccessCollection, V : Swift.RandomAccessCollection, T.Element == Swift.UInt8, T.Index == Swift.Int, V.Element == Swift.UInt8, V.Index == Swift.Int {
  return xor(left, right).slice
}
@inlinable internal func xor<T, V>(_ left: T, _ right: V) -> Swift.Array<Swift.UInt8> where T : Swift.RandomAccessCollection, V : Swift.RandomAccessCollection, T.Element == Swift.UInt8, T.Index == Swift.Int, V.Element == Swift.UInt8, V.Index == Swift.Int {
  let length = Swift.min(left.count, right.count)

  let buf = UnsafeMutablePointer<UInt8>.allocate(capacity: length)
  buf.initialize(repeating: 0, count: length)
  defer {
    buf.deinitialize(count: length)
    buf.deallocate()
  }

  // xor
  for i in 0..<length {
    buf[i] = left[left.startIndex.advanced(by: i)] ^ right[right.startIndex.advanced(by: i)]
  }

  return Array(UnsafeBufferPointer(start: buf, count: length))
}
@inline(__always) @inlinable internal func bitPadding(to data: inout Swift.Array<Swift.UInt8>, blockSize: Swift.Int, allowance: Swift.Int = 0) {
  let msgLength = data.count
  // Step 1. Append Padding Bits
  // append one bit (UInt8 with one bit) to message
  data.append(0x80)

  // Step 2. append "0" bit until message length in bits  448 (mod 512)
  let max = blockSize - allowance // 448, 986
  if msgLength % blockSize < max { // 448
    data += Array<UInt8>(repeating: 0, count: max - 1 - (msgLength % blockSize))
  } else {
    data += Array<UInt8>(repeating: 0, count: blockSize + max - 1 - (msgLength % blockSize))
  }
}
public struct Vector1D {
  public init(_ value: Swift.Double)
  public let value: Swift.Double
}
public struct Vector3D {
  public let x: Swift.Double
  public let y: Swift.Double
  public let z: Swift.Double
  public init(x: Swift.Double, y: Swift.Double, z: Swift.Double)
}
extension Vector1D : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension Vector3D : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension Vector3D {
  public var pointValue: CoreGraphics.CGPoint {
    get
  }
  public var sizeValue: CoreGraphics.CGSize {
    get
  }
}
public protocol RBWebViewDelegate : AnyObject {
  func webViewDidStartLoad(webview: RoomBoxUtils.RBWKWebView)
  func webView(webview: RoomBoxUtils.RBWKWebView, shouldStartWithURL url: Foundation.URL)
  func webView(webview: RoomBoxUtils.RBWKWebView, didFinishLoadingURL url: Foundation.URL)
  func webView(webview: RoomBoxUtils.RBWKWebView, didChangeProgress progress: Swift.Float)
  func webView(webview: RoomBoxUtils.RBWKWebView, didChangeTitle title: Swift.String)
  func webView(webview: RoomBoxUtils.RBWKWebView, didFailToLoadURL url: Foundation.URL, error: Foundation.NSError)
  func webView(webView: RoomBoxUtils.RBWKWebView, decidePolicyFor navigationResponse: WebKit.WKNavigationResponse, decisionHandler: @escaping (WebKit.WKNavigationResponsePolicy) -> Swift.Void)
  func webViewWebContentProcessDidTerminate(webview: RoomBoxUtils.RBWKWebView)
  func webViewCanGoBackChange(webview: RoomBoxUtils.RBWKWebView)
}
extension RBWebViewDelegate {
  public func webViewCanGoBackChange(webview: RoomBoxUtils.RBWKWebView)
  public func webView(webView: RoomBoxUtils.RBWKWebView, decidePolicyFor navigationResponse: WebKit.WKNavigationResponse, decisionHandler: @escaping (WebKit.WKNavigationResponsePolicy) -> Swift.Void)
}
@objc public class RBWebViewJavascriptBridge : ObjectiveC.NSObject {
  public var isLogEnable: Swift.Bool {
    get
    set(newValue)
  }
  public init(webView: WebKit.WKWebView, needRegister: Swift.Bool = true)
  @objc deinit
  public func reset()
  public func injectJavascript()
  public func register(handlerName: Swift.String, handler: @escaping RoomBoxUtils.RBWebViewJavascriptBridgeBase.Handler)
  public func registerJSCall(handlerName: Swift.String, handler: @escaping RoomBoxUtils.RBWebViewJavascriptBridgeBase.Handler)
  public func call(handlerName: Swift.String, data: Any? = nil, callback: RoomBoxUtils.RBWebViewJavascriptBridgeBase.Callback? = nil)
  public func remove(handlerName: Swift.String) -> RoomBoxUtils.RBWebViewJavascriptBridgeBase.Handler?
  public func addScriptMessageHandlers()
  @objc override dynamic public init()
}
extension RBWebViewJavascriptBridge {
  @objc dynamic public func evaluateJavascript(javascript: Swift.String)
}
extension RBWebViewJavascriptBridge : WebKit.WKScriptMessageHandler {
  @objc dynamic public func userContentController(_ userContentController: WebKit.WKUserContentController, didReceive message: WebKit.WKScriptMessage)
}
@objc @_inheritsConvenienceInitializers public class RBWebViewJavascriptBridgeBase : ObjectiveC.NSObject {
  public typealias Callback = (Any?) -> Swift.Void
  public typealias Handler = ([Swift.String : Any]?, RoomBoxUtils.RBWebViewJavascriptBridgeBase.Callback?) -> Swift.Void
  public typealias Message = [Swift.String : Any]
  @objc override dynamic public init()
  @objc deinit
}
@objc public class RBWebViewJavascriptBridgeRecord : RoomBoxUtils.RBWebViewJavascriptBridge {
  public init(webView: WebKit.WKWebView)
  override public func reset()
  override public func injectJavascript()
  public func injectJavascriptOnStart()
  public func injectJSOnStart(javascript: Swift.String)
  override public func register(handlerName: Swift.String, handler: @escaping RoomBoxUtils.RBWebViewJavascriptBridgeBase.Handler)
  override public func registerJSCall(handlerName: Swift.String, handler: @escaping RoomBoxUtils.RBWebViewJavascriptBridgeBase.Handler)
  override public func call(handlerName: Swift.String, data: Any? = nil, callback: RoomBoxUtils.RBWebViewJavascriptBridgeBase.Callback? = nil)
  override public func remove(handlerName: Swift.String) -> RoomBoxUtils.RBWebViewJavascriptBridgeBase.Handler?
  override public func addScriptMessageHandlers()
  @objc override dynamic public func evaluateJavascript(javascript: Swift.String)
  @objc override dynamic public func userContentController(_ userContentController: WebKit.WKUserContentController, didReceive message: WebKit.WKScriptMessage)
  @objc deinit
  override public init(webView: WebKit.WKWebView, needRegister: Swift.Bool = super)
}
public protocol RBWebViewRecordDelegate : AnyObject {
  func webViewDidStartLoad(webview: RoomBoxUtils.RBWKWebViewRecord)
  func webView(webview: RoomBoxUtils.RBWKWebViewRecord, shouldStartWithURL url: Foundation.URL)
  func webView(webview: RoomBoxUtils.RBWKWebViewRecord, didFinishLoadingURL url: Foundation.URL)
  func webView(webview: RoomBoxUtils.RBWKWebViewRecord, didChangeProgress progress: Swift.Float)
  func webView(webview: RoomBoxUtils.RBWKWebViewRecord, didChangeTitle title: Swift.String)
  func webView(webview: RoomBoxUtils.RBWKWebViewRecord, didFailToLoadURL url: Foundation.URL, error: Foundation.NSError)
  func webView(webView: RoomBoxUtils.RBWKWebViewRecord, decidePolicyFor navigationResponse: WebKit.WKNavigationResponse, decisionHandler: @escaping (WebKit.WKNavigationResponsePolicy) -> Swift.Void)
  func webViewWebContentProcessDidTerminate(webview: RoomBoxUtils.RBWKWebViewRecord)
  func webViewCanGoBackChange(webview: RoomBoxUtils.RBWKWebViewRecord)
}
extension RBWebViewRecordDelegate {
  public func webViewCanGoBackChange(webview: RoomBoxUtils.RBWKWebViewRecord)
  public func webView(webView: RoomBoxUtils.RBWKWebViewRecord, decidePolicyFor navigationResponse: WebKit.WKNavigationResponse, decisionHandler: @escaping (WebKit.WKNavigationResponsePolicy) -> Swift.Void)
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class RBWKWebView : WebKit.WKWebView {
  weak public var currentController: UIKit.UIViewController?
  weak public var delegate: RoomBoxUtils.RBWebViewDelegate?
  public var bridge: RoomBoxUtils.RBWebViewJavascriptBridge!
  @objc override dynamic public init(frame: CoreGraphics.CGRect, configuration: WebKit.WKWebViewConfiguration)
  public func clearDataCallback()
  @objc override dynamic public func observeValue(forKeyPath keyPath: Swift.String?, of object: Any?, change: [Foundation.NSKeyValueChangeKey : Any]?, context: Swift.UnsafeMutableRawPointer?)
  @objc deinit
}
extension RBWKWebView : WebKit.WKUIDelegate {
  @objc dynamic public func webView(_ webView: WebKit.WKWebView, runJavaScriptTextInputPanelWithPrompt prompt: Swift.String, defaultText: Swift.String?, initiatedByFrame frame: WebKit.WKFrameInfo, completionHandler: @escaping (Swift.String?) -> Swift.Void)
  @objc dynamic public func webView(_ webView: WebKit.WKWebView, runJavaScriptConfirmPanelWithMessage message: Swift.String, initiatedByFrame frame: WebKit.WKFrameInfo, completionHandler: @escaping (Swift.Bool) -> Swift.Void)
  @objc dynamic public func webView(_ webView: WebKit.WKWebView, runJavaScriptAlertPanelWithMessage message: Swift.String, initiatedByFrame frame: WebKit.WKFrameInfo, completionHandler: @escaping () -> Swift.Void)
  @objc dynamic public func webView(_ webView: WebKit.WKWebView, createWebViewWith configuration: WebKit.WKWebViewConfiguration, for navigationAction: WebKit.WKNavigationAction, windowFeatures: WebKit.WKWindowFeatures) -> WebKit.WKWebView?
}
extension RBWKWebView : WebKit.WKNavigationDelegate {
  @objc dynamic public func webView(_ webView: WebKit.WKWebView, decidePolicyFor navigationAction: WebKit.WKNavigationAction, decisionHandler: @escaping (WebKit.WKNavigationActionPolicy) -> Swift.Void)
  @objc dynamic public func webView(_ webView: WebKit.WKWebView, decidePolicyFor navigationResponse: WebKit.WKNavigationResponse, decisionHandler: @escaping (WebKit.WKNavigationResponsePolicy) -> Swift.Void)
  @objc dynamic public func webView(_ webView: WebKit.WKWebView, didStartProvisionalNavigation navigation: WebKit.WKNavigation!)
  @objc dynamic public func webViewWebContentProcessDidTerminate(_ webView: WebKit.WKWebView)
  @objc dynamic public func webView(_ webView: WebKit.WKWebView, didReceiveServerRedirectForProvisionalNavigation navigation: WebKit.WKNavigation!)
  @objc dynamic public func webView(_ webView: WebKit.WKWebView, didFailProvisionalNavigation navigation: WebKit.WKNavigation!, withError error: Swift.Error)
  @objc dynamic public func webView(_ webView: WebKit.WKWebView, didCommit navigation: WebKit.WKNavigation!)
  @objc dynamic public func webView(_ webView: WebKit.WKWebView, didFinish navigation: WebKit.WKNavigation!)
  @objc dynamic public func webView(_ webView: WebKit.WKWebView, didFail navigation: WebKit.WKNavigation!, withError error: Swift.Error)
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class RBWKWebViewRecord : WebKit.WKWebView {
  weak public var currentController: UIKit.UIViewController?
  weak public var delegate: RoomBoxUtils.RBWebViewRecordDelegate?
  public var bridgeRecord: RoomBoxUtils.RBWebViewJavascriptBridgeRecord!
  @objc override dynamic public init(frame: CoreGraphics.CGRect, configuration: WebKit.WKWebViewConfiguration)
  public func clearDataCallback()
  @objc override dynamic public func observeValue(forKeyPath keyPath: Swift.String?, of object: Any?, change: [Foundation.NSKeyValueChangeKey : Any]?, context: Swift.UnsafeMutableRawPointer?)
  @objc deinit
}
extension RBWKWebViewRecord : WebKit.WKUIDelegate {
  @objc dynamic public func webView(_ webView: WebKit.WKWebView, runJavaScriptTextInputPanelWithPrompt prompt: Swift.String, defaultText: Swift.String?, initiatedByFrame frame: WebKit.WKFrameInfo, completionHandler: @escaping (Swift.String?) -> Swift.Void)
  @objc dynamic public func webView(_ webView: WebKit.WKWebView, runJavaScriptConfirmPanelWithMessage message: Swift.String, initiatedByFrame frame: WebKit.WKFrameInfo, completionHandler: @escaping (Swift.Bool) -> Swift.Void)
  @objc dynamic public func webView(_ webView: WebKit.WKWebView, runJavaScriptAlertPanelWithMessage message: Swift.String, initiatedByFrame frame: WebKit.WKFrameInfo, completionHandler: @escaping () -> Swift.Void)
  @objc dynamic public func webView(_ webView: WebKit.WKWebView, createWebViewWith configuration: WebKit.WKWebViewConfiguration, for navigationAction: WebKit.WKNavigationAction, windowFeatures: WebKit.WKWindowFeatures) -> WebKit.WKWebView?
}
extension RBWKWebViewRecord : WebKit.WKNavigationDelegate {
  @objc dynamic public func webView(_ webView: WebKit.WKWebView, decidePolicyFor navigationAction: WebKit.WKNavigationAction, decisionHandler: @escaping (WebKit.WKNavigationActionPolicy) -> Swift.Void)
  @objc dynamic public func webView(_ webView: WebKit.WKWebView, decidePolicyFor navigationResponse: WebKit.WKNavigationResponse, decisionHandler: @escaping (WebKit.WKNavigationResponsePolicy) -> Swift.Void)
  @objc dynamic public func webView(_ webView: WebKit.WKWebView, didStartProvisionalNavigation navigation: WebKit.WKNavigation!)
  @objc dynamic public func webViewWebContentProcessDidTerminate(_ webView: WebKit.WKWebView)
  @objc dynamic public func webView(_ webView: WebKit.WKWebView, didReceiveServerRedirectForProvisionalNavigation navigation: WebKit.WKNavigation!)
  @objc dynamic public func webView(_ webView: WebKit.WKWebView, didFailProvisionalNavigation navigation: WebKit.WKNavigation!, withError error: Swift.Error)
  @objc dynamic public func webView(_ webView: WebKit.WKWebView, didCommit navigation: WebKit.WKNavigation!)
  @objc dynamic public func webView(_ webView: WebKit.WKWebView, didFinish navigation: WebKit.WKNavigation!)
  @objc dynamic public func webView(_ webView: WebKit.WKWebView, didFail navigation: WebKit.WKNavigation!, withError error: Swift.Error)
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers open class RBZoomingScrollView : UIKit.UIScrollView {
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
  @objc override dynamic open func layoutSubviews()
  open func setMaxMinZoomScalesForCurrentBounds()
  open func rbprepareForReuse()
  open func displayImage(_ image: UIKit.UIImage)
  open func displayImage(complete flag: Swift.Bool)
  open func displayImageFailure()
  open func handleDoubleTap(_ touchPoint: CoreGraphics.CGPoint)
}
extension RBZoomingScrollView : UIKit.UIScrollViewDelegate {
  @objc dynamic public func viewForZooming(in scrollView: UIKit.UIScrollView) -> UIKit.UIView?
  @objc dynamic public func scrollViewWillBeginZooming(_ scrollView: UIKit.UIScrollView, with view: UIKit.UIView?)
  @objc dynamic public func scrollViewDidZoom(_ scrollView: UIKit.UIScrollView)
}
@objc public protocol RoomBoxCategoryListViewDelegate : ObjectiveC.NSObjectProtocol {
  @objc func clickCategoryListViewItem(index: Swift.Int)
}
@_inheritsConvenienceInitializers @objc public class RoomBoxCategoryListView : UIKit.UIView {
  @objc public func configListView(arr: [Swift.String], delegate: RoomBoxUtils.RoomBoxCategoryListViewDelegate, defaultSelected: Swift.Int = 0)
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
@objc @_inheritsConvenienceInitializers public class RoomBoxDeviceBridge : ObjectiveC.NSObject {
  @objc public class func getDeviveName() -> Swift.String
  @objc public class func getSystemVersion() -> Swift.String
  @objc public class func getBatteryLevel() -> Swift.Int
  @objc deinit
  @objc override dynamic public init()
}
public enum RoomBoxDevice {
  case iPodTouch5
  case iPodTouch6
  case iPodTouch7
  case iPhone4
  case iPhone4s
  case iPhone5
  case iPhone5c
  case iPhone5s
  case iPhone6
  case iPhone6Plus
  case iPhone6s
  case iPhone6sPlus
  case iPhone7
  case iPhone7Plus
  case iPhoneSE
  case iPhone8
  case iPhone8Plus
  case iPhoneX
  case iPhoneXS
  case iPhoneXSMax
  case iPhoneXR
  case iPhone11
  case iPhone11Pro
  case iPhone11ProMax
  case iPhoneSE2
  case iPhone12
  case iPhone12Mini
  case iPhone12Pro
  case iPhone12ProMax
  case iPad2
  case iPad3
  case iPad4
  case iPadAir
  case iPadAir2
  case iPad5
  case iPad6
  case iPadAir3
  case iPad7
  case iPad8
  case iPadAir4
  case iPadMini
  case iPadMini2
  case iPadMini3
  case iPadMini4
  case iPadMini5
  case iPadPro9Inch
  case iPadPro12Inch
  case iPadPro12Inch2
  case iPadPro10Inch
  case iPadPro11Inch
  case iPadPro12Inch3
  case iPadPro11Inch2
  case iPadPro12Inch4
  case homePod
  indirect case simulator(RoomBoxUtils.RoomBoxDevice)
  case unknown(Swift.String)
  public static var current: RoomBoxUtils.RoomBoxDevice {
    get
  }
  public static var identifier: Swift.String
  public static func mapToDevice(identifier: Swift.String) -> RoomBoxUtils.RoomBoxDevice
  public static func realDevice(from RoomBoxDevice: RoomBoxUtils.RoomBoxDevice) -> RoomBoxUtils.RoomBoxDevice
  public var diagonal: Swift.Double {
    get
  }
  public var screenRatio: (width: Swift.Double, height: Swift.Double) {
    get
  }
  public static var allPods: [RoomBoxUtils.RoomBoxDevice] {
    get
  }
  public static var allPhones: [RoomBoxUtils.RoomBoxDevice] {
    get
  }
  public static var allPads: [RoomBoxUtils.RoomBoxDevice] {
    get
  }
  @available(*, deprecated, renamed: "allDevicesWithSensorHousing")
  public static var allXSeriesDevices: [RoomBoxUtils.RoomBoxDevice] {
    get
  }
  public static var allPlusSizedDevices: [RoomBoxUtils.RoomBoxDevice] {
    get
  }
  public static var allProDevices: [RoomBoxUtils.RoomBoxDevice] {
    get
  }
  public static var allMiniDevices: [RoomBoxUtils.RoomBoxDevice] {
    get
  }
  public static var allSimulatorPods: [RoomBoxUtils.RoomBoxDevice] {
    get
  }
  public static var allSimulatorPhones: [RoomBoxUtils.RoomBoxDevice] {
    get
  }
  public static var allSimulatorPads: [RoomBoxUtils.RoomBoxDevice] {
    get
  }
  public static var allSimulatorMiniDevices: [RoomBoxUtils.RoomBoxDevice] {
    get
  }
  @available(*, deprecated, renamed: "allSimulatorDevicesWithSensorHousing")
  public static var allSimulatorXSeriesDevices: [RoomBoxUtils.RoomBoxDevice] {
    get
  }
  public static var allSimulatorPlusSizedDevices: [RoomBoxUtils.RoomBoxDevice] {
    get
  }
  public static var allSimulatorProDevices: [RoomBoxUtils.RoomBoxDevice] {
    get
  }
  public var isPod: Swift.Bool {
    get
  }
  public var isPhone: Swift.Bool {
    get
  }
  public var isPad: Swift.Bool {
    get
  }
  public var isSimulator: Swift.Bool {
    get
  }
  public var realDevice: RoomBoxUtils.RoomBoxDevice {
    get
  }
  public var isZoomed: Swift.Bool? {
    get
  }
  public static var allTouchIDCapableDevices: [RoomBoxUtils.RoomBoxDevice] {
    get
  }
  public static var allFaceIDCapableDevices: [RoomBoxUtils.RoomBoxDevice] {
    get
  }
  public static var allBiometricAuthenticationCapableDevices: [RoomBoxUtils.RoomBoxDevice] {
    get
  }
  public var isTouchIDCapable: Swift.Bool {
    get
  }
  public var isFaceIDCapable: Swift.Bool {
    get
  }
  public var hasBiometricSensor: Swift.Bool {
    get
  }
  public static var allDevicesWithSensorHousing: [RoomBoxUtils.RoomBoxDevice] {
    get
  }
  public static var allSimulatorDevicesWithSensorHousing: [RoomBoxUtils.RoomBoxDevice] {
    get
  }
  public var hasSensorHousing: Swift.Bool {
    get
  }
  public static var allDevicesWithRoundedDisplayCorners: [RoomBoxUtils.RoomBoxDevice] {
    get
  }
  public var hasRoundedDisplayCorners: Swift.Bool {
    get
  }
  public static var allDevicesWith3dTouchSupport: [RoomBoxUtils.RoomBoxDevice] {
    get
  }
  public var has3dTouchSupport: Swift.Bool {
    get
  }
  public static var allDevicesWithWirelessChargingSupport: [RoomBoxUtils.RoomBoxDevice] {
    get
  }
  public var supportsWirelessCharging: Swift.Bool {
    get
  }
  public static var allDevicesWithALidarSensor: [RoomBoxUtils.RoomBoxDevice] {
    get
  }
  public var hasLidarSensor: Swift.Bool {
    get
  }
  public static var allRealDevices: [RoomBoxUtils.RoomBoxDevice] {
    get
  }
  public static var allSimulators: [RoomBoxUtils.RoomBoxDevice] {
    get
  }
  public func isOneOf(_ devices: [RoomBoxUtils.RoomBoxDevice]) -> Swift.Bool
  public var name: Swift.String? {
    get
  }
  public var systemName: Swift.String? {
    get
  }
  public var systemVersion: Swift.String? {
    get
  }
  public var model: Swift.String? {
    get
  }
  public var localizedModel: Swift.String? {
    get
  }
  public var ppi: Swift.Int? {
    get
  }
  public var isGuidedAccessSessionActive: Swift.Bool {
    get
  }
  public var screenBrightness: Swift.Int {
    get
  }
}
extension RoomBoxDevice : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
  public var safeDescription: Swift.String {
    get
  }
}
extension RoomBoxDevice : Swift.Equatable {
  public static func == (lhs: RoomBoxUtils.RoomBoxDevice, rhs: RoomBoxUtils.RoomBoxDevice) -> Swift.Bool
}
@available(iOS 8.0, watchOS 4.0, *)
extension RoomBoxDevice {
  public enum BatteryState : Swift.CustomStringConvertible, Swift.Equatable {
    case full
    case charging(Swift.Int)
    case unplugged(Swift.Int)
    public var lowPowerMode: Swift.Bool {
      get
    }
    public var description: Swift.String {
      get
    }
  }
  public var batteryState: RoomBoxUtils.RoomBoxDevice.BatteryState? {
    get
  }
  public var batteryLevel: Swift.Int? {
    get
  }
}
@available(iOS 8.0, watchOS 4.0, *)
extension RoomBoxDevice.BatteryState : Swift.Comparable {
  public static func == (lhs: RoomBoxUtils.RoomBoxDevice.BatteryState, rhs: RoomBoxUtils.RoomBoxDevice.BatteryState) -> Swift.Bool
  public static func < (lhs: RoomBoxUtils.RoomBoxDevice.BatteryState, rhs: RoomBoxUtils.RoomBoxDevice.BatteryState) -> Swift.Bool
}
extension RoomBoxDevice {
  public enum Orientation {
    case landscape
    case portrait
    public static func == (a: RoomBoxUtils.RoomBoxDevice.Orientation, b: RoomBoxUtils.RoomBoxDevice.Orientation) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public var orientation: RoomBoxUtils.RoomBoxDevice.Orientation {
    get
  }
}
extension RoomBoxDevice {
  public static var volumeTotalCapacity: Swift.Int? {
    get
  }
  public static var volumeAvailableCapacity: Swift.Int? {
    get
  }
  @available(iOS 11.0, *)
  public static var volumeAvailableCapacityForImportantUsage: Swift.Int64? {
    get
  }
  @available(iOS 11.0, *)
  public static var volumeAvailableCapacityForOpportunisticUsage: Swift.Int64? {
    get
  }
  @available(iOS 11.0, *)
  public static var volumes: [Foundation.URLResourceKey : Swift.Int64]? {
    get
  }
}
extension RoomBoxDevice {
  public struct ApplePencilSupport : Swift.OptionSet {
    public var rawValue: Swift.UInt
    public init(rawValue: Swift.UInt)
    public static let firstGeneration: RoomBoxUtils.RoomBoxDevice.ApplePencilSupport
    public static let secondGeneration: RoomBoxUtils.RoomBoxDevice.ApplePencilSupport
    public typealias Element = RoomBoxUtils.RoomBoxDevice.ApplePencilSupport
    public typealias ArrayLiteralElement = RoomBoxUtils.RoomBoxDevice.ApplePencilSupport
    public typealias RawValue = Swift.UInt
  }
  public static var allApplePencilCapableDevices: [RoomBoxUtils.RoomBoxDevice] {
    get
  }
  public var applePencilSupport: RoomBoxUtils.RoomBoxDevice.ApplePencilSupport {
    get
  }
}
extension RoomBoxDevice {
  public enum CameraType {
    @available(*, deprecated, renamed: "wide")
    case normal
    case wide
    case telephoto
    case ultraWide
    public static func == (a: RoomBoxUtils.RoomBoxDevice.CameraType, b: RoomBoxUtils.RoomBoxDevice.CameraType) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public var cameras: [RoomBoxUtils.RoomBoxDevice.CameraType] {
    get
  }
  public static var allDevicesWithCamera: [RoomBoxUtils.RoomBoxDevice] {
    get
  }
  @available(*, deprecated, renamed: "allDevicesWithWideCamera")
  public static var allDevicesWithNormalCamera: [RoomBoxUtils.RoomBoxDevice] {
    get
  }
  public static var allDevicesWithWideCamera: [RoomBoxUtils.RoomBoxDevice] {
    get
  }
  public static var allDevicesWithTelephotoCamera: [RoomBoxUtils.RoomBoxDevice] {
    get
  }
  public static var allDevicesWithUltraWideCamera: [RoomBoxUtils.RoomBoxDevice] {
    get
  }
  public var hasCamera: Swift.Bool {
    get
  }
  @available(*, deprecated, renamed: "hasWideCamera")
  public var hasNormalCamera: Swift.Bool {
    get
  }
  public var hasWideCamera: Swift.Bool {
    get
  }
  public var hasTelephotoCamera: Swift.Bool {
    get
  }
  public var hasUltraWideCamera: Swift.Bool {
    get
  }
}
public enum FontWeightStyle {
  case medium
  case semibold
  case light
  case tralight
  case regular
  case thin
  public static func == (a: RoomBoxUtils.FontWeightStyle, b: RoomBoxUtils.FontWeightStyle) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
extension UIFont {
  public class func pingfangSC(weight: RoomBoxUtils.FontWeightStyle, size: CoreGraphics.CGFloat) -> UIKit.UIFont
}
public let RoomBoxKeychainAccessErrorDomain: Swift.String
public enum RoomBoxItemClass {
  case genericPassword
  case internetPassword
}
public enum RoomBoxProtocolType {
  case ftp
  case ftpAccount
  case http
  case irc
  case nntp
  case pop3
  case smtp
  case socks
  case imap
  case ldap
  case appleTalk
  case afp
  case telnet
  case ssh
  case ftps
  case https
  case httpProxy
  case httpsProxy
  case ftpProxy
  case smb
  case rtsp
  case rtspProxy
  case daap
  case eppc
  case ipp
  case nntps
  case ldaps
  case telnetS
  case imaps
  case ircs
  case pop3S
}
public enum RoomBoxAuthenticationType {
  case ntlm
  case msn
  case dpa
  case rpa
  case httpBasic
  case httpDigest
  case htmlForm
  case `default`
}
public enum RoomBoxAccessibility {
  case whenUnlocked
  case afterFirstUnlock
  @available(macCatalyst, unavailable)
  case always
  @available(iOS 8.0, OSX 10.10, *)
  case whenPasscodeSetThisDeviceOnly
  case whenUnlockedThisDeviceOnly
  case afterFirstUnlockThisDeviceOnly
  @available(macCatalyst, unavailable)
  case alwaysThisDeviceOnly
}
public enum RoomBoxAuthenticationUI {
  case allow
  case fail
  case skip
  public static func == (a: RoomBoxUtils.RoomBoxAuthenticationUI, b: RoomBoxUtils.RoomBoxAuthenticationUI) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
@available(iOS 9.0, OSX 10.11, *)
extension RoomBoxAuthenticationUI {
  public var rawValue: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
}
public struct RoomBoxAuthenticationPolicy : Swift.OptionSet {
  @available(iOS 8.0, OSX 10.10, watchOS 2.0, tvOS 8.0, *)
  public static let userPresence: RoomBoxUtils.RoomBoxAuthenticationPolicy
  @available(iOS 11.3, OSX 10.13.4, watchOS 4.3, tvOS 11.3, *)
  public static let biometryAny: RoomBoxUtils.RoomBoxAuthenticationPolicy
  @available(iOS, introduced: 9.0, deprecated: 11.3, renamed: "biometryAny")
  @available(OSX, introduced: 10.12.1, deprecated: 10.13.4, renamed: "biometryAny")
  @available(watchOS, introduced: 2.0, deprecated: 4.3, renamed: "biometryAny")
  @available(tvOS, introduced: 9.0, deprecated: 11.3, renamed: "biometryAny")
  public static let touchIDAny: RoomBoxUtils.RoomBoxAuthenticationPolicy
  @available(iOS 11.3, OSX 10.13, watchOS 4.3, tvOS 11.3, *)
  public static let biometryCurrentSet: RoomBoxUtils.RoomBoxAuthenticationPolicy
  @available(iOS, introduced: 9.0, deprecated: 11.3, renamed: "biometryCurrentSet")
  @available(OSX, introduced: 10.12.1, deprecated: 10.13.4, renamed: "biometryCurrentSet")
  @available(watchOS, introduced: 2.0, deprecated: 4.3, renamed: "biometryCurrentSet")
  @available(tvOS, introduced: 9.0, deprecated: 11.3, renamed: "biometryCurrentSet")
  public static let touchIDCurrentSet: RoomBoxUtils.RoomBoxAuthenticationPolicy
  @available(iOS 9.0, OSX 10.11, watchOS 2.0, tvOS 9.0, *)
  public static let devicePasscode: RoomBoxUtils.RoomBoxAuthenticationPolicy
  @available(OSX 10.15, *)
  @available(iOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  public static let watch: RoomBoxUtils.RoomBoxAuthenticationPolicy
  @available(iOS 9.0, OSX 10.12.1, watchOS 2.0, tvOS 9.0, *)
  public static let or: RoomBoxUtils.RoomBoxAuthenticationPolicy
  @available(iOS 9.0, OSX 10.12.1, watchOS 2.0, tvOS 9.0, *)
  public static let and: RoomBoxUtils.RoomBoxAuthenticationPolicy
  @available(iOS 9.0, OSX 10.12.1, watchOS 2.0, tvOS 9.0, *)
  public static let privateKeyUsage: RoomBoxUtils.RoomBoxAuthenticationPolicy
  @available(iOS 9.0, OSX 10.12.1, watchOS 2.0, tvOS 9.0, *)
  public static let applicationPassword: RoomBoxUtils.RoomBoxAuthenticationPolicy
  public let rawValue: Swift.UInt
  public init(rawValue: Swift.UInt)
  public typealias Element = RoomBoxUtils.RoomBoxAuthenticationPolicy
  public typealias ArrayLiteralElement = RoomBoxUtils.RoomBoxAuthenticationPolicy
  public typealias RawValue = Swift.UInt
}
public struct Attributes {
  public var `class`: Swift.String? {
    get
  }
  public var data: Foundation.Data? {
    get
  }
  public var ref: Foundation.Data? {
    get
  }
  public var persistentRef: Foundation.Data? {
    get
  }
  public var accessible: Swift.String? {
    get
  }
  public var accessControl: Security.SecAccessControl? {
    get
  }
  public var accessGroup: Swift.String? {
    get
  }
  public var synchronizable: Swift.Bool? {
    get
  }
  public var creationDate: Foundation.Date? {
    get
  }
  public var modificationDate: Foundation.Date? {
    get
  }
  public var attributeDescription: Swift.String? {
    get
  }
  public var comment: Swift.String? {
    get
  }
  public var creator: Swift.String? {
    get
  }
  public var type: Swift.String? {
    get
  }
  public var label: Swift.String? {
    get
  }
  public var isInvisible: Swift.Bool? {
    get
  }
  public var isNegative: Swift.Bool? {
    get
  }
  public var account: Swift.String? {
    get
  }
  public var service: Swift.String? {
    get
  }
  public var generic: Foundation.Data? {
    get
  }
  public var securityDomain: Swift.String? {
    get
  }
  public var server: Swift.String? {
    get
  }
  public var `protocol`: Swift.String? {
    get
  }
  public var authenticationType: Swift.String? {
    get
  }
  public var port: Swift.Int? {
    get
  }
  public var path: Swift.String? {
    get
  }
  public subscript(key: Swift.String) -> Any? {
    get
  }
}
@_hasMissingDesignatedInitializers final public class RoomBoxKeychain {
  final public var itemClass: RoomBoxUtils.RoomBoxItemClass {
    get
  }
  final public var service: Swift.String {
    get
  }
  final public var accessGroup: Swift.String? {
    get
  }
  final public var server: Foundation.URL {
    get
  }
  final public var protocolType: RoomBoxUtils.RoomBoxProtocolType {
    get
  }
  final public var authenticationType: RoomBoxUtils.RoomBoxAuthenticationType {
    get
  }
  final public var accessibility: RoomBoxUtils.RoomBoxAccessibility {
    get
  }
  @available(iOS 8.0, OSX 10.10, *)
  @available(watchOS, unavailable)
  final public var authenticationPolicy: RoomBoxUtils.RoomBoxAuthenticationPolicy? {
    get
  }
  final public var synchronizable: Swift.Bool {
    get
  }
  final public var label: Swift.String? {
    get
  }
  final public var comment: Swift.String? {
    get
  }
  @available(iOS 8.0, OSX 10.10, *)
  @available(watchOS, unavailable)
  final public var authenticationPrompt: Swift.String? {
    get
  }
  @available(iOS 9.0, OSX 10.11, *)
  final public var RoomBoxAuthenticationUI: RoomBoxUtils.RoomBoxAuthenticationUI {
    get
  }
  @available(iOS 9.0, OSX 10.11, *)
  final public var authenticationContext: LocalAuthentication.LAContext? {
    get
  }
  convenience public init()
  convenience public init(service: Swift.String)
  convenience public init(accessGroup: Swift.String)
  convenience public init(service: Swift.String, accessGroup: Swift.String)
  convenience public init(server: Swift.String, protocolType: RoomBoxUtils.RoomBoxProtocolType, accessGroup: Swift.String? = nil, authenticationType: RoomBoxUtils.RoomBoxAuthenticationType = .default)
  convenience public init(server: Foundation.URL, protocolType: RoomBoxUtils.RoomBoxProtocolType, accessGroup: Swift.String? = nil, authenticationType: RoomBoxUtils.RoomBoxAuthenticationType = .default)
  final public func accessibility(_ accessibility: RoomBoxUtils.RoomBoxAccessibility) -> RoomBoxUtils.RoomBoxKeychain
  @available(iOS 8.0, OSX 10.10, *)
  @available(watchOS, unavailable)
  final public func accessibility(_ accessibility: RoomBoxUtils.RoomBoxAccessibility, authenticationPolicy: RoomBoxUtils.RoomBoxAuthenticationPolicy) -> RoomBoxUtils.RoomBoxKeychain
  final public func synchronizable(_ synchronizable: Swift.Bool) -> RoomBoxUtils.RoomBoxKeychain
  final public func label(_ label: Swift.String) -> RoomBoxUtils.RoomBoxKeychain
  final public func comment(_ comment: Swift.String) -> RoomBoxUtils.RoomBoxKeychain
  final public func attributes(_ attributes: [Swift.String : Any]) -> RoomBoxUtils.RoomBoxKeychain
  @available(iOS 8.0, OSX 10.10, *)
  @available(watchOS, unavailable)
  final public func authenticationPrompt(_ authenticationPrompt: Swift.String) -> RoomBoxUtils.RoomBoxKeychain
  @available(iOS 9.0, OSX 10.11, *)
  final public func RoomBoxAuthenticationUI(_ authenticationUI: RoomBoxUtils.RoomBoxAuthenticationUI) -> RoomBoxUtils.RoomBoxKeychain
  @available(iOS 9.0, OSX 10.11, *)
  final public func authenticationContext(_ authenticationContext: LocalAuthentication.LAContext) -> RoomBoxUtils.RoomBoxKeychain
  final public func get(_ key: Swift.String, ignoringAttributeSynchronizable: Swift.Bool = true) throws -> Swift.String?
  final public func getString(_ key: Swift.String, ignoringAttributeSynchronizable: Swift.Bool = true) throws -> Swift.String?
  final public func getData(_ key: Swift.String, ignoringAttributeSynchronizable: Swift.Bool = true) throws -> Foundation.Data?
  final public func get<T>(_ key: Swift.String, ignoringAttributeSynchronizable: Swift.Bool = true, handler: (RoomBoxUtils.Attributes?) -> T) throws -> T
  final public func set(_ value: Swift.String, key: Swift.String, ignoringAttributeSynchronizable: Swift.Bool = true) throws
  final public func set(_ value: Foundation.Data, key: Swift.String, ignoringAttributeSynchronizable: Swift.Bool = true) throws
  final public subscript(key: Swift.String) -> Swift.String? {
    get
    set
  }
  final public subscript(string key: Swift.String) -> Swift.String? {
    get
    set
  }
  final public subscript(data key: Swift.String) -> Foundation.Data? {
    get
    set
  }
  final public subscript(attributes key: Swift.String) -> RoomBoxUtils.Attributes? {
    get
  }
  final public func remove(_ key: Swift.String, ignoringAttributeSynchronizable: Swift.Bool = true) throws
  final public func removeAll() throws
  final public func contains(_ key: Swift.String, withoutAuthenticationUI: Swift.Bool = false) throws -> Swift.Bool
  final public class func allKeys(_ itemClass: RoomBoxUtils.RoomBoxItemClass) -> [(Swift.String, Swift.String)]
  final public func allKeys() -> [Swift.String]
  final public class func allItems(_ itemClass: RoomBoxUtils.RoomBoxItemClass) -> [[Swift.String : Any]]
  final public func allItems() -> [[Swift.String : Any]]
  @available(iOS 8.0, *)
  final public func getSharedPassword(_ completion: @escaping (Swift.String?, Swift.String?, Swift.Error?) -> () = { account, password, error -> () in })
  @available(iOS 8.0, *)
  final public func getSharedPassword(_ account: Swift.String, completion: @escaping (Swift.String?, Swift.Error?) -> () = { password, error -> () in })
  @available(iOS 8.0, *)
  final public func setSharedPassword(_ password: Swift.String, account: Swift.String, completion: @escaping (Swift.Error?) -> () = { e -> () in })
  @available(iOS 8.0, *)
  final public func removeSharedPassword(_ account: Swift.String, completion: @escaping (Swift.Error?) -> () = { e -> () in })
  @available(iOS 8.0, *)
  final public class func requestSharedWebCredential(_ completion: @escaping ([[Swift.String : Swift.String]], Swift.Error?) -> () = { credentials, error -> () in })
  @available(iOS 8.0, *)
  final public class func requestSharedWebCredential(domain: Swift.String, completion: @escaping ([[Swift.String : Swift.String]], Swift.Error?) -> () = { credentials, error -> () in })
  @available(iOS 8.0, *)
  final public class func requestSharedWebCredential(domain: Swift.String, account: Swift.String, completion: @escaping ([[Swift.String : Swift.String]], Swift.Error?) -> () = { credentials, error -> () in })
  @available(iOS 8.0, *)
  final public class func generatePassword() -> Swift.String
  @objc deinit
}
extension RoomBoxKeychain : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  final public var description: Swift.String {
    get
  }
  final public var debugDescription: Swift.String {
    get
  }
}
extension Attributes : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension RoomBoxItemClass : Swift.RawRepresentable, Swift.CustomStringConvertible {
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
}
extension RoomBoxProtocolType : Swift.RawRepresentable, Swift.CustomStringConvertible {
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
}
extension RoomBoxAuthenticationType : Swift.RawRepresentable, Swift.CustomStringConvertible {
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
}
extension RoomBoxAccessibility : Swift.RawRepresentable, Swift.CustomStringConvertible {
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
}
public enum Status : Darwin.OSStatus, Swift.Error {
  case success
  case unimplemented
  case diskFull
  case io
  case opWr
  case param
  case wrPerm
  case allocate
  case userCanceled
  case badReq
  case internalComponent
  case notAvailable
  case readOnly
  case authFailed
  case noSuchKeychain
  case invalidKeychain
  case duplicateKeychain
  case duplicateCallback
  case invalidCallback
  case duplicateItem
  case itemNotFound
  case bufferTooSmall
  case dataTooLarge
  case noSuchAttr
  case invalidItemRef
  case invalidSearchRef
  case noSuchClass
  case noDefaultKeychain
  case interactionNotAllowed
  case readOnlyAttr
  case wrongSecVersion
  case keySizeNotAllowed
  case noStorageModule
  case noCertificateModule
  case noPolicyModule
  case interactionRequired
  case dataNotAvailable
  case dataNotModifiable
  case createChainFailed
  case invalidPrefsDomain
  case inDarkWake
  case aclNotSimple
  case policyNotFound
  case invalidTrustSetting
  case noAccessForItem
  case invalidOwnerEdit
  case trustNotAvailable
  case unsupportedFormat
  case unknownFormat
  case keyIsSensitive
  case multiplePrivKeys
  case passphraseRequired
  case invalidPasswordRef
  case invalidTrustSettings
  case noTrustSettings
  case pkcs12VerifyFailure
  case invalidCertificate
  case notSigner
  case policyDenied
  case invalidKey
  case decode
  case `internal`
  case unsupportedAlgorithm
  case unsupportedOperation
  case unsupportedPadding
  case itemInvalidKey
  case itemInvalidKeyType
  case itemInvalidValue
  case itemClassMissing
  case itemMatchUnsupported
  case useItemListUnsupported
  case useKeychainUnsupported
  case useKeychainListUnsupported
  case returnDataUnsupported
  case returnAttributesUnsupported
  case returnRefUnsupported
  case returnPersitentRefUnsupported
  case valueRefUnsupported
  case valuePersistentRefUnsupported
  case returnMissingPointer
  case matchLimitUnsupported
  case itemIllegalQuery
  case waitForCallback
  case missingEntitlement
  case upgradePending
  case mpSignatureInvalid
  case otrTooOld
  case otrIDTooNew
  case serviceNotAvailable
  case insufficientClientID
  case deviceReset
  case deviceFailed
  case appleAddAppACLSubject
  case applePublicKeyIncomplete
  case appleSignatureMismatch
  case appleInvalidKeyStartDate
  case appleInvalidKeyEndDate
  case conversionError
  case appleSSLv2Rollback
  case quotaExceeded
  case fileTooBig
  case invalidDatabaseBlob
  case invalidKeyBlob
  case incompatibleDatabaseBlob
  case incompatibleKeyBlob
  case hostNameMismatch
  case unknownCriticalExtensionFlag
  case noBasicConstraints
  case noBasicConstraintsCA
  case invalidAuthorityKeyID
  case invalidSubjectKeyID
  case invalidKeyUsageForPolicy
  case invalidExtendedKeyUsage
  case invalidIDLinkage
  case pathLengthConstraintExceeded
  case invalidRoot
  case crlExpired
  case crlNotValidYet
  case crlNotFound
  case crlServerDown
  case crlBadURI
  case unknownCertExtension
  case unknownCRLExtension
  case crlNotTrusted
  case crlPolicyFailed
  case idpFailure
  case smimeEmailAddressesNotFound
  case smimeBadExtendedKeyUsage
  case smimeBadKeyUsage
  case smimeKeyUsageNotCritical
  case smimeNoEmailAddress
  case smimeSubjAltNameNotCritical
  case sslBadExtendedKeyUsage
  case ocspBadResponse
  case ocspBadRequest
  case ocspUnavailable
  case ocspStatusUnrecognized
  case endOfData
  case incompleteCertRevocationCheck
  case networkFailure
  case ocspNotTrustedToAnchor
  case recordModified
  case ocspSignatureError
  case ocspNoSigner
  case ocspResponderMalformedReq
  case ocspResponderInternalError
  case ocspResponderTryLater
  case ocspResponderSignatureRequired
  case ocspResponderUnauthorized
  case ocspResponseNonceMismatch
  case codeSigningBadCertChainLength
  case codeSigningNoBasicConstraints
  case codeSigningBadPathLengthConstraint
  case codeSigningNoExtendedKeyUsage
  case codeSigningDevelopment
  case resourceSignBadCertChainLength
  case resourceSignBadExtKeyUsage
  case trustSettingDeny
  case invalidSubjectName
  case unknownQualifiedCertStatement
  case mobileMeRequestQueued
  case mobileMeRequestRedirected
  case mobileMeServerError
  case mobileMeServerNotAvailable
  case mobileMeServerAlreadyExists
  case mobileMeServerServiceErr
  case mobileMeRequestAlreadyPending
  case mobileMeNoRequestPending
  case mobileMeCSRVerifyFailure
  case mobileMeFailedConsistencyCheck
  case notInitialized
  case invalidHandleUsage
  case pvcReferentNotFound
  case functionIntegrityFail
  case internalError
  case memoryError
  case invalidData
  case mdsError
  case invalidPointer
  case selfCheckFailed
  case functionFailed
  case moduleManifestVerifyFailed
  case invalidGUID
  case invalidHandle
  case invalidDBList
  case invalidPassthroughID
  case invalidNetworkAddress
  case crlAlreadySigned
  case invalidNumberOfFields
  case verificationFailure
  case unknownTag
  case invalidSignature
  case invalidName
  case invalidCertificateRef
  case invalidCertificateGroup
  case tagNotFound
  case invalidQuery
  case invalidValue
  case callbackFailed
  case aclDeleteFailed
  case aclReplaceFailed
  case aclAddFailed
  case aclChangeFailed
  case invalidAccessCredentials
  case invalidRecord
  case invalidACL
  case invalidSampleValue
  case incompatibleVersion
  case privilegeNotGranted
  case invalidScope
  case pvcAlreadyConfigured
  case invalidPVC
  case emmLoadFailed
  case emmUnloadFailed
  case addinLoadFailed
  case invalidKeyRef
  case invalidKeyHierarchy
  case addinUnloadFailed
  case libraryReferenceNotFound
  case invalidAddinFunctionTable
  case invalidServiceMask
  case moduleNotLoaded
  case invalidSubServiceID
  case attributeNotInContext
  case moduleManagerInitializeFailed
  case moduleManagerNotFound
  case eventNotificationCallbackNotFound
  case inputLengthError
  case outputLengthError
  case privilegeNotSupported
  case deviceError
  case attachHandleBusy
  case notLoggedIn
  case algorithmMismatch
  case keyUsageIncorrect
  case keyBlobTypeIncorrect
  case keyHeaderInconsistent
  case unsupportedKeyFormat
  case unsupportedKeySize
  case invalidKeyUsageMask
  case unsupportedKeyUsageMask
  case invalidKeyAttributeMask
  case unsupportedKeyAttributeMask
  case invalidKeyLabel
  case unsupportedKeyLabel
  case invalidKeyFormat
  case unsupportedVectorOfBuffers
  case invalidInputVector
  case invalidOutputVector
  case invalidContext
  case invalidAlgorithm
  case invalidAttributeKey
  case missingAttributeKey
  case invalidAttributeInitVector
  case missingAttributeInitVector
  case invalidAttributeSalt
  case missingAttributeSalt
  case invalidAttributePadding
  case missingAttributePadding
  case invalidAttributeRandom
  case missingAttributeRandom
  case invalidAttributeSeed
  case missingAttributeSeed
  case invalidAttributePassphrase
  case missingAttributePassphrase
  case invalidAttributeKeyLength
  case missingAttributeKeyLength
  case invalidAttributeBlockSize
  case missingAttributeBlockSize
  case invalidAttributeOutputSize
  case missingAttributeOutputSize
  case invalidAttributeRounds
  case missingAttributeRounds
  case invalidAlgorithmParms
  case missingAlgorithmParms
  case invalidAttributeLabel
  case missingAttributeLabel
  case invalidAttributeKeyType
  case missingAttributeKeyType
  case invalidAttributeMode
  case missingAttributeMode
  case invalidAttributeEffectiveBits
  case missingAttributeEffectiveBits
  case invalidAttributeStartDate
  case missingAttributeStartDate
  case invalidAttributeEndDate
  case missingAttributeEndDate
  case invalidAttributeVersion
  case missingAttributeVersion
  case invalidAttributePrime
  case missingAttributePrime
  case invalidAttributeBase
  case missingAttributeBase
  case invalidAttributeSubprime
  case missingAttributeSubprime
  case invalidAttributeIterationCount
  case missingAttributeIterationCount
  case invalidAttributeDLDBHandle
  case missingAttributeDLDBHandle
  case invalidAttributeAccessCredentials
  case missingAttributeAccessCredentials
  case invalidAttributePublicKeyFormat
  case missingAttributePublicKeyFormat
  case invalidAttributePrivateKeyFormat
  case missingAttributePrivateKeyFormat
  case invalidAttributeSymmetricKeyFormat
  case missingAttributeSymmetricKeyFormat
  case invalidAttributeWrappedKeyFormat
  case missingAttributeWrappedKeyFormat
  case stagedOperationInProgress
  case stagedOperationNotStarted
  case verifyFailed
  case querySizeUnknown
  case blockSizeMismatch
  case publicKeyInconsistent
  case deviceVerifyFailed
  case invalidLoginName
  case alreadyLoggedIn
  case invalidDigestAlgorithm
  case invalidCRLGroup
  case certificateCannotOperate
  case certificateExpired
  case certificateNotValidYet
  case certificateRevoked
  case certificateSuspended
  case insufficientCredentials
  case invalidAction
  case invalidAuthority
  case verifyActionFailed
  case invalidCertAuthority
  case invaldCRLAuthority
  case invalidCRLEncoding
  case invalidCRLType
  case invalidCRL
  case invalidFormType
  case invalidID
  case invalidIdentifier
  case invalidIndex
  case invalidPolicyIdentifiers
  case invalidTimeString
  case invalidReason
  case invalidRequestInputs
  case invalidResponseVector
  case invalidStopOnPolicy
  case invalidTuple
  case multipleValuesUnsupported
  case notTrusted
  case noDefaultAuthority
  case rejectedForm
  case requestLost
  case requestRejected
  case unsupportedAddressType
  case unsupportedService
  case invalidTupleGroup
  case invalidBaseACLs
  case invalidTupleCredendtials
  case invalidEncoding
  case invalidValidityPeriod
  case invalidRequestor
  case requestDescriptor
  case invalidBundleInfo
  case invalidCRLIndex
  case noFieldValues
  case unsupportedFieldFormat
  case unsupportedIndexInfo
  case unsupportedLocality
  case unsupportedNumAttributes
  case unsupportedNumIndexes
  case unsupportedNumRecordTypes
  case fieldSpecifiedMultiple
  case incompatibleFieldFormat
  case invalidParsingModule
  case databaseLocked
  case datastoreIsOpen
  case missingValue
  case unsupportedQueryLimits
  case unsupportedNumSelectionPreds
  case unsupportedOperator
  case invalidDBLocation
  case invalidAccessRequest
  case invalidIndexInfo
  case invalidNewOwner
  case invalidModifyMode
  case missingRequiredExtension
  case extendedKeyUsageNotCritical
  case timestampMissing
  case timestampInvalid
  case timestampNotTrusted
  case timestampServiceNotAvailable
  case timestampBadAlg
  case timestampBadRequest
  case timestampBadDataFormat
  case timestampTimeNotAvailable
  case timestampUnacceptedPolicy
  case timestampUnacceptedExtension
  case timestampAddInfoNotAvailable
  case timestampSystemFailure
  case signingTimeMissing
  case timestampRejection
  case timestampWaiting
  case timestampRevocationWarning
  case timestampRevocationNotification
  case unexpectedError
}
extension Status : Swift.RawRepresentable, Swift.CustomStringConvertible {
  public init(status: Darwin.OSStatus)
  public var description: Swift.String {
    get
  }
  public typealias RawValue = Darwin.OSStatus
  public init?(rawValue: Darwin.OSStatus)
  public var rawValue: Darwin.OSStatus {
    get
  }
}
extension Status : Foundation.CustomNSError {
  public static let errorDomain: Swift.String
  public var errorCode: Swift.Int {
    get
  }
  public var errorUserInfo: [Swift.String : Any] {
    get
  }
}
@objc @_inheritsConvenienceInitializers public class RoomBoxKeychainAccess : ObjectiveC.NSObject {
  @objc public class func saveUUIDToKeyChain()
  @objc public class func readUUIDFromKeyChain() -> Swift.String
  @objc deinit
  @objc override dynamic public init()
}
extension CharacterSet {
  public static let rbURLQueryAllowed: Foundation.CharacterSet
}
extension String {
  public var base64Decoded: Swift.String? {
    get
  }
  public var base64Encoded: Swift.String? {
    get
  }
  public func ends(with suffix: Swift.String, caseSensitive: Swift.Bool = true) -> Swift.Bool
  public var int: Swift.Int? {
    get
  }
  public var urlDecoded: Swift.String {
    get
  }
  public var urlEncoded: Swift.String {
    get
  }
  public var isBlank: Swift.Bool {
    get
  }
  public func convertToDictionary() -> [Swift.String : Any]?
}
extension String {
  @inlinable public var bytes: Swift.Array<Swift.UInt8> {
    get {
    data(using: String.Encoding.utf8, allowLossyConversion: true)?.bytes ?? Array(utf8)
  }
  }
  @inlinable public func md5() -> Swift.String {
    self.bytes.md5().toHexString()
  }
  @inlinable public func sha1() -> Swift.String {
    self.bytes.sha1().toHexString()
  }
  @inlinable public func sha224() -> Swift.String {
    self.bytes.sha224().toHexString()
  }
  @inlinable public func sha256() -> Swift.String {
    self.bytes.sha256().toHexString()
  }
  @inlinable public func sha384() -> Swift.String {
    self.bytes.sha384().toHexString()
  }
  @inlinable public func sha512() -> Swift.String {
    self.bytes.sha512().toHexString()
  }
  @inlinable public func sha3(_ variant: RoomBoxUtils.RBSHA3.Variant) -> Swift.String {
    self.bytes.sha3(variant).toHexString()
  }
  @inlinable public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.String {
    self.bytes.crc32(seed: seed, reflect: reflect).bytes().toHexString()
  }
  @inlinable public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.String {
    self.bytes.crc32c(seed: seed, reflect: reflect).bytes().toHexString()
  }
  @inlinable public func crc16(seed: Swift.UInt16? = nil) -> Swift.String {
    self.bytes.crc16(seed: seed).bytes().toHexString()
  }
  @inlinable public func encrypt(cipher: RoomBoxUtils.RBCipher) throws -> Swift.String {
    try self.bytes.encrypt(cipher: cipher).toHexString()
  }
  @inlinable public func encryptToBase64(cipher: RoomBoxUtils.RBCipher) throws -> Swift.String {
    try self.bytes.encrypt(cipher: cipher).toBase64()
  }
  @inlinable public func authenticate<A>(with authenticator: A) throws -> Swift.String where A : RoomBoxUtils.RBAuthenticator {
    try self.bytes.authenticate(with: authenticator).toHexString()
  }
}
extension String {
  public func decryptBase64ToString(cipher: RoomBoxUtils.RBCipher) throws -> Swift.String
  public func decryptBase64(cipher: RoomBoxUtils.RBCipher) throws -> Swift.Array<Swift.UInt8>
}
extension String : RoomBoxUtils.RBNamespaceProtocol {
  public typealias RBCompatibleType = Swift.String
}
extension UIButton {
  @objc dynamic public func set(image anImage: UIKit.UIImage?, title: Swift.String, titlePosition: UIKit.UIView.ContentMode, additionalSpacing: CoreGraphics.CGFloat, state: UIKit.UIControl.State)
}
extension UIColor {
  convenience public init?(hexString: Swift.String, transparency: CoreGraphics.CGFloat = 1)
  public var hexString: Swift.String? {
    get
  }
}
@available(iOS 8.0, *)
extension UILayoutSupport {
  public var rb_snp: RoomBoxUtils.RBConstraintLayoutSupportDSL {
    get
  }
}
extension UInt32 {
  @_specialize(exported: false, kind: full, where T == Swift.ArraySlice<Swift.UInt8>)
  @inlinable internal init<T>(bytes: T, fromIndex index: T.Index) where T : Swift.Collection, T.Element == Swift.UInt8, T.Index == Swift.Int {
    if bytes.isEmpty {
      self = 0
      return
    }

    let count = bytes.count

    let val0 = count > 0 ? UInt32(bytes[index.advanced(by: 0)]) << 24 : 0
    let val1 = count > 1 ? UInt32(bytes[index.advanced(by: 1)]) << 16 : 0
    let val2 = count > 2 ? UInt32(bytes[index.advanced(by: 2)]) << 8 : 0
    let val3 = count > 3 ? UInt32(bytes[index.advanced(by: 3)]) : 0

    self = val0 | val1 | val2 | val3
  }
}
extension UInt64 {
  @_specialize(exported: false, kind: full, where T == Swift.ArraySlice<Swift.UInt8>)
  @inlinable internal init<T>(bytes: T, fromIndex index: T.Index) where T : Swift.Collection, T.Element == Swift.UInt8, T.Index == Swift.Int {
    if bytes.isEmpty {
      self = 0
      return
    }

    let count = bytes.count

    let val0 = count > 0 ? UInt64(bytes[index.advanced(by: 0)]) << 56 : 0
    let val1 = count > 1 ? UInt64(bytes[index.advanced(by: 1)]) << 48 : 0
    let val2 = count > 2 ? UInt64(bytes[index.advanced(by: 2)]) << 40 : 0
    let val3 = count > 3 ? UInt64(bytes[index.advanced(by: 3)]) << 32 : 0
    let val4 = count > 4 ? UInt64(bytes[index.advanced(by: 4)]) << 24 : 0
    let val5 = count > 5 ? UInt64(bytes[index.advanced(by: 5)]) << 16 : 0
    let val6 = count > 6 ? UInt64(bytes[index.advanced(by: 6)]) << 8 : 0
    let val7 = count > 7 ? UInt64(bytes[index.advanced(by: 7)]) : 0

    self = val0 | val1 | val2 | val3 | val4 | val5 | val6 | val7
  }
}
public protocol _UInt8Type {
}
extension UInt8 : RoomBoxUtils._UInt8Type {
}
extension UInt8 {
  public func bits() -> [RoomBoxUtils.RBBit]
  public func bits() -> Swift.String
}
extension UIView {
  public var subviewMaxPriority: ObjectiveC.NSInteger? {
    get
    set
  }
  public var roomboxScreenshot: UIKit.UIImage? {
    get
  }
  public var subviewSortPriority: ObjectiveC.NSInteger? {
    get
    set
  }
  public func addSubViewAutoSort(_ fro: UIKit.UIView)
}
extension Swift.Array : RoomBoxUtils._RBTransformable {}
extension Swift.Dictionary : RoomBoxUtils._RBTransformable {}
extension RoomBoxUtils.AuthenticationError : Swift.Equatable {}
extension RoomBoxUtils.AuthenticationError : Swift.Hashable {}
extension RoomBoxUtils.RB_NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType : Swift.Equatable {}
extension RoomBoxUtils.RB_NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType : Swift.Hashable {}
extension Swift.String : RoomBoxUtils._RBTransformable {}
extension RoomBoxUtils.RB_URLEncodedFormParameterEncoder.Destination : Swift.Equatable {}
extension RoomBoxUtils.RB_URLEncodedFormParameterEncoder.Destination : Swift.Hashable {}
extension RoomBoxUtils.RB_URLEncoding.Destination : Swift.Equatable {}
extension RoomBoxUtils.RB_URLEncoding.Destination : Swift.Hashable {}
extension RoomBoxUtils.RB_URLEncoding.ArrayEncoding : Swift.Equatable {}
extension RoomBoxUtils.RB_URLEncoding.ArrayEncoding : Swift.Hashable {}
extension RoomBoxUtils.RB_URLEncoding.BoolEncoding : Swift.Equatable {}
extension RoomBoxUtils.RB_URLEncoding.BoolEncoding : Swift.Hashable {}
extension Foundation.NSNumber : RoomBoxUtils._RBTransformable {}
extension RoomBoxUtils.RB_Request.State : Swift.Equatable {}
extension RoomBoxUtils.RB_Request.State : Swift.Hashable {}
extension Swift.Int32 : RoomBoxUtils._RBTransformable {}
extension RoomBoxUtils.RB_URLEncodedFormEncoder.ArrayEncoding : Swift.Equatable {}
extension RoomBoxUtils.RB_URLEncodedFormEncoder.ArrayEncoding : Swift.Hashable {}
extension RoomBoxUtils.RB_URLEncodedFormEncoder.BoolEncoding : Swift.Equatable {}
extension RoomBoxUtils.RB_URLEncodedFormEncoder.BoolEncoding : Swift.Hashable {}
extension RoomBoxUtils.RB_URLEncodedFormEncoder.SpaceEncoding : Swift.Equatable {}
extension RoomBoxUtils.RB_URLEncodedFormEncoder.SpaceEncoding : Swift.Hashable {}
extension RoomBoxUtils.RBAES.Error : Swift.Equatable {}
extension RoomBoxUtils.RBAES.Error : Swift.Hashable {}
extension RoomBoxUtils.RBAES.Variant : Swift.Equatable {}
extension RoomBoxUtils.RBAES.Variant : Swift.Hashable {}
extension RoomBoxUtils.RBAES.Variant : Swift.RawRepresentable {}
extension RoomBoxUtils.RBAnimatedSwitch.CancelBehavior : Swift.Equatable {}
extension RoomBoxUtils.RBAnimatedSwitch.CancelBehavior : Swift.Hashable {}
extension RoomBoxUtils.CoordinateSpace : Swift.Equatable {}
extension RoomBoxUtils.CoordinateSpace : Swift.Hashable {}
extension RoomBoxUtils.CoordinateSpace : Swift.RawRepresentable {}
extension RoomBoxUtils.LottieBackgroundBehavior : Swift.Equatable {}
extension RoomBoxUtils.LottieBackgroundBehavior : Swift.Hashable {}
extension RoomBoxUtils.RBBit : Swift.Equatable {}
extension RoomBoxUtils.RBBit : Swift.Hashable {}
extension RoomBoxUtils.RBBit : Swift.RawRepresentable {}
extension RoomBoxUtils.RBBlowfish.Error : Swift.Equatable {}
extension RoomBoxUtils.RBBlowfish.Error : Swift.Hashable {}
extension Swift.Int : RoomBoxUtils._RBTransformable {}
extension Swift.UInt : RoomBoxUtils._RBTransformable {}
extension Swift.Int8 : RoomBoxUtils._RBTransformable {}
extension Swift.Int16 : RoomBoxUtils._RBTransformable {}
extension Swift.Int64 : RoomBoxUtils._RBTransformable {}
extension Swift.UInt8 : RoomBoxUtils._RBTransformable {}
extension Swift.UInt16 : RoomBoxUtils._RBTransformable {}
extension Swift.UInt32 : RoomBoxUtils._RBTransformable {}
extension Swift.UInt64 : RoomBoxUtils._RBTransformable {}
extension Swift.Bool : RoomBoxUtils._RBTransformable {}
extension Swift.Float : RoomBoxUtils._RBTransformable {}
extension Swift.Double : RoomBoxUtils._RBTransformable {}
extension Swift.Optional : RoomBoxUtils._RBTransformable {}
extension Swift.Set : RoomBoxUtils._RBTransformable {}
extension Foundation.NSString : RoomBoxUtils._RBTransformable {}
extension Foundation.NSArray : RoomBoxUtils._RBTransformable {}
extension Foundation.NSDictionary : RoomBoxUtils._RBTransformable {}
extension RoomBoxUtils.RBCBC.Error : Swift.Equatable {}
extension RoomBoxUtils.RBCBC.Error : Swift.Hashable {}
extension RoomBoxUtils.RBCCM : RoomBoxUtils.RBBlockMode {}
extension RoomBoxUtils.RBCCM.Error : Swift.Equatable {}
extension RoomBoxUtils.RBCCM.Error : Swift.Hashable {}
extension RoomBoxUtils.RBCFB.Error : Swift.Equatable {}
extension RoomBoxUtils.RBCFB.Error : Swift.Hashable {}
extension RoomBoxUtils.RBCFB.SegmentSize : Swift.Equatable {}
extension RoomBoxUtils.RBCFB.SegmentSize : Swift.Hashable {}
extension RoomBoxUtils.RBCFB.SegmentSize : Swift.RawRepresentable {}
extension RoomBoxUtils.RBChaCha20.Error : Swift.Equatable {}
extension RoomBoxUtils.RBChaCha20.Error : Swift.Hashable {}
extension RoomBoxUtils.CipherError : Swift.Equatable {}
extension RoomBoxUtils.CipherError : Swift.Hashable {}
extension RoomBoxUtils.RBCMAC.Error : Swift.Equatable {}
extension RoomBoxUtils.RBCMAC.Error : Swift.Hashable {}
extension RoomBoxUtils.ColorFormatDenominator : Swift.Equatable {}
extension RoomBoxUtils.ColorFormatDenominator : Swift.Hashable {}
extension RoomBoxUtils.DebugMode : Swift.Equatable {}
extension RoomBoxUtils.DebugMode : Swift.Hashable {}
extension RoomBoxUtils.DebugMode : Swift.RawRepresentable {}
extension RoomBoxUtils.RBCTR : RoomBoxUtils.RBBlockMode {}
extension RoomBoxUtils.RBCTR.Error : Swift.Equatable {}
extension RoomBoxUtils.RBCTR.Error : Swift.Hashable {}
extension RoomBoxUtils.RBGCM.Mode : Swift.Equatable {}
extension RoomBoxUtils.RBGCM.Mode : Swift.Hashable {}
extension RoomBoxUtils.RBGCM.Error : Swift.Equatable {}
extension RoomBoxUtils.RBGCM.Error : Swift.Hashable {}
extension RoomBoxUtils.RBHKDF.Error : Swift.Equatable {}
extension RoomBoxUtils.RBHKDF.Error : Swift.Hashable {}
extension RoomBoxUtils.RBHMAC.Error : Swift.Equatable {}
extension RoomBoxUtils.RBHMAC.Error : Swift.Hashable {}
extension RoomBoxUtils.RBHMAC.Variant : Swift.Equatable {}
extension RoomBoxUtils.RBHMAC.Variant : Swift.Hashable {}
extension RoomBoxUtils.LayerType : Swift.Equatable {}
extension RoomBoxUtils.LayerType : Swift.Hashable {}
extension RoomBoxUtils.LayerType : Swift.RawRepresentable {}
extension RoomBoxUtils.MatteType : Swift.Equatable {}
extension RoomBoxUtils.MatteType : Swift.Hashable {}
extension RoomBoxUtils.MatteType : Swift.RawRepresentable {}
extension RoomBoxUtils.BlendMode : Swift.Equatable {}
extension RoomBoxUtils.BlendMode : Swift.Hashable {}
extension RoomBoxUtils.BlendMode : Swift.RawRepresentable {}
extension RoomBoxUtils.RBOCB.Mode : Swift.Equatable {}
extension RoomBoxUtils.RBOCB.Mode : Swift.Hashable {}
extension RoomBoxUtils.RBOCB.Error : Swift.Equatable {}
extension RoomBoxUtils.RBOCB.Error : Swift.Hashable {}
extension RoomBoxUtils.RBOFB.Error : Swift.Equatable {}
extension RoomBoxUtils.RBOFB.Error : Swift.Hashable {}
extension RoomBoxUtils.RBPadding : Swift.Equatable {}
extension RoomBoxUtils.RBPadding : Swift.Hashable {}
extension RoomBoxUtils.RBPKCS5.PBKDF1.Error : Swift.Equatable {}
extension RoomBoxUtils.RBPKCS5.PBKDF1.Error : Swift.Hashable {}
extension RoomBoxUtils.RBPKCS5.PBKDF1.Variant : Swift.Equatable {}
extension RoomBoxUtils.RBPKCS5.PBKDF1.Variant : Swift.Hashable {}
extension RoomBoxUtils.RBPKCS5.PBKDF2.Error : Swift.Equatable {}
extension RoomBoxUtils.RBPKCS5.PBKDF2.Error : Swift.Hashable {}
extension RoomBoxUtils.RBPCBC.Error : Swift.Equatable {}
extension RoomBoxUtils.RBPCBC.Error : Swift.Hashable {}
extension RoomBoxUtils.RBCaptionOptions.CaptionLocation : Swift.Equatable {}
extension RoomBoxUtils.RBCaptionOptions.CaptionLocation : Swift.Hashable {}
extension RoomBoxUtils.RBPoly1305.Error : Swift.Equatable {}
extension RoomBoxUtils.RBPoly1305.Error : Swift.Hashable {}
extension RoomBoxUtils.RBRabbit.Error : Swift.Equatable {}
extension RoomBoxUtils.RBRabbit.Error : Swift.Hashable {}
@available(*, unavailable, renamed: "Connection")
extension RoomBoxUtils.RBReachability.NetworkStatus : Swift.Equatable {}
@available(*, unavailable, renamed: "Connection")
extension RoomBoxUtils.RBReachability.NetworkStatus : Swift.Hashable {}
extension RoomBoxUtils.RBReachability.Connection : Swift.Equatable {}
extension RoomBoxUtils.RBReachability.Connection : Swift.Hashable {}
extension RoomBoxUtils.RBSHA2.Variant : Swift.Equatable {}
extension RoomBoxUtils.RBSHA2.Variant : Swift.Hashable {}
extension RoomBoxUtils.RBSHA3.Variant : Swift.Equatable {}
extension RoomBoxUtils.RBSHA3.Variant : Swift.Hashable {}
extension RoomBoxUtils.RBSignature.DigestType : Swift.Equatable {}
extension RoomBoxUtils.RBSignature.DigestType : Swift.Hashable {}
extension RoomBoxUtils.RBSwiftyJSONError : Swift.Equatable {}
extension RoomBoxUtils.RBSwiftyJSONError : Swift.Hashable {}
extension RoomBoxUtils.RBSwiftyJSONError : Swift.RawRepresentable {}
extension RoomBoxUtils.`Type` : Swift.Equatable {}
extension RoomBoxUtils.`Type` : Swift.Hashable {}
extension RoomBoxUtils.`Type` : Swift.RawRepresentable {}
extension RoomBoxUtils.writingOptionsKeys : Swift.Equatable {}
extension RoomBoxUtils.writingOptionsKeys : Swift.Hashable {}
extension RoomBoxUtils._objc_Signature.DigestType : Swift.Equatable {}
extension RoomBoxUtils._objc_Signature.DigestType : Swift.Hashable {}
extension RoomBoxUtils._objc_Signature.DigestType : Swift.RawRepresentable {}
extension RoomBoxUtils.RoomBoxDevice.Orientation : Swift.Equatable {}
extension RoomBoxUtils.RoomBoxDevice.Orientation : Swift.Hashable {}
extension RoomBoxUtils.RoomBoxDevice.CameraType : Swift.Equatable {}
extension RoomBoxUtils.RoomBoxDevice.CameraType : Swift.Hashable {}
extension RoomBoxUtils.FontWeightStyle : Swift.Equatable {}
extension RoomBoxUtils.FontWeightStyle : Swift.Hashable {}
extension RoomBoxUtils.RoomBoxItemClass : Swift.Equatable {}
extension RoomBoxUtils.RoomBoxItemClass : Swift.Hashable {}
extension RoomBoxUtils.RoomBoxProtocolType : Swift.Equatable {}
extension RoomBoxUtils.RoomBoxProtocolType : Swift.Hashable {}
extension RoomBoxUtils.RoomBoxAuthenticationType : Swift.Equatable {}
extension RoomBoxUtils.RoomBoxAuthenticationType : Swift.Hashable {}
extension RoomBoxUtils.RoomBoxAccessibility : Swift.Equatable {}
extension RoomBoxUtils.RoomBoxAccessibility : Swift.Hashable {}
extension RoomBoxUtils.RoomBoxAuthenticationUI : Swift.Equatable {}
extension RoomBoxUtils.RoomBoxAuthenticationUI : Swift.Hashable {}
extension RoomBoxUtils.Status : Swift.Equatable {}
extension RoomBoxUtils.Status : Swift.Hashable {}
